<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title data-i18n-key="app.title">NodeVision Editor</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background-color: #0b0c10;
        color: #f5f7fb;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        background: #101114;
        color: #f2f3f7;
      }
      header {
        padding: 16px 24px;
        background: linear-gradient(180deg, #1e2026, #17191f);
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
      }
      header ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        gap: 24px;
        flex-wrap: wrap;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.8);
      }
      main {
        --sidebar-collapsed-width: 72px;
        --sidebar-expanded-width: 392px;
        --sidebar-width: var(--sidebar-collapsed-width);
        --panel-width: calc(var(--sidebar-expanded-width) - var(--sidebar-collapsed-width));
        flex: 1;
        display: grid;
        grid-template-columns: var(--sidebar-width) 1fr;
        min-height: 0;
        transition: grid-template-columns 220ms ease;
      }
      main.sidebar-open {
        --sidebar-width: var(--sidebar-expanded-width);
      }
      .sidebar {
        border-right: 1px solid rgba(255, 255, 255, 0.04);
        background: linear-gradient(180deg, #141518, #101113);
        display: flex;
        min-height: 0;
        width: var(--sidebar-width);
        min-width: var(--sidebar-width);
        transition: width 220ms ease;
      }
      .sidebar-icons {
        width: 72px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        padding: 12px 0;
      }
      .sidebar-icon {
        width: 56px;
        height: 56px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: border 150ms ease, background 150ms ease, transform 150ms ease;
      }
      .sidebar-icon-symbol {
        width: 44px;
        height: 44px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .sidebar-icon-symbol svg {
        width: 100%;
        height: 100%;
        fill: none;
        stroke: currentColor;
        stroke-width: 1.7;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .sidebar-icon-symbol img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      .sidebar-icon:focus-visible {
        outline: 2px solid #7dc3ff;
        outline-offset: 3px;
      }
      .sidebar-icon.active {
        border-color: rgba(255, 223, 107, 0.9);
        background: rgba(255, 223, 107, 0.18);
        color: #ffe089;
        transform: translateX(4px);
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: visible;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      .sidebar-panel-container {
        flex: 0 0 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 16px;
        opacity: 0;
        pointer-events: none;
        padding: 0;
        background: linear-gradient(180deg, #1a1b21, #111218);
        border-left: 1px solid rgba(255, 255, 255, 0.06);
        box-shadow: none;
        transition:
          flex-basis 220ms ease,
          opacity 200ms ease,
          padding 200ms ease,
          box-shadow 200ms ease;
      }
      main.sidebar-open .sidebar-panel-container {
        flex: 0 0 var(--panel-width);
        padding: 20px 24px 24px;
        opacity: 1;
        pointer-events: auto;
        box-shadow: 12px 0 24px rgba(0, 0, 0, 0.35);
      }
      .sidebar-panel {
        display: none;
        flex-direction: column;
        gap: 16px;
        min-height: 0;
      }
      .sidebar-panel.active {
        display: flex;
      }
      .canvas-wrap {
        position: relative;
        overflow: hidden;
        background-color: #14151b;
        --grid-minor-size: 8px;
        --grid-major-size: 32px;
        --grid-offset-x: 0px;
        --grid-offset-y: 0px;
      }
      #canvas-grid {
        position: absolute;
        inset: 0;
        pointer-events: none;
        background-color: #16171c;
        background-image:
          linear-gradient(var(--grid-minor-angle-x, 90deg), rgba(255, 255, 255, 0.02) 1px, transparent 1px),
          linear-gradient(var(--grid-minor-angle-y, 0deg), rgba(255, 255, 255, 0.02) 1px, transparent 1px),
          linear-gradient(var(--grid-major-angle-x, 90deg), rgba(255, 255, 255, 0.045) 1px, transparent 1px),
          linear-gradient(var(--grid-major-angle-y, 0deg), rgba(255, 255, 255, 0.045) 1px, transparent 1px);
        background-size:
          var(--grid-minor-size) var(--grid-minor-size),
          var(--grid-minor-size) var(--grid-minor-size),
          var(--grid-major-size) var(--grid-major-size),
          var(--grid-major-size) var(--grid-major-size);
        background-position:
          var(--grid-offset-x) var(--grid-offset-y),
          var(--grid-offset-x) var(--grid-offset-y),
          var(--grid-offset-x) var(--grid-offset-y),
          var(--grid-offset-x) var(--grid-offset-y);
        z-index: 0;
      }
      #canvas {
        position: absolute;
        inset: 0;
        cursor: default;
        transform-origin: 0 0;
        z-index: 1;
      }
      body[data-canvas-tool='pan'] #canvas {
        cursor: grab;
      }
      body[data-canvas-tool='pan'].is-panning #canvas {
        cursor: grabbing;
      }
      #canvas.zooming {
        cursor: zoom-in;
      }
      #node-layer,
      #connection-layer {
        position: absolute;
        inset: 0;
      }
      #node-layer {
        min-height: 100%;
      }
      #connection-layer {
        pointer-events: none;
        overflow: visible;
      }
      #selection-rect {
        position: absolute;
        border: 1px solid rgba(77, 115, 255, 0.9);
        background: rgba(77, 115, 255, 0.25);
        border-radius: 10px;
        pointer-events: none;
        display: none;
        z-index: 2;
      }
      #selection-outline {
        position: absolute;
        border: 2px dashed rgba(255, 255, 255, 0.5);
        border-radius: 18px;
        pointer-events: auto;
        display: none;
        z-index: 1;
        cursor: move;
      }
      .canvas-controls {
        position: fixed;
        left: 24px;
        bottom: 24px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: rgba(7, 9, 15, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 999px;
        padding: 6px 12px;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(14px);
        z-index: 10;
        cursor: grab;
        touch-action: none;
      }
      .canvas-controls.is-dragging {
        cursor: grabbing;
      }
      .canvas-tool {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(7, 9, 15, 0.85);
        color: #f5f7ff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        cursor: pointer;
        transition: background 180ms ease, color 180ms ease, border 180ms ease, transform 180ms ease;
      }
      .canvas-tool:hover,
      .canvas-tool:focus-visible {
        background: rgba(255, 223, 107, 0.18);
        border-color: rgba(255, 223, 107, 0.35);
        color: #ffe089;
      }
      .canvas-tool:focus-visible {
        outline: 2px solid #6ea8ff;
        outline-offset: 2px;
      }
      .canvas-tool:active {
        background: rgba(255, 223, 107, 0.28);
        border-color: rgba(255, 223, 107, 0.55);
        color: #fff2c1;
      }
      .canvas-tool.active {
        background: rgba(255, 223, 107, 0.28);
        border-color: rgba(255, 223, 107, 0.55);
        color: #fff2c1;
        box-shadow: 0 6px 20px rgba(15, 16, 24, 0.4);
      }
      .canvas-tool-icon {
        width: 46px;
        height: 46px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
      }
      .canvas-tool-icon img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      .canvas-controls-divider {
        width: 1px;
        height: 32px;
        background: rgba(255, 255, 255, 0.08);
      }
      .zoom-control {
        position: relative;
      }
      #zoom-display {
        min-width: 76px;
        height: 36px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(23, 24, 32, 0.75);
        color: #f5f7ff;
        padding: 0 16px;
        font-size: 15px;
        transition: border 150ms ease, background 150ms ease, color 150ms ease;
        outline: none;
      }
      #zoom-display[aria-expanded='true'],
      #zoom-display:hover,
      #zoom-display:focus-visible {
        background: rgba(255, 223, 107, 0.18);
        border-color: rgba(255, 223, 107, 0.35);
        color: #ffe089;
      }
      #zoom-display:active {
        background: rgba(255, 223, 107, 0.28);
        border-color: rgba(255, 223, 107, 0.55);
        color: #fff2c1;
      }
      #zoom-menu {
        position: absolute;
        right: 0;
        bottom: calc(100% + 8px);
        width: 260px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(8, 11, 19, 0.98);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.55);
        padding: 12px;
        display: none;
        flex-direction: column;
        gap: 6px;
      }
      #zoom-menu[data-open='true'] {
        display: flex;
      }
      #zoom-menu button {
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(19, 22, 33, 0.95);
        color: #f5f7ff;
        transition: background 160ms ease, border 160ms ease, color 160ms ease;
        outline: none;
        width: 100%;
        padding: 9px 12px;
        font-size: 15px;
        text-align: left;
        white-space: nowrap;
      }
      #zoom-menu button:hover,
      #zoom-menu button:focus-visible {
        background: rgba(255, 223, 107, 0.18);
        border-color: rgba(255, 223, 107, 0.35);
        color: #ffe089;
      }
      #zoom-menu button:active {
        background: rgba(255, 223, 107, 0.28);
        border-color: rgba(255, 223, 107, 0.55);
        color: #fff2c1;
      }
      #zoom-menu hr {
        border: none;
        height: 1px;
        background: rgba(255, 255, 255, 0.08);
        margin: 6px 0;
      }
      .zoom-input-row {
        display: flex;
        gap: 8px;
        margin-top: 4px;
      }
      #zoom-input {
        flex: 1;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(13, 15, 23, 0.95);
        color: #f5f7ff;
        padding: 8px 12px;
        font-size: 15px;
      }
      #zoom-input:focus-visible {
        outline: 2px solid #6ea8ff;
        outline-offset: 2px;
      }
      #zoom-apply {
        border-radius: 10px;
        border: none;
        padding: 8px 14px;
        font-size: 15px;
        background: #4d73ff;
        color: #fff;
        box-shadow: 0 6px 14px rgba(77, 115, 255, 0.4);
      }
      .node {
        position: absolute;
        border-radius: 18px;
        padding: 0 0 14px;
        min-width: 336px;
        min-height: 460px;
        background: linear-gradient(180deg, #fafafa, #e6e6ea);
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 12px 34px rgba(78, 86, 107, 0.35);
        color: #2b2c31;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow: hidden;
        transition: border 160ms ease, box-shadow 160ms ease, transform 160ms ease;
      }
      body.node-dragging .node {
        transition: border 160ms ease, box-shadow 160ms ease;
      }
      .node::after {
        content: '';
        position: absolute;
        inset: 4px;
        border-radius: 14px;
        border: 2px solid transparent;
        pointer-events: none;
        opacity: 0;
        transition: border-color 150ms ease, opacity 150ms ease, box-shadow 150ms ease;
      }
      .node-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 12px 18px 6px;
        background: linear-gradient(180deg, #fefefe, #ececef);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        position: relative;
      }
      .node-header-main {
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex: 1;
      }
      button.node-delete-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: none;
        padding: 0;
        background: #ff5662;
        color: transparent;
        font-size: 0;
        line-height: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: none;
        transition: none;
        appearance: none;
        -webkit-appearance: none;
      }
      button.node-delete-btn:focus-visible {
        outline: 1px solid rgba(255, 255, 255, 0.8);
        outline-offset: 2px;
      }
      button.node-delete-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .node-title {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 0.01em;
        color: #1f1f24;
      }
      .node-meta {
        margin: 0;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(48, 48, 60, 0.5);
      }
      .node-description {
        margin: 0;
        font-size: 12px;
        color: rgba(48, 48, 60, 0.7);
      }
      .node-chip {
        display: inline-flex;
        align-items: center;
        padding: 2px 10px;
        border-radius: 999px;
        font-size: 11px;
        background: rgba(97, 97, 110, 0.15);
        color: rgba(48, 48, 60, 0.85);
      }
      .node-resize-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(33, 119, 255, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 6px 12px rgba(33, 119, 255, 0.4);
        cursor: pointer;
        z-index: 2;
      }
      .node-resize-nw {
        top: -8px;
        left: -8px;
        cursor: nwse-resize;
      }
      .node-resize-ne {
        top: -8px;
        right: -8px;
        cursor: nesw-resize;
      }
      .node-resize-sw {
        bottom: -8px;
        left: -8px;
        cursor: nesw-resize;
      }
      .node-resize-se {
        bottom: -8px;
        right: -8px;
        cursor: nwse-resize;
      }
      .node.node-highlight,
      .node.node-pressed {
        border-color: rgba(255, 223, 107, 0.8);
        box-shadow: 0 0 0 3px rgba(255, 223, 107, 0.35), 0 18px 32px rgba(0, 0, 0, 0.4);
      }
      .node.node-highlight::after,
      .node.node-pressed::after {
        border-color: rgba(255, 223, 107, 0.95);
        opacity: 1;
        box-shadow: 0 0 18px rgba(255, 223, 107, 0.6);
      }
      @keyframes nodeGlow {
        0% {
          border-color: rgba(255, 223, 107, 0.65);
          box-shadow: 0 0 12px rgba(255, 223, 107, 0.35);
        }
        100% {
          border-color: rgba(255, 244, 201, 1);
          box-shadow: 0 0 28px rgba(255, 244, 201, 0.95);
        }
      }
      .node-highlight {
        animation: nodeGlow 1.2s ease-in-out infinite alternate;
      }
      .node-ports {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 8px 18px 0;
        gap: 12px;
      }
      .node-info {
        margin: 6px 18px 10px;
        padding: 10px 12px;
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.7);
        color: #1f1f24;
        font-size: 12px;
        line-height: 1.4;
      }
      .node-info-heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        font-weight: 600;
        font-size: 12px;
        margin-bottom: 4px;
      }
      .node-info-chip {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        background: rgba(0, 0, 0, 0.08);
        padding: 2px 8px;
        border-radius: 999px;
      }
      .node-info-desc {
        margin: 4px 0 8px;
        color: rgba(31, 31, 36, 0.75);
      }
      .node-info-tip {
        margin: 8px 0 0;
        font-size: 11px;
        color: rgba(31, 31, 36, 0.8);
      }
      .node-status-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .node-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        border-radius: 8px;
        border: 1px solid rgba(0, 0, 0, 0.06);
        padding: 6px 8px;
        font-size: 11px;
      }
      .node-status-ok {
        background: rgba(52, 199, 89, 0.18);
        color: #116229;
      }
      .node-status-warn {
        background: rgba(255, 149, 0, 0.18);
        color: #7d3a00;
      }
      #status-list {
        display: none;
      }
      .node-ports .ports {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .node-ports .ports.input {
        align-items: flex-start;
      }
      .node-ports .ports.output {
        align-items: flex-end;
      }
      /* Load node styles */
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media {
        padding: 0 18px 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        border-top: 1px solid rgba(0, 0, 0, 0.05);
        padding-top: 12px;
        flex: 1 1 auto;
        min-height: 0;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia) .node-media-upload {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 10px 18px;
        border-radius: 12px;
        border: 1px solid rgba(0, 0, 0, 0.18);
        background: linear-gradient(180deg, #dcdfe8, #bec4d8);
        color: #1d2333;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        overflow: hidden;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia) .node-media-upload.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia) .node-media-upload span {
        pointer-events: none;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia) .node-media-upload input[type="file"] {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia) .node-media-upload input[type="file"]:disabled {
        cursor: not-allowed;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-empty {
        margin: 0;
        font-size: 12px;
        color: rgba(48, 48, 60, 0.6);
        text-align: center;
        padding: 6px 0 2px;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-frame {
        width: 100%;
        display: flex;
        justify-content: center;
        flex: 1 1 auto;
        min-height: 0;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-preview {
        border: none;
        border-radius: 0;
        overflow: hidden;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        width: min(100%, var(--preview-width, 320px));
        height: min(var(--preview-height, 240px), 100%);
        max-width: 100%;
        max-height: 100%;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-preview img,
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-preview video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: transparent;
        border-radius: 0;
        box-shadow: none;
        max-width: 100%;
        max-height: 100%;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-toolbar {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 8px;
        align-items: center;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia) .node-media-arrow {
        border-radius: 999px;
        width: 32px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: 600;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-filename {
        border: 1px solid rgba(0, 0, 0, 0.15);
        border-radius: 999px;
        padding: 4px 12px;
        background: rgba(255, 255, 255, 0.65);
        font-size: 12px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .node:is(.node-type-loadimage, .node-type-loadvideo, .node-type-loadmedia, .node-type-mediapreview) .node-media-aspect {
        margin: 10px 0 0;
        font-size: 13px;
        text-align: center;
        color: rgba(48, 48, 60, 0.85);
        font-weight: 600;
      }
      .node-media-hints {
        margin: 6px 0 0;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .node-media-hint {
        margin: 0;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
      }
      .node-media-hint.accent {
        font-weight: 600;
        color: rgba(255, 224, 137, 0.9);
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .trim-launcher {
        margin-top: 16px;
        padding: 16px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.12));
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .trim-launcher-buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .trim-launcher-btn {
        flex: 1 1 120px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        font-weight: 600;
        padding: 10px 16px;
        cursor: pointer;
        transition: background 150ms ease, border-color 150ms ease;
      }
      .trim-launcher-btn:hover,
      .trim-launcher-btn:focus-visible {
        border-color: rgba(255, 224, 137, 0.9);
        background: rgba(255, 224, 137, 0.15);
        outline: none;
      }
      .trim-launcher-status {
        margin: 0;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.85);
      }
      .nv-modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(6, 6, 10, 0.75);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 24px;
      }
      .nv-modal-backdrop[data-open='true'] {
        display: flex;
      }
      .nv-modal {
        width: min(880px, calc(100vw - 40px));
        max-height: min(96vh, 940px);
        overflow: visible;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: #11121a;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 20px;
        padding: 28px 36px 40px;
      }
      .nv-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .nv-modal-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }
      .nv-modal-close {
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        width: 34px;
        height: 34px;
        border-radius: 999px;
        font-size: 18px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        cursor: pointer;
      }
      .nv-modal-close:hover,
      .nv-modal-close:focus-visible {
        background: rgba(255, 224, 137, 0.3);
        outline: none;
      }
      .nv-modal-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
        overflow: visible;
      }
      .trim-modal-placeholder {
        margin: 0;
        padding: 40px 0;
        text-align: center;
        font-size: 15px;
        color: rgba(255, 255, 255, 0.85);
      }
      .trim-image-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      .trim-image-toolbar-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .trim-tool-button {
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        font-size: 13px;
        padding: 8px 12px;
        cursor: pointer;
        min-height: 36px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1.2;
      }
      .trim-tool-button[data-active='true'] {
        background: rgba(255, 224, 137, 0.2);
        border-color: rgba(255, 224, 137, 0.8);
      }
      .trim-tool-button[data-trim-tool='zoom-in'],
      .trim-tool-button[data-trim-tool='zoom-out'] {
        width: 42px;
        padding: 0;
        font-size: 18px;
      }
      .trim-stage-wrapper {
        position: relative;
        width: 100%;
        padding: 12px 0 28px;
      }
      .trim-image-stage {
        position: relative;
        width: 100%;
        aspect-ratio: var(--trim-image-aspect, 16 / 9);
        max-height: min(58vh, 480px);
        border-radius: 24px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.04);
        margin: 0 auto 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      }
      .trim-grid-overlay {
        position: absolute;
        inset: 0;
        border-radius: 24px;
        pointer-events: none;
        background-size: 20px 20px;
        background-image: linear-gradient(rgba(255, 255, 255, 0.08) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.08) 1px, transparent 1px);
        opacity: 0;
        transition: opacity 150ms ease;
      }
      .trim-grid-overlay.is-visible {
        opacity: 1;
      }
      .trim-image-stage img {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: contain;
        user-select: none;
        pointer-events: none;
      }
      .trim-image-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin: 8px 0 12px;
      }
      .trim-control {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 16px;
        padding: 12px 14px;
      }
      .trim-control label {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 13px;
      }
      .trim-control-inputs {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .trim-control-inputs input[type='range'] {
        flex: 1;
      }
      .trim-control-inputs input[type='number'] {
        width: 64px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        padding: 6px 8px;
      }
      .trim-control-badge {
        border-radius: 999px;
        padding: 4px 12px;
        background: rgba(255, 255, 255, 0.08);
        font-size: 12px;
      }
      .trim-control-unit {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
      }
      .trim-control select {
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        padding: 8px 10px;
      }
      .trim-crop-box {
        position: absolute;
        border: 4px solid #ffe089;
        box-sizing: border-box;
        border-radius: 0;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.35);
        cursor: move;
      }
      .trim-crop-handle {
        position: absolute;
        background: #ffe089;
        border: 2px solid #11121a;
        border-radius: 999px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
      }
      .trim-crop-handle[data-trim-handle='nw'],
      .trim-crop-handle[data-trim-handle='ne'],
      .trim-crop-handle[data-trim-handle='sw'],
      .trim-crop-handle[data-trim-handle='se'] {
        width: 22px;
        height: 22px;
      }
      .trim-crop-handle[data-trim-handle='nw'] {
        top: -12px;
        left: -12px;
        cursor: nwse-resize;
      }
      .trim-crop-handle[data-trim-handle='ne'] {
        top: -12px;
        right: -12px;
        cursor: nesw-resize;
      }
      .trim-crop-handle[data-trim-handle='sw'] {
        bottom: -12px;
        left: -12px;
        cursor: nesw-resize;
      }
      .trim-crop-handle[data-trim-handle='se'] {
        bottom: -12px;
        right: -12px;
        cursor: nwse-resize;
      }
      .trim-crop-handle[data-trim-handle='n'],
      .trim-crop-handle[data-trim-handle='s'] {
        width: 52px;
        height: 14px;
      }
      .trim-crop-handle[data-trim-handle='n'] {
        top: -9px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }
      .trim-crop-handle[data-trim-handle='s'] {
        bottom: -9px;
        left: 50%;
        transform: translateX(-50%);
        cursor: ns-resize;
      }
      .trim-crop-handle[data-trim-handle='w'],
      .trim-crop-handle[data-trim-handle='e'] {
        width: 14px;
        height: 52px;
      }
      .trim-crop-handle[data-trim-handle='w'] {
        left: -9px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
      .trim-crop-handle[data-trim-handle='e'] {
        right: -9px;
        top: 50%;
        transform: translateY(-50%);
        cursor: ew-resize;
      }
      .trim-modal-hint {
        margin: 0;
        padding-bottom: 8px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.75);
        text-align: center;
      }
      .trim-modal-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      .trim-modal-actions-spacer {
        flex: 1;
      }
      .trim-video-layout {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-bottom: 12px;
      }
      @media (min-width: 720px) {
        .trim-video-layout {
          flex-direction: row;
        }
      }
      .trim-video-preview {
        flex: 1;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.03);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .trim-video-preview.is-empty {
        border-style: dashed;
        border-color: rgba(255, 255, 255, 0.2);
      }
      .trim-video-preview video {
        width: 100%;
        border-radius: 16px;
        background: #000;
        display: block;
        min-height: 200px;
      }
      .trim-video-preview-empty {
        min-height: 200px;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        text-align: center;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.75);
      }
      .trim-video-preview-meta {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
        gap: 12px;
      }
      .trim-video-preview-name {
        font-weight: 600;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .trim-video-fields {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 12px;
      }
      .trim-video-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.85);
      }
      .trim-video-field input {
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.06);
        padding: 10px 12px;
        color: inherit;
        font-size: 14px;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Consolas, monospace;
      }
      .trim-video-field input:disabled {
        opacity: 0.5;
      }
      .trim-video-checkbox {
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 12px;
        display: flex;
        gap: 10px;
        align-items: flex-start;
      }
      .trim-video-checkbox input {
        margin-top: 4px;
      }
      .trim-video-checkbox small {
        display: block;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
      }
      .trim-video-timeline {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .trim-video-timeline[data-disabled='true'] {
        opacity: 0.5;
        pointer-events: none;
      }
      .trim-video-track {
        position: relative;
        height: 36px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .trim-video-range {
        position: absolute;
        top: 4px;
        bottom: 4px;
        left: 12px;
        width: calc(100% - 24px);
        border-radius: 999px;
        background: rgba(255, 224, 137, 0.2);
        border: 1px solid rgba(255, 224, 137, 0.9);
      }
      .trim-video-handle {
        position: absolute;
        top: -6px;
        width: 14px;
        height: 48px;
        border-radius: 999px;
        border: none;
        background: #ffe089;
        cursor: ew-resize;
      }
      .trim-video-handle[data-trim-video-handle='start'] {
        left: -7px;
      }
      .trim-video-handle[data-trim-video-handle='end'] {
        right: -7px;
      }
      .trim-video-timecodes {
        display: flex;
        justify-content: space-between;
        font-family: 'JetBrains Mono', 'SFMono-Regular', Consolas, monospace;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.8);
      }
      .trim-video-actions {
        flex-wrap: wrap;
      }
      .trim-video-transport {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .pill-button.primary {
        background: #ffe089;
        color: #11121a;
        border: none;
      }
      button, .pill-button {
        border: none;
        border-radius: 999px;
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        font-size: 13px;
        cursor: pointer;
        transition: background 120ms ease;
      }
      button.node-delete-btn,
      button.node-delete-btn:hover,
      button.node-delete-btn:focus,
      button.node-delete-btn:focus-visible {
        background: #ff5662 !important;
        color: transparent;
      }
      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      button:hover:not(:disabled), .pill-button:hover:not(.disabled) {
        background: rgba(255, 255, 255, 0.18);
      }
      .toolbar {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .workflow-dropdown {
        position: relative;
      }
      #workflow-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 14px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(5, 9, 20, 0.7);
        color: #f5f7ff;
      }
      #workflow-toggle span.chevron {
        font-size: 10px;
        opacity: 0.7;
      }
      #workflow-menu {
        position: absolute;
        top: calc(100% + 6px);
        left: 0;
        min-width: 220px;
        background: rgba(8, 11, 19, 0.98);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        padding: 8px;
        display: none;
        flex-direction: column;
        gap: 2px;
        z-index: 30;
      }
      #workflow-menu[data-open='true'] {
        display: flex;
      }
      #workflow-menu button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: none;
        background: transparent;
        color: #f5f7ff;
        display: flex;
        justify-content: flex-start;
        gap: 8px;
        font-size: 13px;
      }
      #workflow-menu button:hover {
        background: rgba(255, 255, 255, 0.08);
      }
      .workflow-panel {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .workflow-panel header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      #workflow-create {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
      }
      #workflow-search {
        width: 100%;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(12, 15, 23, 0.85);
        color: inherit;
      }
      #workflow-empty {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
      }
      #workflow-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      #workflow-list button {
        width: 100%;
        text-align: left;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(16, 19, 28, 0.8);
        padding: 10px 12px;
        color: inherit;
      }
      #workflow-list button.active {
        border-color: rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.12);
      }
      .workflow-item-name {
        font-size: 13px;
        font-weight: 600;
      }
      .workflow-item-meta {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
      }
      #workflow-context-menu {
        position: fixed;
        min-width: 180px;
        background: rgba(5, 8, 15, 0.96);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        padding: 6px;
        display: none;
        flex-direction: column;
        gap: 4px;
        z-index: 90;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      }
      #workflow-context-menu[data-open='true'] {
        display: flex;
      }
      #workflow-context-menu button {
        width: 100%;
        border: none;
        border-radius: 10px;
        padding: 8px 10px;
        background: transparent;
        color: #f5f7ff;
        text-align: left;
        font-size: 13px;
      }
      #workflow-context-menu button:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      .toolbar-group {
        display: inline-flex;
        gap: 4px;
        background: rgba(255, 255, 255, 0.05);
        padding: 4px;
        border-radius: 999px;
      }
      .toolbar-group.align-controls {
        display: none;
      }
      .locale-group {
        align-items: center;
        gap: 8px;
      }
      .locale-group label {
        font-size: 12px;
        letter-spacing: 0.01em;
      }
      .locale-group select {
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(5, 7, 12, 0.9);
        color: inherit;
        padding: 4px 10px;
        font-size: 12px;
      }
      .search-box input {
        width: 100%;
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(12, 15, 23, 0.8);
        color: inherit;
        font-size: 14px;
      }
      .suggestions {
        list-style: none;
        padding: 0;
        margin: 8px 0 0;
        max-height: 180px;
        overflow: auto;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(8, 10, 16, 0.9);
      }
      .suggestions li {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        cursor: pointer;
      }
      .suggestions li:last-child {
        border-bottom: none;
      }
      .suggestions li.active {
        background: rgba(78, 158, 255, 0.16);
      }
      .help-card {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 16px;
        background: rgba(13, 16, 25, 0.9);
        font-size: 13px;
      }
      .queue-card,
      .diagnostics-card,
      .connections-card {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 16px;
        background: rgba(13, 16, 25, 0.85);
        display: flex;
        flex-direction: column;
        gap: 10px;
        font-size: 12px;
      }
      .queue-card header,
      .diagnostics-card header,
      .connections-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .about-card {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 16px;
        background: rgba(13, 16, 25, 0.85);
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 13px;
      }
      .about-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .about-card dl {
        margin: 0;
      }
      .about-card dt {
        font-size: 10px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
      }
      .about-card dd {
        margin: 2px 0 10px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.9);
      }
      .about-card .mono {
        font-family: 'JetBrains Mono', 'SFMono-Regular', monospace;
        word-break: break-all;
      }
      .about-links {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .about-links a {
        color: #88b6ff;
        font-size: 12px;
      }
      .queue-lists {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .queue-section {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 8px;
      }
      .queue-section strong {
        font-size: 11px;
        letter-spacing: 0.02em;
      }
      .queue-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 2px 0;
      }
      .queue-badge {
        display: inline-flex;
        padding: 2px 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        font-size: 11px;
      }
      .connections-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 12px;
      }
      .connections-list li {
        display: block;
      }
      .connection-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .connection-row input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: #ffd166;
        cursor: pointer;
      }
      .connection-row span {
        flex: 1;
      }
      .connection-row input[type="checkbox"]:checked + span {
        color: #ffe6a1;
      }
      .connections-list .connections-empty {
        opacity: 0.7;
      }
      .pending-hint {
        font-size: 11px;
        color: #ffd166;
      }
      .ports {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex: 1;
      }
      .ports.inputs,
      .ports.outputs {
        align-items: stretch;
      }
      .port {
        border: none;
        background: transparent;
        color: #1f1f24;
        font-size: 13px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 8px;
        padding: 4px 4px;
        min-width: 120px;
      }
      .port.port-input {
        flex-direction: row;
        justify-content: flex-start;
      }
      .port.port-output {
        flex-direction: row;
        justify-content: flex-end;
      }
      .port-label {
        font-weight: 600;
        font-size: 13px;
        color: #232329;
      }
      .port:focus-visible {
        outline: 2px solid #4e9eff;
        outline-offset: 2px;
      }
      .port-dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 2px solid rgba(66, 66, 88, 0.4);
        background: rgba(66, 66, 88, 0.2);
        box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.15);
        flex-shrink: 0;
      }
      .port-connected {
        border-color: rgba(143, 160, 228, 0.8);
        box-shadow: 0 0 0 2px rgba(143, 160, 228, 0.25);
      }
      .port-connected .port-dot {
        background: rgba(143, 160, 228, 0.6);
      }
      .port-pending {
        border-color: rgba(255, 209, 102, 0.9);
        box-shadow: 0 0 0 2px rgba(255, 209, 102, 0.4);
      }
      .port-drop-target {
        border-color: rgba(126, 194, 255, 0.85);
        box-shadow: 0 0 0 2px rgba(126, 194, 255, 0.35), 0 0 18px rgba(126, 194, 255, 0.25);
      }
      .port-drop-target .port-dot {
        border-color: rgba(126, 194, 255, 0.9);
        background: rgba(126, 194, 255, 0.35);
      }
      .port-placeholder {
        display: none;
      }
      #connection-layer path {
        fill: none;
        stroke: rgba(186, 199, 227, 0.9);
        stroke-width: 4px;
        stroke-linecap: round;
        filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.35));
      }
      @keyframes connectionGlow {
        0% {
          stroke-width: 4px;
          stroke: rgba(255, 223, 107, 0.85);
          filter: drop-shadow(0 0 8px rgba(255, 223, 107, 0.45));
        }
        100% {
          stroke-width: 8px;
          stroke: rgba(255, 244, 201, 1);
          filter: drop-shadow(0 0 22px rgba(255, 244, 201, 0.95));
        }
      }
      #connection-layer path.connection-highlight {
        stroke: rgba(255, 244, 201, 1);
        animation: connectionGlow 1.2s ease-in-out infinite alternate;
      }
      #connection-layer .connection-preview {
        stroke: rgba(255, 209, 102, 0.9);
        stroke-dasharray: 8 6;
      }
      .pill-button.pill-danger {
        border: 1px solid rgba(255, 82, 82, 0.55);
        background: rgba(255, 82, 82, 0.15);
      }
      .queue-alerts {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 8px;
        background: rgba(255, 183, 77, 0.08);
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 12px;
      }
      .queue-warning {
        display: flex;
        flex-direction: column;
        gap: 2px;
        border-left: 3px solid rgba(255, 255, 255, 0.2);
        padding-left: 8px;
      }
      .queue-warning strong {
        font-size: 11px;
        letter-spacing: 0.05em;
      }
      .queue-warning-warn {
        border-left-color: #ffb347;
      }
      .queue-warning-error {
        border-left-color: #ff5e7a;
      }
      .queue-warning-info {
        border-left-color: #4e9eff;
      }
      .history-time {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
      }
      #queue-history,
      #inspect-history {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .history-row {
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        padding-bottom: 6px;
      }
      .history-row:last-child {
        border-bottom: none;
      }
      .history-row-main {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
      }
      .history-job {
        font-weight: 600;
      }
      .history-message {
        margin: 4px 0 0;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.75);
      }
      .log-level-badge {
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 10px;
        letter-spacing: 0.08em;
      }
      .log-info {
        background: rgba(78, 158, 255, 0.2);
      }
      .log-warn {
        background: rgba(255, 183, 77, 0.2);
      }
      .log-error {
        background: rgba(255, 110, 110, 0.2);
      }
      .inspect-row {
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        padding-bottom: 6px;
      }
      .inspect-row:last-child {
        border-bottom: none;
      }
      .inspect-row-main,
      .inspect-row-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .inspect-row-meta {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.7);
      }
      .diagnostics-export {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      #log-password {
        flex: 1;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(6, 8, 14, 0.6);
        color: inherit;
        padding: 6px 12px;
      }
      #toast {
        position: fixed;
        right: 24px;
        bottom: 24px;
        min-width: 200px;
        max-width: 360px;
        background: rgba(44, 132, 255, 0.95);
        color: #fff;
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 13px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        display: none;
      }
      #toast.error {
        background: rgba(255, 82, 82, 0.95);
      }
      #toast.visible {
        display: block;
      }
      .help-card table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }
      .help-card td {
        padding: 4px 0;
        color: rgba(255, 255, 255, 0.75);
      }
      #autosave-indicator {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
      }
      #json-panel {
        display: none;
      }
      #project-json {
        display: none;
      }
      .readonly-banner {
        display: none;
        padding: 10px 14px;
        border-radius: 10px;
        background: rgba(255, 183, 77, 0.15);
        color: #ffdca8;
        font-size: 13px;
      }
      .readonly .readonly-banner {
        display: block;
      }
      .readonly #canvas,
      .readonly button[data-align],
      .readonly .toolbar button {
        pointer-events: none;
        opacity: 0.5;
      }
      .banner {
        padding: 10px 14px;
        border-radius: 10px;
        background: rgba(78, 158, 255, 0.18);
        font-size: 13px;
      }
      #workflow-name-dialog {
        position: fixed;
        inset: 0;
        background: rgba(5, 8, 15, 0.76);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }
      #workflow-name-dialog[data-open='true'] {
        display: flex;
      }
      .workflow-dialog-card {
        width: min(360px, calc(100vw - 48px));
        background: rgba(10, 14, 22, 0.95);
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 20px;
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .workflow-dialog-card h3 {
        margin: 0;
        font-size: 18px;
      }
      #workflow-name-input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(3, 6, 14, 0.9);
        color: inherit;
        font-size: 14px;
      }
      #workflow-name-input[data-invalid='true'] {
        border-color: rgba(255, 109, 122, 0.9);
        box-shadow: 0 0 0 1px rgba(255, 109, 122, 0.4);
      }
      .workflow-dialog-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }
      .workflow-dialog-actions button {
        padding: 8px 16px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
      }
      .workflow-dialog-actions button.primary {
        background: rgba(99, 132, 255, 0.35);
        border-color: rgba(99, 132, 255, 0.55);
      }
      @media (max-width: 1100px) {
        main {
          --sidebar-collapsed-width: 56px;
          --sidebar-expanded-width: min(420px, calc(100vw - 80px));
        }
        .sidebar {
          border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }
        .sidebar-icons {
          flex-direction: row;
          justify-content: center;
          width: auto;
        }
        .sidebar-icon.active {
          transform: translateY(-4px);
        }
        #json-panel {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <ul id="status-list"></ul>
      <div class="toolbar">
        <div class="workflow-dropdown">
          <button type="button" id="workflow-toggle" aria-haspopup="true" aria-expanded="false">
            <span id="workflow-name-label">Unsaved Workflow</span>
            <span class="chevron"></span>
          </button>
          <div id="workflow-menu" role="menu" aria-hidden="true">
            <button type="button" id="workflow-menu-rename" data-workflow-action="rename" data-i18n-key="workflow.menu.rename">Rename</button>
            <button type="button" id="workflow-menu-file-save" data-workflow-action="fileSave" data-i18n-key="workflow.menu.fileSave">File save</button>
            <button type="button" id="workflow-menu-file-load" data-workflow-action="fileLoad" data-i18n-key="workflow.menu.fileLoad">File load</button>
            <button type="button" id="workflow-menu-save-as" data-workflow-action="saveAs" data-i18n-key="workflow.menu.saveAs">Save as</button>
            <button type="button" id="workflow-menu-clear" data-workflow-action="clear" data-i18n-key="workflow.menu.clear">Clear workflow</button>
            <button type="button" id="workflow-menu-browse" data-workflow-action="browse" data-i18n-key="workflow.menu.openList">Browse workflows</button>
          </div>
        </div>
        <div class="toolbar-group align-controls">
          <button type="button" data-align="left" data-i18n-key="toolbar.alignLeft">Align left</button>
          <button type="button" data-align="top" data-i18n-key="toolbar.alignTop">Align top</button>
          <button type="button" data-align="center" data-i18n-key="toolbar.alignCenter">Align center</button>
        </div>
        <div class="toolbar-group">
          <button type="button" id="btn-undo" data-i18n-key="toolbar.undo">Undo</button>
          <button type="button" id="btn-redo" data-i18n-key="toolbar.redo">Redo</button>
        </div>
        <div class="toolbar-group">
          <label style="display:flex;gap:6px;align-items:center;font-size:12px;">
            <input type="checkbox" id="running-toggle" /> <span data-i18n-key="toolbar.runningMode">Running mode</span>
          </label>
        </div>
        <div class="toolbar-group locale-group">
          <label for="locale-select" data-i18n-key="toolbar.localeLabel">Language</label>
          <select id="locale-select" data-i18n-attr-aria-label="toolbar.localeLabel">
            <option value="en-US" data-i18n-key="toolbar.locale.en">English</option>
            <option value="ja-JP" data-i18n-key="toolbar.locale.ja">Japanese</option>
          </select>
        </div>
        <span id="autosave-indicator" aria-live="polite" data-i18n-key="autosave.pending">Waiting for changes</span>
      </div>
    </header>
    <main>
      <section class="sidebar" aria-label="Node search and help" data-i18n-attr-aria-label="sidebar.ariaLabel">
        <div class="sidebar-icons" role="tablist">
          <button type="button" class="sidebar-icon" data-panel="panel-search" aria-controls="panel-search" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" />
            </span>
            <span class="sr-only">Search</span>
          </button>
          <button type="button" class="sidebar-icon" data-panel="panel-queue" aria-controls="panel-queue" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <svg viewBox="0 0 24 24" role="presentation">
                <path d="M19 12a7 7 0 1 1-2.05-4.95" />
                <polyline points="19 5 19 9 15 9" />
              </svg>
            </span>
            <span class="sr-only">Queue</span>
          </button>
          <button type="button" class="sidebar-icon" data-panel="panel-workflows" aria-controls="panel-workflows" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" />
            </span>
            <span class="sr-only">Workflows</span>
          </button>
          <button type="button" class="sidebar-icon" data-panel="panel-connections" aria-controls="panel-connections" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" />
            </span>
            <span class="sr-only">Connections</span>
          </button>
          <button type="button" class="sidebar-icon" data-panel="panel-diagnostics" aria-controls="panel-diagnostics" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <svg viewBox="0 0 24 24" role="presentation">
                <rect x="6" y="5" width="12" height="15" rx="2" />
                <path d="M9 3h6v3H9z" />
                <path d="M9 13l2.5 2.5L15 11" />
              </svg>
            </span>
            <span class="sr-only">Diagnostics</span>
          </button>
          <button type="button" class="sidebar-icon" data-panel="panel-about" aria-controls="panel-about" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" />
            </span>
            <span class="sr-only">About</span>
          </button>
          <button type="button" class="sidebar-icon" data-panel="panel-help" aria-controls="panel-help" aria-expanded="false">
            <span aria-hidden="true" class="sidebar-icon-symbol">
              <img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" />
            </span>
            <span class="sr-only">Help</span>
          </button>
        </div>
        <div class="sidebar-panel-container" id="sidebar-panels" data-state="closed">
          <div id="panel-search" class="sidebar-panel" role="region" aria-hidden="true">
            <label class="search-box">
              <span style="font-size:12px; color: rgba(255,255,255,0.7);" data-i18n-key="sidebar.searchLabel">Node search</span>
              <input
                id="node-search"
                type="search"
                placeholder="Load, Trim, Resize..."
                autocomplete="off"
                data-i18n-attr-placeholder="sidebar.searchPlaceholder"
              />
            </label>
            <ul
              id="search-suggestions"
              class="suggestions"
              role="listbox"
              aria-label="Node suggestions"
              data-i18n-attr-aria-label="sidebar.suggestionsLabel"
            ></ul>
          </div>
          <div id="panel-help" class="sidebar-panel" role="region" aria-hidden="true">
            <div class="help-card" aria-live="polite">
              <strong data-i18n-key="help.shortcutsTitle">Shortcuts</strong>
              <table>
                <tr><td>Ctrl/Cmd + C</td><td data-i18n-key="help.copy">Copy node</td></tr>
                <tr><td>Ctrl/Cmd + V</td><td data-i18n-key="help.paste">Paste (4px snap)</td></tr>
                <tr><td>Ctrl/Cmd + D</td><td data-i18n-key="help.duplicate">Duplicate</td></tr>
                <tr><td>1</td><td data-i18n-key="help.zoomReset">Zoom 100%</td></tr>
                <tr><td>Shift + 1</td><td data-i18n-key="help.fitSelection">Fit selection</td></tr>
                <tr><td>+= / +Shift+=</td><td data-i18n-key="help.zoomOut">Canvas zoom out</td></tr>
                <tr><td>+ / +Shift+</td><td data-i18n-key="help.zoomIn">Canvas zoom in</td></tr>
              </table>
            </div>
          </div>
          <div id="panel-queue" class="sidebar-panel" role="region" aria-hidden="true">
            <div class="readonly-banner" id="readonly-banner" data-i18n-key="readonly.banner">Read-only because the schema version differs. Editing is disabled.</div>
            <div class="queue-card" aria-label="Job queue" data-i18n-attr-aria-label="queue.ariaLabel">
              <header>
                <strong data-i18n-key="queue.title">Job queue</strong>
                <div class="toolbar-group">
                  <button type="button" id="btn-demo-job" data-i18n-key="queue.demoJob">Add demo job</button>
                  <button type="button" id="btn-cancel-all" data-i18n-key="queue.cancelAll">Cancel all</button>
                </div>
              </header>
              <div id="queue-warnings" class="queue-alerts" aria-live="polite"></div>
              <div class="queue-lists">
                <div class="queue-section">
                  <strong data-i18n-key="queue.status.running">Running</strong>
                  <div id="queue-running"></div>
                </div>
                <div class="queue-section">
                  <strong data-i18n-key="queue.status.queued">Queued</strong>
                  <div id="queue-queued"></div>
                </div>
                <div class="queue-section">
                  <strong data-i18n-key="queue.historyTitle">History (20 entries)</strong>
                  <div id="queue-history"></div>
                </div>
              </div>
            </div>
          </div>
          <div id="panel-workflows" class="sidebar-panel" role="region" aria-hidden="true">
            <div class="workflow-panel">
              <header>
                <strong data-i18n-key="workflows.title">Workflows</strong>
                <button type="button" id="workflow-create" data-i18n-key="workflows.saveCurrent">Save current workflow</button>
              </header>
              <label class="search-box">
                <span style="font-size:12px; color: rgba(255,255,255,0.7);" data-i18n-key="workflows.searchLabel">Search workflows</span>
                <input
                  type="search"
                  id="workflow-search"
                  placeholder="Search workflows"
                  autocomplete="off"
                  data-i18n-attr-placeholder="workflows.searchPlaceholder"
                />
              </label>
              <div id="workflow-empty" data-i18n-key="workflows.empty">No saved workflows yet</div>
              <ul id="workflow-list"></ul>
            </div>
          </div>
          <div id="panel-connections" class="sidebar-panel" role="region" aria-hidden="true">
            <div class="connections-card" aria-label="Connection list" data-i18n-attr-aria-label="connections.ariaLabel">
              <header>
                <strong data-i18n-key="connections.title">Connections</strong>
                <span id="connection-pending" class="pending-hint" aria-live="polite"></span>
              </header>
              <ul id="connection-list" class="connections-list" role="list"></ul>
            </div>
          </div>
          <div id="panel-diagnostics" class="sidebar-panel" role="region" aria-hidden="true">
            <div class="diagnostics-card" aria-label="Logs and diagnostics" data-i18n-attr-aria-label="diagnostics.ariaLabel">
              <header>
                <strong data-i18n-key="diagnostics.title">Logs & diagnostics</strong>
                <label style="display:flex;gap:6px;align-items:center;">
                  <input type="checkbox" id="crash-consent" /> <span data-i18n-key="diagnostics.crashConsent">Include crash dumps</span>
                </label>
              </header>
              <div class="diagnostics-export">
                <input
                  type="password"
                  id="log-password"
                  placeholder="Export password"
                  autocomplete="off"
                  data-i18n-attr-placeholder="diagnostics.passwordPlaceholder"
                />
                <button type="button" id="btn-export-logs" data-i18n-key="diagnostics.exportButton">Export logs</button>
              </div>
              <div id="export-status"></div>
              <div class="queue-section">
                <strong data-i18n-key="diagnostics.inspectHistoryTitle">Inspect history (20 entries)</strong>
                <div id="inspect-history"></div>
              </div>
            </div>
          </div>
          <div id="panel-about" class="sidebar-panel" role="region" aria-hidden="true">
            <div
              class="about-card"
              id="about-card"
              aria-live="polite"
              aria-label="About & licensing"
              data-i18n-attr-aria-label="about.ariaLabel"
            >
              <header>
                <strong data-i18n-key="about.title">About & licensing</strong>
              </header>
              <dl>
                <div>
                  <dt data-i18n-key="about.distributionLabel">FFmpeg distribution</dt>
                  <dd id="about-distribution"></dd>
                </div>
                <div>
                  <dt data-i18n-key="about.licenseLabel">License</dt>
                  <dd id="about-license"></dd>
                </div>
                <div>
                  <dt data-i18n-key="about.pathLabel">FFmpeg path</dt>
                  <dd id="about-path" class="mono"></dd>
                </div>
                <div>
                  <dt data-i18n-key="about.versionLabel">Version</dt>
                  <dd id="about-version"></dd>
                </div>
              </dl>
              <div class="about-links">
                <a id="about-license-link" href="#" target="_blank" rel="noreferrer" data-i18n-key="about.licenseLink">License</a>
                <a id="about-source-link" href="#" target="_blank" rel="noreferrer" data-i18n-key="about.sourceLink">Source</a>
              </div>
              <p id="about-notice"></p>
            </div>
          </div>
        </div>
      </section>
      <section class="canvas-wrap">
        <div id="canvas-grid" aria-hidden="true"></div>
        <div id="canvas" role="region" aria-label="Node canvas" data-i18n-attr-aria-label="canvas.ariaLabel">
          <svg id="connection-layer" aria-hidden="true"></svg>
          <div id="node-layer"></div>
          <div id="selection-rect" aria-hidden="true"></div>
          <div id="selection-outline" aria-hidden="true"></div>
        </div>
        <div
          class="canvas-controls"
          id="canvas-controls"
          role="toolbar"
          aria-label="Canvas controls"
          data-i18n-attr-aria-label="canvas.controls"
        >
          <button
            type="button"
            id="tool-select"
            class="canvas-tool active"
            aria-pressed="true"
            title="Select tool"
            data-i18n-attr-title="canvas.toolSelectTooltip"
            data-i18n-attr-aria-label="canvas.toolSelectTooltip"
          >
            <span aria-hidden="true" class="canvas-tool-icon"><img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" /></span>
          </button>
          <button
            type="button"
            id="tool-pan"
            class="canvas-tool"
            aria-pressed="false"
            title="Pan view"
            data-i18n-attr-title="canvas.toolPanTooltip"
            data-i18n-attr-aria-label="canvas.toolPanTooltip"
          >
            <span aria-hidden="true" class="canvas-tool-icon"><img src="data:image/png;base64,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" alt="" decoding="async" draggable="false" loading="lazy" /></span>
          </button>
          <button
            type="button"
            id="btn-fit-view"
            class="canvas-tool"
            title="Fit selection"
            data-i18n-attr-title="canvas.fitViewTooltip"
            data-i18n-attr-aria-label="canvas.fitViewTooltip"
          >
            <span aria-hidden="true" class="canvas-tool-icon"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAEUhJREFUeNrs3TFyHMcZhmH0WAfQERgx5hHEeC/gTGToSMUTkDwBSycAfIgNHFFHQM5EyhzqCJ6V1zBdhOBd7MxO9/89TxVqSQWqwvSgv7dUkthugux2uzfzx6f56/V+v7+/ASDevA2v5o/P89e7eRvuUr7vFjb+t8ff/i4CAPhq/L8//qW3KRHQQg746/G/EQEAPDL+N0kR0AIO+LHxFwEAxv+x8Y+JgFb8gJ8afxEAYPyfUjoCWuEDPmX8RQCA8Y+MgFb0gM8ZfxEAYPzjIqAVPODnjL8IADD+URHQih3wJeMvAgCMf0wEtEIHvMT4iwAA4x8RAa3IAS85/iIAwPiXj4BW4IDXGH8RAGD8S0dAG/yA1xx/EQBg/MtGQBv4gK8x/iIAwPiXjIA26AFfc/xFAIDxLxcBbcAD3mL8RQCA8S8VAW2wA95y/EUAgPEvEwFtoAPuYfxFAIDxLxEBbZAD7mn8RQCA8R8+AtoAB9zj+IsAAOM/dAS0zg+45/EXAQDGf9gIaB0f8AjjLwIAjP+QEdA6PeCRxl8EABj/4SKgdXjAI46/CAAw/kNFQOvsgEcefxEAYPyHiYDW0QFXGH8RAGD8h4iA1skBVxp/EQBg/LuPgNbBAVccfxEAYPy7joC28QFXHn8RAGD8u42AtuEBJ4y/CAAw/l1GQNvogJPGXwQAGP/uIqBtcMCJ4y8CAIx/VxHQrnzAyeMvAgCMfzcR0K54wMZfBAAY/04ioF3pgI2/CAAw/h1FQLvCARt/EQBg/DuLgLbyARt/EQBg/DuMgLbiARt/EQBg/DuNgLbSARt/EQBg/DuOgLbCARt/EQBg/DuPgLbwARt/EQBg/AeIgLbgARt/EQBg/AeJgLbQARt/EQBg/AeKgLbAARt/EQBg/AeLgHbhARt/EQBg/AeMgHbBARt/EQBg/AeNgPbMAzb+IgDA+A8cAe0ZB2z8RQCA8R88AtqZB2z8RQCA8S8QAe2MAzb+IgDA+BeJgMn4D+nwg/b5+IPH8hfaC0/BmWL8B3V73OzLA8D4i4CwC837Hn4pYvxT3vfJZSgC8L67FDH+ee/75DIUAXjfXYoY/7z3fXIZigAXmvfdpYjxz3vfJ5ehCDD+3neXIsY/732fXIYiwPjjUsT4573vk8tQBBh/XIoY/7z3fXIZigDjj0tRBBj/vPd9chmKAOMPIsD4573vh38C8MmzEAHGH0SA8Y/y6RAAr2/+/f+WRwQYf0RAeAQY/wh//Hky0/EPlBEBIsD4Q3gEGP+c8T9s/x//EqAIEAHGH7IjwPhnjf/hNw//GaAIEAHGHzIjwPjnjf//BIAIEAHGH/IiwPhnjv83ASACRIDxh5wIMP654/9oAIgAEWD8oX4EGP/s8f/TABABIsD4Q90IMP7G/8kAEAEiwPhDvQgw/sb/pAAQASLA+EOdCDD+xv+sABABIsD4w/gRYPyN/7MCQASIAOMP40aA8Tf+FwWACBABxh/GiwDjb/wXCQARIAKMP4wTAcbf+C8aACJABBh/6D8CjL/xXyUARIAIMP7QbwQYf+O/agCIABFg/KG/CDD+xv8qASACRIDxh34iwPgb/6sGgAgQAcYfto8A42/8NwkAESACjD9sFwHG3/hvGgAiQAQYf7h+BBh/499FAIgAEWD84XoRYPyNf1cBIAJEgPGH9SPA+Bv/LgNABIgA4w/rRYDxN/5dB4AIEAHGH5aPAONv/IcIABEgAow/LBcBxt/4DxUAIkAEGH+4PAKMv/EfMgBEgAgw/vD8CDD+xn/oABABIsD4w/kRYPyNf4kAEAEiwPjD6RFg/I1/qQAQAdkRYPzhtAgw/sa/ZACIgMwIMP5wWgQYf+NfOgBEQFwEfDD+cFIEfDD+xr98AIiAqAh47zHASd4bf+MfEQAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgAA4x8aACIAAOMfGgAiAADjHxoAIgCA9PGPDQARAGD8k8c/OgBEAIDxT34IU/pbIAIAjL8AEAEiAMD4CwARAIDxFwAiAADjLwBEAADGXwCIAACMvwAQAQAYfwEgAgAw/gJABABg/AWACADA+AsAEQCA8RcAIgAA4y8ARAAAxl8AiAAA448AEAEAxh8BIAIAjD8CQAQAGH8EgAgAMP4CABEAYPwFACIAwPgLAEQAgPEXAIgAAOMvABABAMZfACACAIy/ABABIgDA+AsAEQCA8RcAIgAA4y8ARACA8UcAFI2Anz0JgAc/G38BUN5ut3szf7z3JAAevD/ejQiA0uN/60kAfONWBAgA4w8gAhAAxh9ABCAAjD+ACEAAGH8AEYAAMP4AIgABYPwBRAACwPgDiAAEgPEHEAECAOMPIAIEAMYfQAQIAIw/gAgQABh/ABEgAIw/ACJAABh/AESAADD+AIgAAWD8ARABAsD4AyACBIDxB0AECADjD4AIEADGHwARIACMPwAiQAAYfwBEgAAw/gCIAAFg/AFEAALA+AOIAAFg/I0/gAgQAMYfABEgAIw/ACJAABh/AESAADD+AIgAAWD8ARABAsD4AyACBIDxB0AECADjD4AIEADGHwARIACMPwAiQAAYfwBEgAAw/gCIAAFg/AEQAZkBYPwBEAGn+a7Q+L+YP36cv37xnnKhe4/AmcIjfpy35pf9fv+rRwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwEGr8o3sdrsX88etI2UB9/v9/p3HUMd8P3yaP155Eizg7Xw//FrhG/muyokcDmT+If+7CAAecRj/HzwGjP9/TZVOZj6Yu8MBeUcBWGH87yp9Q1O1ExIBABj/wAAQAQAY/9AAEAEAGP/QABABABj/0AAQAQAY/9AAEAEAGP/QABABABj/0AAQAQAY/9AAEAEAGP/QABABAKSPf2wAiAAAksc/OgBEAIDxT34AU/obIAIAjL8AEAEAGH8BIAIAMP4CQAQAYPwFgAgAwPgLABEAgPEXACIAAOMvAEQAAMZfAIgAAIy/ABABABh/ASACADD+AkAEAGD8BYAIAMD4CwARAGD8EQAiAMD4IwBEAIDxRwCIAADjjwAQAQDGXwAgAgCMvwBABAAYfwGACAAw/gIAEQBg/AUAIgDA+AsARACA8RcAIkAEABh/ASACADD+AkAEAGD8BYAIADD+CICiEfDRkwB48NH4C4Dydrvdq/njJ08C4MFPx7sRAVB6/D/PX997GgAPDnfiZxEgAIw/gAhAABh/ABGAADD+ACIAAWD8AUQAAsD4A4gABIDxBxABCADjDyACEADGH0AECACMP4AIEAAYfwARIAAw/gAiQABg/AFEgAAw/gCIAAFg/AEQAQLA+AMgAgSA8QdABAgA4w+ACBAAxh8AESAAjD8AIkAAGH8ARIAAMP4AiAABYPwBEAECwPgDIAIEgPEHEAEIAOMPIAIEgPE3/gAiQAAYfwBEgAAw/gCIAAFg/AEQAQLA+AMgAgSA8QdABAgA4w+ACBAAxh8AESAAjD8AIkAAGH8ARIAAMP4AiAABYPwBEAECwPgDIAIEgPEHQARkBoDxB0AEhAWA8QdABIQFgPEHQASEBYDxB0AEhAWA8QdABIQFgPEHQASEBYDxB0AEhAWA8QdABIQFgPEHQASEBYDxB0AEhAWA8QdABIQFgPEHQASEBYDxB0AEhAWA8QdABIQFgPEHQASEBYDxB0AEhAWA8QdABIQFgPEHQASEBYDxB0AEhAWA8Y/w+/z10WOAk3w8/swgAuoGgPGPGf/X+/3+w/z51uOAJ709/qy8FgEioGwAGP+o8b8//Gb+vBMB8OT43x1/Vu5FgAgoGQDGP2/8/0MEwNPj/9XPiggQAbUCwPjnjr8IgNPGXwSIgHIBYPyNvwiA08ZfBIiAMgFg/I2/CIDzxl8EiIDhA8D4G38RAM8bfxEgAoYNAONv/EUAXDb+IkAEDBcAxt/4iwBYZvxFgAgYJgCMv/EXAbDs+IsAEdB9ABh/4y8CYJ3xFwEioNsAMP7GXwTAuuMvAkRAdwFg/I2/CIDrjL8IEAHdBIDxN/4iAK47/iJABGweAMbf+IsA2Gb8RYAI2CwAjL/xFwGw7fiLABFw9QAw/sZfBEAf4y8CRMDVAsD4G38RAH2NvwgQAasHgPE3/iIA+hx/ESACVgsA42/8RQD0Pf4iQAQsHgDG3/iLABhj/EWACFgsAIy/8RcBMNb4iwARcHEAGH/jLwJgzPEXASLg2QFg/I2/CICxx18EiICzA8D4G38RADXGXwSIgJMDwPgbfxEAtcZfBIiA/xsAxt/4iwCoOf4iQAT8aQAYf+MvAqD2+IsAEfBNABh/4y8CIGP8RYAImIy/8RcBkDn+IiA7Aibjb/xFAOSOvwjIjYDJ+Bt/EQDZ4y8CMiNgMv7GXwSA8RcBeRFwCIB3noXxFwFg/EVAlHeTS9H4iwAw/iIg732fXIrGXwTgMjT+IiDvfZ9cisZfBOAyRATkve+TS9H4iwBchoiAvPd9cikafxHgfXcZIgLy3vfJpWj8XWzed5chIiDvfZ9cisYf77vLEBGQ975PLkXjj/fdZYgIyHvfJ5ei8cf77jJEBOS97+3Uv9tut3szf9x6rsYf4Ktt8OfJDBq77cyDFgHGH0AEDD7+ZweACDD+ACJg/PF/VgCIAOMPIALGHv9nB4AIMP4AImDc8b8oAESA8QcQAWOO/8UBIAKMP4AIGG/8FwkAEWD8AUTAWOO/WACIAOMPIALGGf9FA0AEGH8AETDG+C8eACLA+AOIgP7Hf5UAEAHGH0AE9D3+qwWACDD+ACKg3/FfNQBEgPEHEAF9jv/qASACjD+ACOhv/K8SACLA+AOIgL7G/2oBIAKMP4AI6Gf8rxoAIsD4A4iAPsb/6gEgAow/gAjYfvw3CYDgCDD+ACKgi/HfLAACI8D4A4iAbsZ/0wAIigDjDyACuhr/zQMgIAKMP4AI6G78uwiAwhFg/AFEQJfj300AFIwA4w8gArod/64CoFAEGH8AEdD1+HcXAAUiwPgDiIDux7/LABg4Aow/gAgYYvy7DYABI8D4A4iAYca/6wAYKAKMP4AIGGr8uw+AASLA+AOIgOHGf4gA6DgCjD+ACBhy/IcJgA4jwPgDiIBhx3+oAOgoAow/gAgYevyHC4AOIsD4A4iA4cd/yADYMAKMP4AIKDH+wwbABhFg/AFEQJnxHzoArhgBxh9ABJQa/+ED4AoRYPwBREC58S8RACtGgPEHEAElx79MAKwQAcYfQASUHf9SAbBgBBh/ABFQevzLBcACEWD8AURA+fEvGQAXRIDxBxABEeNfNgCeEQHGH0AExIx/6QA4IwKMP4AIiBr/8gFwQgQYfwAREDf+EQHwRAQYfwAR8FgElB//mAB4JAKMPwCPRUDE+B/8JeWQv3z5cv/y5cvf5l/+YPwBOG7DP+dt+Mf8y7/OX39LGf+DfwkwAHJshQW72xOPAAAAAElFTkSuQmCC" alt="" decoding="async" draggable="false" loading="lazy" /></span>
          </button>
          <span class="canvas-controls-divider" aria-hidden="true"></span>
          <div class="zoom-control">
            <button
              type="button"
              id="zoom-display"
              aria-haspopup="true"
              aria-expanded="false"
              title="Adjust zoom"
              data-i18n-attr-title="canvas.zoomDisplayLabel"
              data-i18n-attr-aria-label="canvas.zoomDisplayLabel"
            >
              100%
            </button>
            <div id="zoom-menu" role="menu" aria-hidden="true">
              <button type="button" id="zoom-in" role="menuitem" data-i18n-key="canvas.zoomIn">Zoom in</button>
              <button type="button" id="zoom-out" role="menuitem" data-i18n-key="canvas.zoomOut">Zoom out</button>
              <button type="button" id="zoom-fit-menu" role="menuitem" data-i18n-key="canvas.zoomToFit">Zoom to fit</button>
              <hr />
              <div class="zoom-input-row">
                <input
                  type="number"
                  id="zoom-input"
                  inputmode="numeric"
                  min="25"
                  max="400"
                  aria-label="Zoom percent"
                  data-i18n-attr-aria-label="canvas.zoomInputLabel"
                  placeholder="230"
                  data-i18n-attr-placeholder="canvas.zoomInputPlaceholder"
                />
                <button type="button" id="zoom-apply" role="menuitem" data-i18n-key="canvas.zoomApply">Apply</button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
    <section id="json-panel" hidden aria-hidden="true">
      <textarea
        id="project-json"
        spellcheck="false"
        aria-label="JSON for save/load"
        data-i18n-attr-aria-label="json.editorLabel"
        hidden
      ></textarea>
    </section>
    <div id="toast" role="status" aria-live="assertive"></div>
    <div id="workflow-context-menu" role="menu" aria-hidden="true">
      <button type="button" id="workflow-context-delete" data-i18n-key="workflow.context.delete">Delete workflow</button>
    </div>
    <div id="workflow-name-dialog" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="workflow-dialog-card" role="document">
        <h3 id="workflow-name-title" data-i18n-key="workflow.modal.title">Workflow name</h3>
        <input
          type="text"
          id="workflow-name-input"
          autocomplete="off"
          data-i18n-attr-placeholder="workflow.modal.placeholder"
        />
        <div class="workflow-dialog-actions">
          <button type="button" id="workflow-name-cancel" data-i18n-key="workflow.modal.cancel">Cancel</button>
          <button type="button" class="primary" id="workflow-name-confirm" data-i18n-key="workflow.modal.confirm">Save</button>
        </div>
      </div>
    </div>
    <script>
      window.__NODEVISION_BOOTSTRAP__ = JSON.parse(decodeURIComponent('%7B%22status%22%3A%7B%22settings%22%3A%7B%22schemaVersion%22%3A%221.0.7%22%2C%22tempRoot%22%3A%22%2Ftmp%2Fnodevision%22%2C%22ffmpegPath%22%3A%22%2Fusr%2Fbin%2Fffmpeg%22%2C%22ffprobePath%22%3A%22%2Fusr%2Fbin%2Fffprobe%22%2C%22locale%22%3A%22ja-JP%22%2C%22http%22%3A%7B%22enabled%22%3Afalse%2C%22tokenLabel%22%3A%22default%22%2C%22port%22%3A3921%7D%2C%22presets%22%3A%7B%22videoBitrate%22%3A%228M%22%2C%22audioBitrate%22%3A%22320k%22%2C%22container%22%3A%22mp4%22%7D%2C%22diagnostics%22%3A%7B%22lastTokenPreview%22%3Anull%2C%22collectCrashDumps%22%3Afalse%2C%22lastLogExportPath%22%3Anull%7D%2C%22createdAt%22%3A%222025-11-18T15%3A28%3A27.756Z%22%2C%22updatedAt%22%3A%222025-11-18T15%3A28%3A27.756Z%22%7D%2C%22ffmpeg%22%3A%7B%22ffmpeg%22%3A%7B%22path%22%3A%22%2Fusr%2Fbin%2Fffmpeg%22%2C%22version%22%3A%226.1%22%2C%22license%22%3A%22lgpl%22%7D%2C%22ffprobe%22%3A%7B%22path%22%3A%22%2Fusr%2Fbin%2Fffprobe%22%2C%22version%22%3A%226.1%22%2C%22license%22%3A%22lgpl%22%7D%7D%2C%22token%22%3A%7B%22label%22%3A%22default%22%2C%22value%22%3A%22abcd1234%22%2C%22expiresAt%22%3A%222025-11-19T15%3A28%3A27.757Z%22%2C%22createdAt%22%3A%222025-11-18T15%3A28%3A27.756Z%22%2C%22updatedAt%22%3A%222025-11-18T15%3A28%3A27.756Z%22%7D%2C%22distribution%22%3A%7B%22ffmpeg%22%3A%7B%22origin%22%3A%22external%22%2C%22license%22%3A%22lgpl%22%2C%22licenseUrl%22%3A%22https%3A%2F%2Fwww.gnu.org%2Flicenses%2Fold-licenses%2Flgpl-2.1.en.html%22%2C%22sourceUrl%22%3A%22https%3A%2F%2Fffmpeg.org%2Fdownload.html%23sources%22%7D%7D%7D%2C%22templates%22%3A%5B%7B%22typeId%22%3A%22load%22%2C%22nodeVersion%22%3A%221.0.0%22%2C%22title%22%3A%22Load%20Media%22%2C%22category%22%3A%22Input%22%2C%22description%22%3A%22Import%20image%2Fvideo%20files%22%2C%22keywords%22%3A%5B%22load%22%2C%22input%22%5D%2C%22outputs%22%3A%5B%7B%22id%22%3A%22media%22%2C%22label%22%3A%22Media%22%2C%22direction%22%3A%22output%22%2C%22dataType%22%3A%22video%22%7D%5D%7D%2C%7B%22typeId%22%3A%22trim%22%2C%22nodeVersion%22%3A%221.0.0%22%2C%22title%22%3A%22Trim%22%2C%22category%22%3A%22Edit%22%2C%22description%22%3A%22Set%20in%2Fout%20points%22%2C%22keywords%22%3A%5B%22trim%22%5D%2C%22inputs%22%3A%5B%7B%22id%22%3A%22source%22%2C%22label%22%3A%22Source%22%2C%22direction%22%3A%22input%22%2C%22dataType%22%3A%22video%22%7D%5D%2C%22outputs%22%3A%5B%7B%22id%22%3A%22result%22%2C%22label%22%3A%22Result%22%2C%22direction%22%3A%22output%22%2C%22dataType%22%3A%22video%22%7D%5D%7D%2C%7B%22typeId%22%3A%22preview%22%2C%22nodeVersion%22%3A%221.0.0%22%2C%22title%22%3A%22Preview%22%2C%22category%22%3A%22Output%22%2C%22description%22%3A%22Preview%20media%22%2C%22keywords%22%3A%5B%22preview%22%5D%2C%22inputs%22%3A%5B%7B%22id%22%3A%22source%22%2C%22label%22%3A%22Source%22%2C%22direction%22%3A%22input%22%2C%22dataType%22%3A%22video%22%7D%5D%7D%5D%2C%22nodes%22%3A%5B%7B%22id%22%3A%22n-load%22%2C%22typeId%22%3A%22loadImage%22%2C%22nodeVersion%22%3A%221.0.0%22%2C%22title%22%3A%22Load%22%2C%22position%22%3A%7B%22x%22%3A0%2C%22y%22%3A0%7D%2C%22width%22%3A220%2C%22height%22%3A120%2C%22inputs%22%3A%5B%5D%2C%22outputs%22%3A%5B%7B%22id%22%3A%22media%22%2C%22label%22%3A%22Media%22%2C%22direction%22%3A%22output%22%2C%22dataType%22%3A%22video%22%7D%5D%2C%22searchTokens%22%3A%5B%22load%22%5D%7D%2C%7B%22id%22%3A%22n-trim%22%2C%22typeId%22%3A%22trim%22%2C%22nodeVersion%22%3A%221.0.0%22%2C%22title%22%3A%22Trim%22%2C%22position%22%3A%7B%22x%22%3A280%2C%22y%22%3A40%7D%2C%22width%22%3A220%2C%22height%22%3A140%2C%22inputs%22%3A%5B%7B%22id%22%3A%22source%22%2C%22label%22%3A%22Source%22%2C%22direction%22%3A%22input%22%2C%22dataType%22%3A%22video%22%7D%5D%2C%22outputs%22%3A%5B%7B%22id%22%3A%22result%22%2C%22label%22%3A%22Result%22%2C%22direction%22%3A%22output%22%2C%22dataType%22%3A%22video%22%7D%5D%2C%22searchTokens%22%3A%5B%22trim%22%5D%7D%2C%7B%22id%22%3A%22n-preview%22%2C%22typeId%22%3A%22mediaPreview%22%2C%22nodeVersion%22%3A%221.0.0%22%2C%22title%22%3A%22Preview%22%2C%22position%22%3A%7B%22x%22%3A580%2C%22y%22%3A-20%7D%2C%22width%22%3A240%2C%22height%22%3A160%2C%22inputs%22%3A%5B%7B%22id%22%3A%22source%22%2C%22label%22%3A%22Source%22%2C%22direction%22%3A%22input%22%2C%22dataType%22%3A%22video%22%7D%5D%2C%22outputs%22%3A%5B%5D%2C%22searchTokens%22%3A%5B%22preview%22%5D%7D%5D%2C%22connections%22%3A%5B%7B%22id%22%3A%22c1%22%2C%22fromNodeId%22%3A%22n-load%22%2C%22fromPortId%22%3A%22media%22%2C%22toNodeId%22%3A%22n-trim%22%2C%22toPortId%22%3A%22source%22%7D%2C%7B%22id%22%3A%22c2%22%2C%22fromNodeId%22%3A%22n-trim%22%2C%22fromPortId%22%3A%22result%22%2C%22toNodeId%22%3A%22n-preview%22%2C%22toPortId%22%3A%22source%22%7D%5D%2C%22queue%22%3A%7B%22active%22%3A%5B%5D%2C%22queued%22%3A%5B%5D%2C%22history%22%3A%5B%5D%2C%22warnings%22%3A%5B%5D%2C%22limits%22%3A%7B%22maxParallelJobs%22%3A1%2C%22maxQueueLength%22%3A4%2C%22queueTimeoutMs%22%3A180000%7D%7D%2C%22diagnostics%22%3A%7B%22collectCrashDumps%22%3Afalse%2C%22lastTokenPreview%22%3Anull%2C%22lastLogExportPath%22%3Anull%2C%22lastExportSha%22%3Anull%2C%22inspectHistory%22%3A%5B%5D%7D%7D'));
      window.__NODEVISION_TRANSLATIONS__ = {"en-US":{"common.close":"Close","actions.save":"Save","actions.cancel":"Cancel","actions.reset":"Reset","app.title":"NodeVision Editor","toolbar.alignLeft":"Align left","toolbar.alignTop":"Align top","toolbar.alignCenter":"Align center","toolbar.undo":"Undo","toolbar.redo":"Redo","toolbar.runningMode":"Running mode","toolbar.localeLabel":"Language","toolbar.locale.en":"English","toolbar.locale.ja":"Japanese","workflow.unsaved":"Unsaved Workflow","workflow.menu.rename":"Rename","workflow.menu.fileSave":"Save to file","workflow.menu.fileLoad":"Load from file","workflow.menu.saveAs":"Save as","workflow.menu.clear":"Clear workflow","workflow.menu.openList":"Browse workflows","workflow.context.delete":"Delete workflow","workflow.modal.title":"Workflow name","workflow.modal.placeholder":"Name your workflow","workflow.modal.cancel":"Cancel","workflow.modal.confirm":"Save","workflow.promptName":"Workflow name","workflow.confirmDelete":"Delete workflow \"{{name}}\"?","workflow.confirmClear":"Clear the current workflow? This removes all nodes.","workflow.errorNameRequired":"Please enter a workflow name.","workflows.title":"Workflows","workflows.saveCurrent":"Save current workflow","workflows.searchLabel":"Search workflows","workflows.searchPlaceholder":"Search workflows","workflows.empty":"No saved workflows yet","autosave.pending":"Waiting for changes...","autosave.running":"Monitoring changes while running ({{seconds}}s)","autosave.idle":"Watching for edits ({{seconds}}s)","autosave.saved":"Autosaved at {{time}}","sidebar.ariaLabel":"Node search and help","sidebar.searchLabel":"Node search","sidebar.searchPlaceholder":"Load, Trim, Resize...","sidebar.suggestionsLabel":"Node suggestions","help.shortcutsTitle":"Shortcuts","help.copy":"Copy node","help.paste":"Paste (4px snap)","help.duplicate":"Duplicate","help.zoomReset":"Zoom 100%","help.fitSelection":"Fit selection","help.zoomIn":"Canvas zoom in","help.zoomOut":"Canvas zoom out","help.guideTitle":"Guided actions","help.guideHtml":" Drag nodes to move (4px snap)<br /> Press Enter to add highlighted suggestions<br /> Use Tab to focus cards.","readonly.banner":"Read-only because the schema version differs. Editing is disabled.","queue.ariaLabel":"Job queue","queue.title":"Job queue","queue.demoJob":"Add demo job","queue.cancelAll":"Cancel all","queue.status.running":"Running","queue.status.queued":"Queued","queue.status.coolingDown":"Cooling down","queue.status.failed":"Failed","queue.status.canceled":"Canceled","queue.historyTitle":"History (20 entries)","queue.emptyActive":"No active jobs","queue.emptyQueued":"No queued jobs","queue.noHistory":"No history yet","queue.noLogs":"No logs yet","queue.defaultJob":"Job","queue.stableTitle":"Queue Stable","queue.stableSummary":"Queued {{queued}}/{{limit}}  Timeout {{timeout}}s","nodes.ariaLabel":"{{title}} node","nodes.load.selectButton":"Choose a file to upload","nodes.load.empty":"No media selected yet","nodes.load.previewMeta":"{{name}}  {{size}}  {{type}}","nodes.load.unknownType":"unknown format","nodes.load.noFile":"No file chosen","nodes.load.aspectUnknown":"Size unknown","nodes.mediaPreview.noInput":"Connect a media node to preview it here.","nodes.mediaPreview.waiting":"Waiting for upstream media","nodes.mediaPreview.disconnected":"No source connected","nodes.mediaPreview.sourceLabel":"Source: {{title}}","nodes.mediaPreview.metaUnknown":"Size unknown","nodes.delete":"Delete node","nodes.status.connected":"Connected","nodes.status.missing":"Missing","nodes.trim.tip":"Connect a source clip and edit it using the trim modals before applying heavy effects.","nodes.trim.imageButton":"Image Trim","nodes.trim.videoButton":"Video Trim","nodes.trim.status.empty":"No adjustments yet","nodes.trim.status.imageEdited":"Image crop ready","nodes.trim.status.videoEdited":"Video trim ready","nodes.trim.status.imageSummary":"Image crop {{width}}%  {{height}}%","nodes.trim.status.videoSummary":"Video {{start}}  {{end}}{{strict}}","nodes.trim.status.videoEndLabel":"end","nodes.trim.status.videoStrictSuffix":"(strict)","nodes.trim.imageTools.zoomIn":"Zoom in","nodes.trim.imageTools.zoomOut":"Zoom out","nodes.trim.imageTools.grid":"Grid","nodes.trim.imageTools.rotateLeft":"Rotate left","nodes.trim.imageTools.rotateRight":"Rotate right","nodes.trim.imageTools.flipHorizontal":"Flip horizontally","nodes.trim.imageTools.flipHorizontalShort":"","nodes.trim.imageTools.flipVertical":"Flip vertically","nodes.trim.imageTools.flipVerticalShort":"","nodes.trim.imageTools.reset":"Reset transform","nodes.trim.imageControls.rotation":"Rotation","nodes.trim.imageControls.zoom":"Zoom","nodes.trim.imageControls.aspect":"Aspect ratio","nodes.trim.imageControls.aspectOption.free":"Free","nodes.trim.imageControls.aspectOption.original":"Original","nodes.trim.imageControls.aspectOption.square":"Square","nodes.trim.imageControls.aspectOption.4:3":"4:3","nodes.trim.imageControls.aspectOption.16:9":"16:9","nodes.trim.imageControls.aspectOption.9:16":"9:16","nodes.trim.modalPlaceholder.image":"Drag the highlighted box or its corners to crop the displayed image.","nodes.trim.modalPlaceholder.video":"Video trim modal is coming soonset accurate in/out ranges in a dedicated workspace.","nodes.trim.toast.imageSaved":"Image crop updated.","nodes.trim.toast.videoSaved":"Video trim updated.","nodes.trim.modalPlaceholder.noImage":"Load an image source and connect it to this Trim node to enable cropping.","nodes.mediaPreview.trimmedBadge":"Trimmed output","nodes.mediaPreview.trimmedRange":"Range {{start}}  {{end}}{{strict}}","nodes.mediaPreview.trimmedCrop":"Crop {{width}}%  {{height}}%","nodes.trim.modalPlaceholder.noVideo":"Connect a video Load node and capture a preview before trimming.","nodes.trim.modalHint.video":"Use the handles or enter exact timecodes, then save to refresh downstream previews.","nodes.trim.video.previewFallback":"Video source","nodes.trim.video.startLabel":"Start time","nodes.trim.video.endLabel":"End time","nodes.trim.video.durationUnknown":"Duration unknown","nodes.trim.video.strictLabel":"Strict cut","nodes.trim.video.strictHint":"Discard frames outside the saved range.","nodes.trim.video.controls.play":"Play","nodes.trim.video.controls.pause":"Pause","nodes.trim.video.controls.stepBack":"Step back","nodes.trim.video.controls.stepForward":"Step forward","nodes.trim.video.startHandle":"Adjust start handle","nodes.trim.video.endHandle":"Adjust end handle","nodes.resize.tip":"Keep Resize nodes near export to avoid repeated resampling.","nodes.overlay.tip":"Attach both Base and Layer inputsalpha channels stay intact.","nodes.text.tip":"Text Overlay renders crisp vector titles on top of the background clip.","nodes.crop.tip":"Crop defines the visible frame; pair it with Resize or Export to lock the aspect.","nodes.speed.tip":"Speed changes alter downstream duration, so reconnect jobs after tweaking ratios.","nodes.changeFps.tip":"Normalize variable frame rate footage before export to keep audio in sync.","nodes.export.tip":"Only flows that reach Export will generate a rendered file.","ports.inputsLabel":"{{title}} inputs","ports.outputsLabel":"{{title}} outputs","ports.emptyInputs":"No inputs","ports.emptyOutputs":"No outputs","ports.direction.input":"Input","ports.direction.output":"Output","ports.portLabel":"{{direction}} port {{label}} ({{dataType}})","connections.title":"Connections","connections.ariaLabel":"Connection list","connections.empty":"No connections yet","connections.ready":"Select an output port to start connecting","connections.remove":"Remove connection","connections.itemLabel":"{{from}}  {{to}}","connections.pending":"Select an input port to finish connection from {{from}}","diagnostics.ariaLabel":"Logs and diagnostics","diagnostics.title":"Logs & diagnostics","diagnostics.crashConsent":"Include crash dumps","diagnostics.passwordPlaceholder":"Export password","diagnostics.exportButton":"Export logs","diagnostics.inspectHistoryTitle":"Inspect history (20 entries)","diagnostics.noExport":"No exports yet","diagnostics.lastExport":"Last export: {{path}} (SHA {{sha}})","diagnostics.unknownSha":"unknown","diagnostics.historyEmpty":"No inspect history yet","diagnostics.noDetails":"No details","diagnostics.defaultToken":"token?","diagnostics.clipCount":"{{count}} clips","diagnostics.defaultPath":"diagnostics folder","json.banner":"Manage JSON saves and loads here. schemaVersion=1.0.7 is preserved.","json.export":"Export JSON","json.import":"Import JSON","json.editorLabel":"JSON for save/load","canvas.ariaLabel":"Node canvas","canvas.controls":"Canvas controls","canvas.toolSelectTooltip":"Select tool (V)","canvas.toolPanTooltip":"Pan view (H)","canvas.fitViewTooltip":"Fit selection (.)","canvas.zoomDisplayLabel":"Zoom options (+~ / +Shift+; for zoom in  += / +Shift+= for zoom out)","canvas.zoomIn":"Zoom in (+~ / +Shift+;)","canvas.zoomOut":"Zoom out (+= / +Shift+=)","canvas.zoomToFit":"Zoom to fit selection","canvas.zoomApply":"Apply","canvas.zoomInputLabel":"Zoom percent","canvas.zoomInputPlaceholder":"e.g. 150","toast.queueRefreshFailed":"Failed to refresh queue: {{message}}","toast.demoJobMissing":"Demo job API is unavailable","toast.demoJobAdded":"Demo job added","toast.queueFull":"{{code}}: queue is full","toast.demoJobFailed":"Failed to add job: {{reason}}","toast.cancelAll":"All jobs canceled","toast.mediaSelected":"Loaded {{name}}","toast.mediaFailed":"Could not open the file picker. Try again or restart.","toast.mediaWrongTypeImage":"This node only accepts image files.","toast.mediaWrongTypeVideo":"This node only accepts video files.","toast.exportMissing":"Export API is not connected","toast.exportFailed":"Export failed: {{reason}}","toast.logsExported":"Logs exported to {{path}}{{shaSuffix}}","toast.logsExportedSha":" (SHA256: {{sha}})","toast.crashOn":"Crash dumps will be included","toast.crashOff":"Crash dumps will be excluded","errors.schemaMissing":"schemaVersion is missing","errors.jsonLoadFailed":"Failed to load JSON: {{reason}}","about.title":"About & licensing","about.ariaLabel":"About and licensing","about.distributionLabel":"FFmpeg distribution","about.licenseLabel":"License","about.pathLabel":"FFmpeg path","about.versionLabel":"FFmpeg version","about.origin.bundled":"Bundled with NodeVision","about.origin.external":"External/system binary","about.noticeBundled":"NodeVision ships FFmpeg compiled under the LGPL v2.1+. Use the links below to review the license text and download matching source code.","about.noticeExternal":"FFmpeg was detected on this system. Confirm that the {{license}} license suits your redistribution requirements.","about.licenseLinkLabel":"License text","about.sourceLinkLabel":"FFmpeg source","about.versionUnknown":"Unknown","about.licenseValue.lgpl":"LGPL v2.1+","about.licenseValue.gpl":"GPL v3+","about.licenseValue.nonfree":"Nonfree build (--enable-nonfree)","about.licenseValue.unknown":"Unknown license","nodeTemplate.loadMedia.title":"Load Media","nodeTemplate.loadMedia.description":"Open a local image or video file","nodeTemplate.loadMedia.port.media":"Media","nodeTemplate.loadImage.title":"Load Image","nodeTemplate.loadImage.description":"Open a local image file","nodeTemplate.loadImage.port.media":"Image","nodeTemplate.loadVideo.title":"Load Video","nodeTemplate.loadVideo.description":"Open a local video file","nodeTemplate.loadVideo.port.media":"Video","nodeTemplate.mediaPreview.title":"Media Preview","nodeTemplate.mediaPreview.description":"Display the connected image or video inside the graph","nodeTemplate.mediaPreview.port.source":"Source","nodeTemplate.trim.title":"Trim","nodeTemplate.trim.description":"Cut media between in/out points","nodeTemplate.trim.port.source":"Source","nodeTemplate.trim.port.result":"Result","nodeTemplate.resize.title":"Resize","nodeTemplate.resize.description":"Resize media with aspect ratio controls","nodeTemplate.resize.port.source":"Source","nodeTemplate.resize.port.resized":"Resized","nodeTemplate.overlay.title":"Overlay","nodeTemplate.overlay.description":"Blend two sources with position controls","nodeTemplate.overlay.port.base":"Base","nodeTemplate.overlay.port.layer":"Layer","nodeTemplate.overlay.port.composite":"Composite","nodeTemplate.text.title":"Text Overlay","nodeTemplate.text.description":"Render titles or captions with font and color controls","nodeTemplate.text.port.background":"Background","nodeTemplate.text.port.titled":"Titled","nodeTemplate.crop.title":"Crop","nodeTemplate.crop.description":"Trim the visible area to a custom frame","nodeTemplate.crop.port.source":"Source","nodeTemplate.crop.port.cropped":"Cropped","nodeTemplate.speed.title":"Speed","nodeTemplate.speed.description":"Ramp playback speed for slow/fast motion","nodeTemplate.speed.port.source":"Source","nodeTemplate.speed.port.retimed":"Retimed","nodeTemplate.changeFps.title":"Change FPS","nodeTemplate.changeFps.description":"Convert variable frame rate clips to constant FPS","nodeTemplate.changeFps.port.source":"Source","nodeTemplate.changeFps.port.normalized":"Normalized","nodeTemplate.export.title":"Export Media","nodeTemplate.export.description":"Finalize and export the edited result","nodeTemplate.export.port.program":"Program","nodeTemplate.export.port.delivery":"Exported","demo.jobName":"FFmpeg demo render"},"ja-JP":{"common.close":"","actions.save":"","actions.cancel":"","actions.reset":"","app.title":"NodeVision","toolbar.alignLeft":"","toolbar.alignTop":"","toolbar.alignCenter":"","toolbar.undo":"","toolbar.redo":"","toolbar.runningMode":"","toolbar.localeLabel":"","toolbar.locale.en":"","toolbar.locale.ja":"","workflow.unsaved":"","workflow.menu.rename":"","workflow.menu.fileSave":"","workflow.menu.fileLoad":"","workflow.menu.saveAs":"","workflow.menu.clear":"","workflow.menu.openList":"","workflow.context.delete":"","workflow.modal.title":"","workflow.modal.placeholder":"","workflow.modal.cancel":"","workflow.modal.confirm":"","workflow.promptName":"","workflow.confirmDelete":"{{name}}","workflow.confirmClear":"","workflow.errorNameRequired":"","workflows.title":"","workflows.saveCurrent":"","workflows.searchLabel":"","workflows.searchPlaceholder":"","workflows.empty":"","autosave.pending":"...","autosave.running":" ({{seconds}})","autosave.idle":" ({{seconds}})","autosave.saved":"{{time}} ","sidebar.ariaLabel":"","sidebar.searchLabel":"","sidebar.searchPlaceholder":"","sidebar.suggestionsLabel":"","help.shortcutsTitle":"","help.copy":"","help.paste":"4px","help.duplicate":"","help.zoomReset":" 100%","help.fitSelection":"","help.zoomIn":"","help.zoomOut":"","help.guideTitle":"","help.guideHtml":"4px<br />Enter<br />Tab","readonly.banner":"","queue.ariaLabel":"","queue.title":"","queue.demoJob":"","queue.cancelAll":"","queue.status.running":"","queue.status.queued":"","queue.status.coolingDown":"","queue.status.failed":"","queue.status.canceled":"","queue.historyTitle":" (20)","queue.emptyActive":"","queue.emptyQueued":"","queue.noHistory":"","queue.noLogs":"","queue.defaultJob":"","queue.stableTitle":"","queue.stableSummary":" {{queued}}/{{limit}}   {{timeout}}","nodes.ariaLabel":"{{title}} ","nodes.load.selectButton":"","nodes.load.empty":"","nodes.load.previewMeta":"{{name}}  {{size}}  {{type}}","nodes.load.unknownType":"","nodes.load.noFile":"","nodes.load.aspectUnknown":"","nodes.mediaPreview.noInput":"","nodes.mediaPreview.waiting":"","nodes.mediaPreview.disconnected":"","nodes.mediaPreview.sourceLabel":": {{title}}","nodes.mediaPreview.metaUnknown":"","nodes.delete":"","nodes.status.connected":"","nodes.status.missing":"","nodes.trim.tip":"IN/OUT","nodes.trim.imageButton":"","nodes.trim.videoButton":"","nodes.trim.status.empty":"","nodes.trim.status.imageEdited":"","nodes.trim.status.videoEdited":"","nodes.trim.status.imageSummary":" {{width}}%  {{height}}% ","nodes.trim.status.videoSummary":" {{start}}  {{end}}{{strict}}","nodes.trim.status.videoEndLabel":"","nodes.trim.status.videoStrictSuffix":"","nodes.trim.imageTools.zoomIn":"","nodes.trim.imageTools.zoomOut":"","nodes.trim.imageTools.grid":"","nodes.trim.imageTools.rotateLeft":"","nodes.trim.imageTools.rotateRight":"","nodes.trim.imageTools.flipHorizontal":"","nodes.trim.imageTools.flipHorizontalShort":"","nodes.trim.imageTools.flipVertical":"","nodes.trim.imageTools.flipVerticalShort":"","nodes.trim.imageTools.reset":"","nodes.trim.imageControls.rotation":"","nodes.trim.imageControls.zoom":"","nodes.trim.imageControls.aspect":"","nodes.trim.imageControls.aspectOption.free":"","nodes.trim.imageControls.aspectOption.original":"","nodes.trim.imageControls.aspectOption.square":"","nodes.trim.imageControls.aspectOption.4:3":"4:3","nodes.trim.imageControls.aspectOption.16:9":"16:9","nodes.trim.imageControls.aspectOption.9:16":"9:16","nodes.trim.modalPlaceholder.image":"","nodes.trim.modalPlaceholder.video":"IN/OUT","nodes.trim.modalPlaceholder.noImage":"","nodes.trim.toast.imageSaved":"","nodes.trim.toast.videoSaved":"","nodes.mediaPreview.trimmedBadge":"","nodes.mediaPreview.trimmedRange":" {{start}}  {{end}}{{strict}}","nodes.mediaPreview.trimmedCrop":" {{width}}%  {{height}}%","nodes.trim.modalPlaceholder.noVideo":"","nodes.trim.modalHint.video":"IN/OUT","nodes.trim.video.previewFallback":"","nodes.trim.video.startLabel":"","nodes.trim.video.endLabel":"","nodes.trim.video.durationUnknown":"","nodes.trim.video.strictLabel":"","nodes.trim.video.strictHint":"","nodes.trim.video.controls.play":"","nodes.trim.video.controls.pause":"","nodes.trim.video.controls.stepBack":"1","nodes.trim.video.controls.stepForward":"1","nodes.trim.video.startHandle":"","nodes.trim.video.endHandle":"","nodes.resize.tip":"","nodes.overlay.tip":"","nodes.text.tip":"GPU","nodes.crop.tip":"","nodes.speed.tip":"","nodes.changeFps.tip":"FPS","nodes.export.tip":"","ports.inputsLabel":"{{title}} ","ports.outputsLabel":"{{title}} ","ports.emptyInputs":"","ports.emptyOutputs":"","ports.direction.input":"","ports.direction.output":"","ports.portLabel":"{{direction}} {{label}} ({{dataType}})","connections.title":"","connections.ariaLabel":"","connections.empty":"","connections.ready":"","connections.remove":"","connections.itemLabel":"{{from}}  {{to}}","connections.pending":"{{from}} ","diagnostics.ariaLabel":"","diagnostics.title":" & ","diagnostics.crashConsent":"","diagnostics.passwordPlaceholder":"","diagnostics.exportButton":"","diagnostics.inspectHistoryTitle":"inspect (20)","diagnostics.noExport":"","diagnostics.lastExport":": {{path}} (SHA {{sha}})","diagnostics.unknownSha":"","diagnostics.historyEmpty":"","diagnostics.noDetails":"","diagnostics.defaultToken":"?","diagnostics.clipCount":"{{count}} ","diagnostics.defaultPath":"","json.banner":"JSON/schemaVersion=1.0.7 ","json.export":"JSON","json.import":"JSON","json.editorLabel":"JSON","canvas.ariaLabel":"","canvas.controls":"","canvas.toolSelectTooltip":" (V)","canvas.toolPanTooltip":" (H)","canvas.fitViewTooltip":" (.)","canvas.zoomDisplayLabel":": + / +Shift+  : += / +Shift+=","canvas.zoomIn":" (+ / +Shift+)","canvas.zoomOut":" (+= / +Shift+=)","canvas.zoomToFit":"","canvas.zoomApply":"","canvas.zoomInputLabel":" %","canvas.zoomInputPlaceholder":": 150","toast.queueRefreshFailed":": {{message}}","toast.demoJobMissing":"API","toast.demoJobAdded":"","toast.queueFull":"{{code}}: ","toast.demoJobFailed":": {{reason}}","toast.cancelAll":"","toast.mediaSelected":"{{name}} ","toast.mediaFailed":"","toast.mediaWrongTypeImage":"","toast.mediaWrongTypeVideo":"","toast.exportMissing":"Export API","toast.exportFailed":": {{reason}}","toast.logsExported":" {{path}}{{shaSuffix}} ","toast.logsExportedSha":" (SHA256: {{sha}})","toast.crashOn":"","toast.crashOff":"","errors.schemaMissing":"schemaVersion ","errors.jsonLoadFailed":"JSON: {{reason}}","about.title":"","about.ariaLabel":"","about.distributionLabel":"FFmpeg","about.licenseLabel":"","about.pathLabel":"FFmpeg","about.versionLabel":"FFmpeg","about.origin.bundled":"NodeVision (LGPL)","about.origin.external":"/","about.noticeBundled":"NodeVisionLGPL v2.1+FFmpeg","about.noticeExternal":"FFmpeg: {{license}}","about.licenseLinkLabel":"","about.sourceLinkLabel":"FFmpeg","about.versionUnknown":"","about.licenseValue.lgpl":"LGPL v2.1+","about.licenseValue.gpl":"GPL v3+","about.licenseValue.nonfree":" (--enable-nonfree)","about.licenseValue.unknown":"","nodeTemplate.loadMedia.title":"","nodeTemplate.loadMedia.description":"","nodeTemplate.loadMedia.port.media":"","nodeTemplate.loadImage.title":"","nodeTemplate.loadImage.description":"","nodeTemplate.loadImage.port.media":"","nodeTemplate.loadVideo.title":"","nodeTemplate.loadVideo.description":"","nodeTemplate.loadVideo.port.media":"","nodeTemplate.mediaPreview.title":"","nodeTemplate.mediaPreview.description":"","nodeTemplate.mediaPreview.port.source":"","nodeTemplate.trim.title":"","nodeTemplate.trim.description":"IN/OUT","nodeTemplate.trim.port.source":"","nodeTemplate.trim.port.result":"","nodeTemplate.resize.title":"","nodeTemplate.resize.description":"","nodeTemplate.resize.port.source":"","nodeTemplate.resize.port.resized":"","nodeTemplate.overlay.title":"","nodeTemplate.overlay.description":"2","nodeTemplate.overlay.port.base":"","nodeTemplate.overlay.port.layer":"","nodeTemplate.overlay.port.composite":"","nodeTemplate.text.title":"","nodeTemplate.text.description":"","nodeTemplate.text.port.background":"","nodeTemplate.text.port.titled":"","nodeTemplate.crop.title":"","nodeTemplate.crop.description":"","nodeTemplate.crop.port.source":"","nodeTemplate.crop.port.cropped":"","nodeTemplate.speed.title":"","nodeTemplate.speed.description":"/","nodeTemplate.speed.port.source":"","nodeTemplate.speed.port.retimed":"","nodeTemplate.changeFps.title":"","nodeTemplate.changeFps.description":"","nodeTemplate.changeFps.port.source":"","nodeTemplate.changeFps.port.normalized":"","nodeTemplate.export.title":"","nodeTemplate.export.description":"","nodeTemplate.export.port.program":"","nodeTemplate.export.port.delivery":"","demo.jobName":"FFmpeg "}};
      window.__NODEVISION_SUPPORTED_LOCALES__ = ["en-US","ja-JP"];
      window.__NODEVISION_FALLBACK_LOCALE__ = 'ja-JP';
    </script>
    <script>
      (function(){
        const modules = {
        './app': function (exports, require, module) {
      "use strict";
      /// <reference lib="dom" />
      Object.defineProperty(exports, "__esModule", { value: true });
      const dom_1 = require("./dom");
      const state_1 = require("./state");
      const trim_shared_1 = require("./nodes/trim-shared");
      const nodes_1 = require("./nodes");
      const ports_1 = require("./ports");
      const preview_layout_1 = require("./nodes/preview-layout");
      const preview_size_1 = require("./nodes/preview-size");
      (() => {
          const rendererWindow = window;
          const nodevision = window.nodevision;
          const WORKFLOW_STORAGE_KEY = 'nodevision.workflows.v1';
          const SNAP = 4;
          const DRAG_THRESHOLD = 3;
          const SCHEMA = '1.0.7';
          const MIN_PREVIEW_WIDTH = 220;
          const MIN_PREVIEW_HEIGHT = 165;
          const HORIZONTAL_PREVIEW_PADDING = 40;
          const PREVIEW_FRAME_RATIO = MIN_PREVIEW_WIDTH / MIN_PREVIEW_HEIGHT;
          const MIN_NODE_CHROME = 180;
          const DEFAULT_NODE_CHROME = 260;
          const NODE_MIN_WIDTH = MIN_PREVIEW_WIDTH + HORIZONTAL_PREVIEW_PADDING;
          const NODE_MAX_WIDTH = 960;
          const NODE_MIN_HEIGHT = MIN_PREVIEW_HEIGHT + MIN_NODE_CHROME;
          const NODE_MAX_HEIGHT = 1000;
          const MAX_CHROME_SYNC_ATTEMPTS = 2;
          const LOAD_NODE_TYPE_IDS = new Set(['loadImage', 'loadVideo', 'loadMedia']);
          const GRID_MINOR_BASE = 8;
          const GRID_MAJOR_FACTOR = 4;
          const SELECTION_PADDING = 6;
          const LOCALE_STORAGE_KEY = 'nodevision.locale';
          const CANVAS_CONTROLS_POSITION_KEY = 'nodevision.canvasControls.position';
          const CANVAS_CONTROLS_MARGIN = 12;
          const TRANSLATIONS = rendererWindow.__NODEVISION_TRANSLATIONS__ ?? {};
          const SUPPORTED_LOCALES = Array.isArray(rendererWindow.__NODEVISION_SUPPORTED_LOCALES__) && rendererWindow.__NODEVISION_SUPPORTED_LOCALES__.length
              ? rendererWindow.__NODEVISION_SUPPORTED_LOCALES__
              : Object.keys(TRANSLATIONS);
          const FALLBACK_LOCALE = typeof rendererWindow.__NODEVISION_FALLBACK_LOCALE__ === 'string'
              ? rendererWindow.__NODEVISION_FALLBACK_LOCALE__
              : SUPPORTED_LOCALES[0] ?? 'en-US';
          const BOOTSTRAP = rendererWindow.__NODEVISION_BOOTSTRAP__;
          if (!BOOTSTRAP) {
              console.error('[NodeVision] renderer bootstrap payload is missing');
              return;
          }
          const elements = (0, dom_1.captureDomElements)();
          let unsavedWorkflowLabel = 'Unsaved Workflow';
          let activeModal = null;
          let modalBackdrop = null;
          let modalContainer = null;
          let modalTitleElement = null;
          let modalContentElement = null;
          let modalCloseButton = null;
          let modalLastFocused = null;
          const MODAL_FOCUSABLE_SELECTORS = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
          const DEFAULT_TRIM_REGION = { x: 0, y: 0, width: 1, height: 1 };
          const MIN_TRIM_REGION_SIZE = 0.05;
          const MIN_TRIM_VIDEO_RANGE_MS = 100;
          const TRIM_VIDEO_JOG_STEP_MS = 500;
          const TRIM_VIDEO_TIMELINE_PADDING = 12;
          const TRIM_VIDEO_DEFAULT_EPSILON_MS = 30;
          const cloneNodeSettings = (settings) => settings ? (0, state_1.deepClone)(settings) : undefined;
          const getErrorMessage = (error) => (error instanceof Error ? error.message : String(error));
          const readStoredLocale = () => {
              try {
                  if (typeof localStorage === 'undefined') {
                      return null;
                  }
                  return localStorage.getItem(LOCALE_STORAGE_KEY);
              }
              catch (error) {
                  console.warn('[NodeVision] locale storage unavailable', error);
                  return null;
              }
          };
          const detectLocale = () => {
              const stored = readStoredLocale();
              if (stored && TRANSLATIONS[stored]) {
                  return stored;
              }
              const configured = BOOTSTRAP?.status?.settings?.locale;
              if (configured && TRANSLATIONS[configured]) {
                  return configured;
              }
              const candidates = [];
              if (navigator?.language) {
                  candidates.push(navigator.language);
              }
              if (Array.isArray(navigator?.languages)) {
                  candidates.push(...navigator.languages);
              }
              for (const candidate of candidates) {
                  if (!candidate)
                      continue;
                  const normalized = String(candidate).toLowerCase();
                  const match = SUPPORTED_LOCALES.find(locale => normalized.startsWith(locale.toLowerCase()));
                  if (match) {
                      return match;
                  }
              }
              return FALLBACK_LOCALE;
          };
          const createId = (base) => (crypto?.randomUUID ? crypto.randomUUID() : `${base}-${Date.now()}-${Math.floor(Math.random() * 9999)}`);
          const cssEscape = (value) => {
              if (window.CSS?.escape) {
                  return window.CSS.escape(String(value));
              }
              return String(value).replace(/([^a-zA-Z0-9_-])/g, '\\$1');
          };
          const state = (0, state_1.createInitialState)(BOOTSTRAP, detectLocale());
          const nodeRendererByType = new Map();
          let nodeResizeObserver = null;
          const getNodeRenderer = (typeId) => nodeRendererByType.get(typeId);
          const toNodeTypeClass = (typeId) => 'node-type-' + typeId.replace(/[^a-zA-Z0-9]+/g, '-').toLowerCase();
          const readCanvasControlsPosition = () => {
              try {
                  if (typeof localStorage === 'undefined') {
                      return null;
                  }
                  const raw = localStorage.getItem(CANVAS_CONTROLS_POSITION_KEY);
                  if (!raw) {
                      return null;
                  }
                  const parsed = JSON.parse(raw);
                  if (typeof parsed?.x === 'number' && typeof parsed?.y === 'number') {
                      return { x: parsed.x, y: parsed.y };
                  }
              }
              catch (error) {
                  console.warn('[NodeVision] failed to read canvas controls position', error);
              }
              return null;
          };
          const persistCanvasControlsPosition = (pos) => {
              try {
                  if (typeof localStorage === 'undefined') {
                      return;
                  }
                  if (!pos) {
                      localStorage.removeItem(CANVAS_CONTROLS_POSITION_KEY);
                      return;
                  }
                  localStorage.setItem(CANVAS_CONTROLS_POSITION_KEY, JSON.stringify(pos));
              }
              catch (error) {
                  console.warn('[NodeVision] failed to persist canvas controls position', error);
              }
          };
          const clampCanvasControlsPosition = (pos, dims) => {
              const rect = dims ?? elements.canvasControls.getBoundingClientRect();
              const width = Math.max(rect.width, 1);
              const height = Math.max(rect.height, 1);
              const maxX = Math.max(CANVAS_CONTROLS_MARGIN, window.innerWidth - width - CANVAS_CONTROLS_MARGIN);
              const maxY = Math.max(CANVAS_CONTROLS_MARGIN, window.innerHeight - height - CANVAS_CONTROLS_MARGIN);
              return {
                  x: Math.min(Math.max(pos.x, CANVAS_CONTROLS_MARGIN), maxX),
                  y: Math.min(Math.max(pos.y, CANVAS_CONTROLS_MARGIN), maxY)
              };
          };
          const applyCanvasControlsPosition = (pos) => {
              if (!pos) {
                  elements.canvasControls.style.left = '';
                  elements.canvasControls.style.top = '';
                  elements.canvasControls.style.bottom = '';
                  elements.canvasControls.style.right = '';
                  state.canvasControlsPosition = null;
                  return;
              }
              const clamped = clampCanvasControlsPosition(pos);
              elements.canvasControls.style.left = `${Math.round(clamped.x)}px`;
              elements.canvasControls.style.top = `${Math.round(clamped.y)}px`;
              elements.canvasControls.style.bottom = 'auto';
              elements.canvasControls.style.right = 'auto';
              state.canvasControlsPosition = { x: Math.round(clamped.x), y: Math.round(clamped.y) };
          };
          const storedControlsPosition = readCanvasControlsPosition();
          if (storedControlsPosition) {
              applyCanvasControlsPosition(storedControlsPosition);
          }
          const startCanvasControlsDrag = (event) => {
              if (event.button !== 0)
                  return;
              const target = event.target;
              if (target && (target.closest('button') || target.closest('input') || target.closest('select'))) {
                  if (!event.altKey) {
                      return;
                  }
              }
              const rect = elements.canvasControls.getBoundingClientRect();
              canvasControlsDragSession = {
                  pointerId: event.pointerId ?? 1,
                  offset: { x: event.clientX - rect.left, y: event.clientY - rect.top },
                  width: rect.width,
                  height: rect.height
              };
              elements.canvasControls.classList.add('is-dragging');
              elements.canvasControls.style.left = `${rect.left}px`;
              elements.canvasControls.style.top = `${rect.top}px`;
              elements.canvasControls.style.bottom = 'auto';
              elements.canvasControls.style.right = 'auto';
              state.canvasControlsPosition = { x: rect.left, y: rect.top };
              window.addEventListener('pointermove', handleCanvasControlsPointerMove);
              window.addEventListener('pointerup', handleCanvasControlsPointerUp);
              window.addEventListener('pointercancel', handleCanvasControlsPointerCancel);
              try {
                  elements.canvasControls.setPointerCapture(event.pointerId ?? 1);
              }
              catch {
                  /* ignore */
              }
              event.preventDefault();
          };
          const updateCanvasControlsPositionFromEvent = (event) => {
              if (!canvasControlsDragSession)
                  return;
              const { offset, width, height } = canvasControlsDragSession;
              const next = {
                  x: event.clientX - offset.x,
                  y: event.clientY - offset.y
              };
              const clamped = clampCanvasControlsPosition(next, { width, height });
              elements.canvasControls.style.left = `${Math.round(clamped.x)}px`;
              elements.canvasControls.style.top = `${Math.round(clamped.y)}px`;
              state.canvasControlsPosition = { x: Math.round(clamped.x), y: Math.round(clamped.y) };
          };
          const stopCanvasControlsDrag = (persist, event) => {
              if (!canvasControlsDragSession)
                  return;
              window.removeEventListener('pointermove', handleCanvasControlsPointerMove);
              window.removeEventListener('pointerup', handleCanvasControlsPointerUp);
              window.removeEventListener('pointercancel', handleCanvasControlsPointerCancel);
              if (persist) {
                  persistCanvasControlsPosition(state.canvasControlsPosition ?? null);
              }
              elements.canvasControls.classList.remove('is-dragging');
              if (event) {
                  try {
                      elements.canvasControls.releasePointerCapture(event.pointerId ?? canvasControlsDragSession.pointerId);
                  }
                  catch {
                      /* ignore */
                  }
              }
              canvasControlsDragSession = null;
          };
          const handleCanvasControlsPointerMove = (event) => {
              if (!canvasControlsDragSession || (event.pointerId ?? 1) !== canvasControlsDragSession.pointerId) {
                  return;
              }
              event.preventDefault();
              updateCanvasControlsPositionFromEvent(event);
          };
          const handleCanvasControlsPointerUp = (event) => {
              if (!canvasControlsDragSession || (event.pointerId ?? 1) !== canvasControlsDragSession.pointerId) {
                  return;
              }
              event.preventDefault();
              stopCanvasControlsDrag(true, event);
          };
          const handleCanvasControlsPointerCancel = (event) => {
              if (!canvasControlsDragSession || (event.pointerId ?? 1) !== canvasControlsDragSession.pointerId) {
                  return;
              }
              stopCanvasControlsDrag(false, event);
          };
          const handleCanvasControlsResize = () => {
              if (!state.canvasControlsPosition) {
                  return;
              }
              applyCanvasControlsPosition(state.canvasControlsPosition);
              persistCanvasControlsPosition(state.canvasControlsPosition);
          };
          const isEventInsideCanvas = (event) => {
              const rect = elements.canvas.getBoundingClientRect();
              return event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;
          };
          const MIN_ZOOM = 0.25;
          const MAX_ZOOM = 3;
          const ZOOM_STEP = 0.1;
          let panSession = null;
          let canvasControlsDragSession = null;
          let zoomMenuOpen = false;
          let activeConnectionDrag = null;
          let dropTargetPort = null;
          let marqueeSession = null;
          const formatTemplate = (template, vars = {}) => {
              let result = template;
              for (const [token, value] of Object.entries(vars)) {
                  const placeholder = '{{' + token + '}}';
                  result = result.split(placeholder).join(String(value));
              }
              let cleaned = '';
              let cursor = 0;
              while (cursor < result.length) {
                  const open = result.indexOf('{{', cursor);
                  if (open === -1) {
                      cleaned += result.slice(cursor);
                      break;
                  }
                  cleaned += result.slice(cursor, open);
                  const close = result.indexOf('}}', open + 2);
                  if (close === -1) {
                      break;
                  }
                  cursor = close + 2;
              }
              return cleaned;
          };
          const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj ?? {}, key);
          const lookupTranslation = (key) => {
              const localeDict = TRANSLATIONS[state.locale];
              if (localeDict && hasOwn(localeDict, key)) {
                  return localeDict[key];
              }
              const fallbackDict = TRANSLATIONS[FALLBACK_LOCALE];
              if (fallbackDict && hasOwn(fallbackDict, key)) {
                  return fallbackDict[key];
              }
              return null;
          };
          const translateWithFallback = (key, fallback, vars = {}) => {
              const template = lookupTranslation(key);
              const base = template ?? fallback;
              if (!base) {
                  return key;
              }
              return formatTemplate(base, vars);
          };
          const t = (key, vars = {}) => translateWithFallback(key, key, vars);
          const getNodeTitle = (node) => translateWithFallback(`nodeTemplate.${node.typeId}.title`, node.title);
          const getPortLabel = (typeId, port) => translateWithFallback(`nodeTemplate.${typeId}.port.${port.id}`, port.label);
          const getTemplateTitle = (template) => translateWithFallback(`nodeTemplate.${template.typeId}.title`, template.title);
          const getTemplateDescription = (template) => translateWithFallback(`nodeTemplate.${template.typeId}.description`, template.description ?? '');
          const applyI18nAttributes = (node) => {
              if (!node || !node.attributes)
                  return;
              Array.from(node.attributes).forEach(attr => {
                  if (!attr.name.startsWith('data-i18n-attr-'))
                      return;
                  const target = attr.name.replace('data-i18n-attr-', '');
                  const key = attr.value;
                  if (!key)
                      return;
                  node.setAttribute(target, t(key));
              });
          };
          const applyTranslations = () => {
              document.documentElement.lang = state.locale;
              document.querySelectorAll('[data-i18n-key]').forEach(node => {
                  const key = node.getAttribute('data-i18n-key');
                  if (!key)
                      return;
                  node.textContent = t(key);
                  applyI18nAttributes(node);
              });
              document.querySelectorAll('[data-i18n-html]').forEach(node => {
                  const key = node.getAttribute('data-i18n-html');
                  if (!key)
                      return;
                  node.innerHTML = t(key);
                  applyI18nAttributes(node);
              });
              document
                  .querySelectorAll('[data-i18n-attr-placeholder], [data-i18n-attr-aria-label], [data-i18n-attr-title]')
                  .forEach(applyI18nAttributes);
          };
          const templates = BOOTSTRAP.templates ?? [];
          const getTemplateByType = (typeId) => templates.find(template => template.typeId === typeId);
          applyTranslations();
          syncUnsavedWorkflowLabel();
          hydrateStoredWorkflows();
          const describeStatus = (status) => {
              switch (status) {
                  case 'running':
                      return t('queue.status.running');
                  case 'queued':
                      return t('queue.status.queued');
                  case 'coolingDown':
                      return t('queue.status.coolingDown');
                  case 'failed':
                      return t('queue.status.failed');
                  case 'canceled':
                      return t('queue.status.canceled');
                  default:
                      return status;
              }
          };
          const escapeHtml = (value) => String(value ?? '')
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
          const describeTrimDuration = (value) => {
              if (typeof value !== 'number' || !Number.isFinite(value)) {
                  return t('nodes.trim.video.durationUnknown');
              }
              if (value < 1000) {
                  return `${value} ms`;
              }
              if (value < 60000) {
                  return `${(value / 1000).toFixed(2)} s`;
              }
              const minutes = Math.floor(value / 60000);
              const remainingSeconds = ((value % 60000) / 1000).toFixed(1);
              return `${minutes}m ${remainingSeconds}s`;
          };
          const parseTrimTimecode = (raw) => {
              const value = raw.trim().replace(',', '.');
              if (!value) {
                  return null;
              }
              if (/^\d+(\.\d+)?$/.test(value)) {
                  const seconds = Number(value);
                  return Number.isFinite(seconds) ? Math.max(0, Math.round(seconds * 1000)) : null;
              }
              const segments = value.split(':').map(part => part.trim());
              if (!segments.length) {
                  return null;
              }
              let multiplier = 1;
              let total = 0;
              while (segments.length) {
                  const segment = segments.pop();
                  if (!segment) {
                      return null;
                  }
                  const number = Number(segment);
                  if (!Number.isFinite(number)) {
                      return null;
                  }
                  total += number * multiplier;
                  multiplier *= 60;
              }
              return Math.max(0, Math.round(total * 1000));
          };
          const trapFocusWithinModal = (event) => {
              if (!modalContainer)
                  return;
              const focusable = Array.from(modalContainer.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)).filter(element => !element.hasAttribute('disabled'));
              if (!focusable.length) {
                  event.preventDefault();
                  (modalCloseButton ?? modalContainer).focus();
                  return;
              }
              const first = focusable[0];
              const last = focusable[focusable.length - 1];
              const active = document.activeElement;
              if (event.shiftKey) {
                  if (active === first || !focusable.includes(active)) {
                      event.preventDefault();
                      last.focus();
                  }
              }
              else if (active === last) {
                  event.preventDefault();
                  first.focus();
              }
          };
          const closeActiveModal = () => {
              if (!activeModal) {
                  return;
              }
              activeModal = null;
              modalBackdrop?.setAttribute('data-open', 'false');
              modalContainer?.setAttribute('aria-hidden', 'true');
              if (modalTitleElement) {
                  modalTitleElement.textContent = '';
              }
              if (modalContentElement) {
                  modalContentElement.innerHTML = '';
              }
              const focusTarget = modalLastFocused;
              modalLastFocused = null;
              if (focusTarget) {
                  focusTarget.focus();
              }
          };
          const ensureModalHost = () => {
              if (modalBackdrop) {
                  return;
              }
              modalBackdrop = document.createElement('div');
              modalBackdrop.className = 'nv-modal-backdrop';
              modalBackdrop.dataset.open = 'false';
              modalBackdrop.innerHTML = `
            <div class="nv-modal" role="dialog" aria-modal="true" aria-hidden="true" tabindex="-1">
              <div class="nv-modal-header">
                <h2 data-modal-title></h2>
                <button type="button" class="nv-modal-close" data-modal-close aria-label="${escapeHtml(t('common.close'))}">
                  
                </button>
              </div>
              <div class="nv-modal-content" data-modal-content></div>
            </div>
          `;
              document.body.appendChild(modalBackdrop);
              modalContainer = modalBackdrop.querySelector('.nv-modal');
              modalTitleElement = modalBackdrop.querySelector('[data-modal-title]');
              modalContentElement = modalBackdrop.querySelector('[data-modal-content]');
              modalCloseButton = modalBackdrop.querySelector('[data-modal-close]');
              modalBackdrop.addEventListener('click', event => {
                  if (event.target === modalBackdrop) {
                      closeActiveModal();
                  }
              });
              modalBackdrop.addEventListener('keydown', event => {
                  if (event.key === 'Tab') {
                      trapFocusWithinModal(event);
                  }
              });
              modalCloseButton?.addEventListener('click', () => closeActiveModal());
              document.addEventListener('keydown', event => {
                  if (event.key === 'Escape' && activeModal) {
                      event.preventDefault();
                      closeActiveModal();
                  }
              });
          };
          const renderTrimImageModal = (session) => {
              if (!modalTitleElement || !modalContentElement) {
                  return;
              }
              modalTitleElement.textContent = t('nodes.trim.imageButton');
              modalContentElement.innerHTML = '';
              if (!session.sourcePreview) {
                  const warning = document.createElement('p');
                  warning.className = 'trim-modal-placeholder';
                  warning.textContent = t('nodes.trim.modalPlaceholder.noImage');
                  modalContentElement.appendChild(warning);
                  return;
              }
              const rotationValue = Math.round(session.draftRotationDeg || 0);
              const zoomPercent = Math.round((session.draftZoom || 1) * 100);
              const aspectOptions = ['free', 'original', 'square', '4:3', '16:9', '9:16'];
              modalContentElement.innerHTML = `
            <div class="trim-image-toolbar" role="toolbar">
              <div class="trim-image-toolbar-group">
                <button type="button" class="trim-tool-button" data-trim-tool="zoom-out" title="${escapeHtml(t('nodes.trim.imageTools.zoomOut'))}"></button>
                <button type="button" class="trim-tool-button" data-trim-tool="zoom-in" title="${escapeHtml(t('nodes.trim.imageTools.zoomIn'))}"></button>
                <button type="button" class="trim-tool-button" data-trim-tool="grid" data-active="${String(session.showGrid)}" title="${escapeHtml(t('nodes.trim.imageTools.grid'))}">
                  ${escapeHtml(t('nodes.trim.imageTools.grid'))}
                </button>
              </div>
              <div class="trim-image-toolbar-group">
                <button type="button" class="trim-tool-button" data-trim-tool="rotate-left" title="${escapeHtml(t('nodes.trim.imageTools.rotateLeft'))}">${escapeHtml(t('nodes.trim.imageTools.rotateLeft'))}</button>
                <button type="button" class="trim-tool-button" data-trim-tool="rotate-right" title="${escapeHtml(t('nodes.trim.imageTools.rotateRight'))}">${escapeHtml(t('nodes.trim.imageTools.rotateRight'))}</button>
                <button type="button" class="trim-tool-button" data-trim-tool="flip-horizontal" title="${escapeHtml(t('nodes.trim.imageTools.flipHorizontal'))}">${escapeHtml(t('nodes.trim.imageTools.flipHorizontalShort'))}</button>
                <button type="button" class="trim-tool-button" data-trim-tool="flip-vertical" title="${escapeHtml(t('nodes.trim.imageTools.flipVertical'))}">${escapeHtml(t('nodes.trim.imageTools.flipVerticalShort'))}</button>
                <button type="button" class="trim-tool-button" data-trim-tool="reset-transform" title="${escapeHtml(t('nodes.trim.imageTools.reset'))}">${escapeHtml(t('nodes.trim.imageTools.reset'))}</button>
              </div>
            </div>
            <div class="trim-stage-wrapper" data-trim-stage-wrapper>
              <div class="trim-image-stage" data-trim-stage>
              <img src="${session.sourcePreview.url}" alt="${escapeHtml(session.sourcePreview.name)}" />
              <div class="trim-crop-box" data-trim-box>
                ${['n', 's', 'w', 'e', 'nw', 'ne', 'sw', 'se']
                  .map(handle => `<div class="trim-crop-handle" data-trim-handle="${handle}"></div>`)
                  .join('')}
              </div>
              <div class="trim-grid-overlay${session.showGrid ? ' is-visible' : ''}" data-trim-grid-overlay></div>
            </div>
            </div>
            <div class="trim-image-controls">
              <div class="trim-control">
                <label>
                  <span>${escapeHtml(t('nodes.trim.imageControls.rotation'))}</span>
                  <div class="trim-control-inputs">
                    <input type="range" min="-180" max="180" step="1" value="${rotationValue}" data-trim-rotation-range />
                    <input type="number" min="-180" max="180" step="1" value="${rotationValue}" data-trim-rotation-input />
                    <span class="trim-control-unit"></span>
                  </div>
                </label>
              </div>
              <div class="trim-control">
                <label>
                  <span>${escapeHtml(t('nodes.trim.imageControls.zoom'))}</span>
                  <div class="trim-control-inputs">
                    <input type="range" min="0.25" max="4" step="0.05" value="${session.draftZoom ?? 1}" data-trim-zoom-range />
                    <span class="trim-control-badge" data-trim-zoom-label>${zoomPercent}%</span>
                  </div>
                </label>
              </div>
              <div class="trim-control">
                <label>
                  <span>${escapeHtml(t('nodes.trim.imageControls.aspect'))}</span>
                  <select data-trim-aspect>
                    ${aspectOptions
                  .map(option => `
                          <option value="${option}" ${option === session.draftAspectMode ? 'selected' : ''}>
                            ${escapeHtml(t(`nodes.trim.imageControls.aspectOption.${option}`))}
                          </option>`)
                  .join('')}
                  </select>
                </label>
              </div>
            </div>
            <p class="trim-modal-hint">${escapeHtml(t('nodes.trim.modalPlaceholder.image'))}</p>
            <div class="trim-modal-actions">
              <button type="button" class="pill-button" data-trim-reset>${escapeHtml(t('actions.reset'))}</button>
              <span class="trim-modal-actions-spacer"></span>
              <button type="button" class="pill-button" data-trim-cancel>${escapeHtml(t('actions.cancel'))}</button>
              <button type="button" class="pill-button primary" data-trim-save>${escapeHtml(t('actions.save'))}</button>
            </div>
          `;
              const imageElement = modalContentElement.querySelector('.trim-image-stage img');
              if (imageElement?.complete ?? false) {
                  initializeTrimImageControls(session);
              }
              else {
                  imageElement?.addEventListener('load', () => {
                      initializeTrimImageControls(session);
                  }, { once: true });
              }
          };
          const renderTrimVideoModal = (session) => {
              if (!modalTitleElement || !modalContentElement) {
                  return;
              }
              const preview = session.sourcePreview?.kind === 'video' ? session.sourcePreview : null;
              const hasPreview = Boolean(preview);
              const disabledAttr = hasPreview ? '' : ' disabled';
              const startValue = (0, trim_shared_1.formatTrimTimecode)(session.draftStart);
              const endValue = (0, trim_shared_1.formatTrimTimecode)(session.draftEnd);
              const previewName = preview?.name ?? t('nodes.trim.video.previewFallback');
              const durationLabel = describeTrimDuration(session.durationMs ?? preview?.durationMs ?? null);
              const previewMarkup = preview
                  ? `<video src="${preview.url}" data-trim-video-player preload="metadata" playsinline muted controls></video>`
                  : `<div class="trim-video-preview-empty">${escapeHtml(t('nodes.trim.modalPlaceholder.noVideo'))}</div>`;
              modalTitleElement.textContent = t('nodes.trim.videoButton');
              modalContentElement.innerHTML = `
            <div class="trim-video-layout" data-trim-video-ready="${hasPreview}">
              <div class="trim-video-preview${hasPreview ? '' : ' is-empty'}" data-trim-video-preview>
                ${previewMarkup}
                <div class="trim-video-preview-meta">
                  <span class="trim-video-preview-name" title="${escapeHtml(previewName)}">${escapeHtml(previewName)}</span>
                  <span class="trim-video-preview-duration" data-trim-video-duration>${escapeHtml(durationLabel)}</span>
                </div>
              </div>
              <div class="trim-video-fields">
                <label class="trim-video-field">
                  <span>${escapeHtml(t('nodes.trim.video.startLabel'))}</span>
                  <input type="text" data-trim-video-start value="${escapeHtml(startValue)}" placeholder="00:00.000" inputmode="decimal"${disabledAttr} />
                </label>
                <label class="trim-video-field">
                  <span>${escapeHtml(t('nodes.trim.video.endLabel'))}</span>
                  <input type="text" data-trim-video-end value="${escapeHtml(endValue)}" placeholder="00:00.000" inputmode="decimal"${disabledAttr} />
                </label>
                <label class="trim-video-checkbox">
                  <input type="checkbox" data-trim-video-strict${session.draftStrict ? ' checked' : ''}${disabledAttr} />
                  <div>
                    <span>${escapeHtml(t('nodes.trim.video.strictLabel'))}</span>
                    <small>${escapeHtml(t('nodes.trim.video.strictHint'))}</small>
                  </div>
                </label>
              </div>
            </div>
            <div class="trim-video-timeline"${hasPreview ? '' : ' data-disabled="true"'} data-trim-video-timeline>
              <div class="trim-video-track" data-trim-video-track>
                <div class="trim-video-range" data-trim-video-range>
                  <button type="button" class="trim-video-handle" data-trim-video-handle="start" aria-label="${escapeHtml(t('nodes.trim.video.startHandle'))}"${disabledAttr}></button>
                  <button type="button" class="trim-video-handle" data-trim-video-handle="end" aria-label="${escapeHtml(t('nodes.trim.video.endHandle'))}"${disabledAttr}></button>
                </div>
              </div>
              <div class="trim-video-timecodes">
                <span data-trim-video-timecode="start">${escapeHtml(startValue || '00:00.000')}</span>
                <span data-trim-video-timecode="playhead">00:00.000</span>
                <span data-trim-video-timecode="end">${escapeHtml(endValue || '--:--.---')}</span>
              </div>
            </div>
            <p class="trim-modal-hint">${escapeHtml(t('nodes.trim.modalHint.video'))}</p>
            <div class="trim-modal-actions trim-video-actions">
              <div class="trim-video-transport">
                <button type="button" class="pill-button" data-trim-video-jog="back"${disabledAttr}>${escapeHtml(t('nodes.trim.video.controls.stepBack'))}</button>
                <button type="button" class="pill-button" data-trim-video-play${disabledAttr}>${escapeHtml(t('nodes.trim.video.controls.play'))}</button>
                <button type="button" class="pill-button" data-trim-video-jog="forward"${disabledAttr}>${escapeHtml(t('nodes.trim.video.controls.stepForward'))}</button>
              </div>
              <span class="trim-modal-actions-spacer"></span>
              <button type="button" class="pill-button" data-trim-reset${disabledAttr}>${escapeHtml(t('actions.reset'))}</button>
              <button type="button" class="pill-button" data-trim-cancel>${escapeHtml(t('actions.cancel'))}</button>
              <button type="button" class="pill-button primary" data-trim-save${disabledAttr}>${escapeHtml(t('actions.save'))}</button>
            </div>
          `;
              initializeTrimVideoControls(session);
          };
          const renderTrimModalView = (state) => {
              if (!modalContentElement || !modalTitleElement) {
                  return;
              }
              if (state.mode === 'image') {
                  renderTrimImageModal(state);
                  return;
              }
              renderTrimVideoModal(state);
          };
          const persistTrimSettings = (nodeId, mutate, toastKey) => {
              const targetNode = state.nodes.find(entry => entry.id === nodeId);
              if (!targetNode) {
                  closeActiveModal();
                  return;
              }
              const settings = (0, trim_shared_1.ensureTrimSettings)(targetNode);
              mutate(settings);
              scheduleTrimPreviewUpdate(targetNode);
              closeActiveModal();
              commitState();
              showToast(t(toastKey));
          };
          const initializeTrimImageControls = (session) => {
              const modalContent = modalContentElement;
              if (!modalContent) {
                  return;
              }
              const stage = modalContent.querySelector('[data-trim-stage]');
              const cropBox = modalContent.querySelector('[data-trim-box]');
              const imageElement = modalContent.querySelector('.trim-image-stage img');
              const gridOverlay = modalContent.querySelector('[data-trim-grid-overlay]');
              const rotationRange = modalContent.querySelector('[data-trim-rotation-range]');
              const rotationInput = modalContent.querySelector('[data-trim-rotation-input]');
              const zoomRange = modalContent.querySelector('[data-trim-zoom-range]');
              const zoomLabel = modalContent.querySelector('[data-trim-zoom-label]');
              const aspectSelect = modalContent.querySelector('[data-trim-aspect]');
              const toolbarButtons = modalContent.querySelectorAll('[data-trim-tool]');
              if (!stage || !cropBox) {
                  return;
              }
              const getImageAspectRatio = () => {
                  const preview = session.sourcePreview;
                  if (preview?.width && preview?.height) {
                      return preview.width / preview.height;
                  }
                  if (imageElement?.naturalWidth && imageElement?.naturalHeight) {
                      return imageElement.naturalWidth / imageElement.naturalHeight;
                  }
                  return 1;
              };
              const aspectValueMap = {
                  free: null,
                  original: null,
                  square: 1,
                  '4:3': 4 / 3,
                  '16:9': 16 / 9,
                  '9:16': 9 / 16
              };
              const getSelectedAspectRatio = () => {
                  const mode = session.draftAspectMode ?? 'free';
                  if (mode === 'original') {
                      return getImageAspectRatio();
                  }
                  return aspectValueMap[mode] ?? null;
              };
              const getNormalizedAspectRatio = () => {
                  const target = getSelectedAspectRatio();
                  if (!target) {
                      return null;
                  }
                  const imageAspect = getImageAspectRatio() || 1;
                  if (!imageAspect) {
                      return null;
                  }
                  return target / imageAspect;
              };
              const clampSize = (value) => clampValue(value, MIN_TRIM_REGION_SIZE, 1);
              const clampRegionPosition = (region) => {
                  return {
                      ...region,
                      x: clampValue(region.x, 0, 1 - region.width),
                      y: clampValue(region.y, 0, 1 - region.height)
                  };
              };
              const buildRegionFromAnchor = (width, height, handle, reference) => {
                  const left = reference.x;
                  const top = reference.y;
                  const right = reference.x + reference.width;
                  const bottom = reference.y + reference.height;
                  const centerX = left + reference.width / 2;
                  const centerY = top + reference.height / 2;
                  let x = reference.x;
                  let y = reference.y;
                  switch (handle) {
                      case 'nw':
                          x = right - width;
                          y = bottom - height;
                          break;
                      case 'ne':
                          x = left;
                          y = bottom - height;
                          break;
                      case 'sw':
                          x = right - width;
                          y = top;
                          break;
                      case 'se':
                          x = left;
                          y = top;
                          break;
                      case 'n':
                          x = centerX - width / 2;
                          y = bottom - height;
                          break;
                      case 's':
                          x = centerX - width / 2;
                          y = top;
                          break;
                      case 'w':
                          x = right - width;
                          y = centerY - height / 2;
                          break;
                      case 'e':
                          x = left;
                          y = centerY - height / 2;
                          break;
                      case 'center':
                      default:
                          x = centerX - width / 2;
                          y = centerY - height / 2;
                          break;
                  }
                  return { x, y, width, height };
              };
              const applyAspectConstraint = (region, handle) => {
                  const normalizedRatio = getNormalizedAspectRatio();
                  const reference = { ...region };
                  const baseWidth = clampSize(reference.width);
                  const baseHeight = clampSize(reference.height);
                  if (!normalizedRatio) {
                      return clampRegionPosition({ ...reference, width: baseWidth, height: baseHeight });
                  }
                  const widthFromHeight = clampSize(baseHeight * normalizedRatio);
                  const heightFromWidth = clampSize(baseWidth / normalizedRatio);
                  const regionByWidth = clampRegionPosition(buildRegionFromAnchor(widthFromHeight, baseHeight, handle, reference));
                  const regionByHeight = clampRegionPosition(buildRegionFromAnchor(baseWidth, heightFromWidth, handle, reference));
                  if (handle === 'n' || handle === 's') {
                      return regionByWidth;
                  }
                  if (handle === 'e' || handle === 'w') {
                      return regionByHeight;
                  }
                  const computeRatioError = (candidate) => {
                      const candidateRatio = candidate.width / candidate.height;
                      return Math.abs(candidateRatio - normalizedRatio);
                  };
                  const widthError = computeRatioError(regionByWidth);
                  const heightError = computeRatioError(regionByHeight);
                  if (widthError < heightError - 0.0001) {
                      return regionByWidth;
                  }
                  if (heightError < widthError - 0.0001) {
                      return regionByHeight;
                  }
                  const areaWidth = regionByWidth.width * regionByWidth.height;
                  const areaHeight = regionByHeight.width * regionByHeight.height;
                  return areaWidth >= areaHeight ? regionByWidth : regionByHeight;
              };
              const applyStageAspectRatio = () => {
                  if (!imageElement) {
                      return;
                  }
                  const { naturalWidth, naturalHeight } = imageElement;
                  if (!naturalWidth || !naturalHeight) {
                      return;
                  }
                  const ratioValue = `${naturalWidth} / ${naturalHeight}`;
                  stage.style.setProperty('aspect-ratio', ratioValue);
                  stage.style.setProperty('--trim-image-aspect', ratioValue);
              };
              applyStageAspectRatio();
              const clampRotation = (value) => Math.max(-180, Math.min(180, value));
              const clampZoom = (value) => Math.max(0.25, Math.min(4, value));
              const updateZoomLabel = () => {
                  if (!zoomLabel)
                      return;
                  const zoomPercent = Math.round((session.draftZoom ?? 1) * 100);
                  zoomLabel.textContent = `${zoomPercent}%`;
              };
              const updateTransformStyles = () => {
                  if (!imageElement) {
                      return;
                  }
                  const rotation = clampRotation(session.draftRotationDeg ?? 0);
                  const zoomValue = clampZoom(session.draftZoom ?? 1);
                  session.draftRotationDeg = rotation;
                  session.draftZoom = zoomValue;
                  const flipX = session.draftFlipHorizontal ? -1 : 1;
                  const flipY = session.draftFlipVertical ? -1 : 1;
                  imageElement.style.transform = `rotate(${rotation}deg) scaleX(${zoomValue * flipX}) scaleY(${zoomValue * flipY})`;
                  if (gridOverlay) {
                      gridOverlay.classList.toggle('is-visible', session.showGrid);
                      gridOverlay.style.transform = `rotate(${rotation}deg)`;
                  }
                  updateZoomLabel();
              };
              const syncRotationControls = () => {
                  const value = String(clampRotation(session.draftRotationDeg ?? 0));
                  if (rotationRange)
                      rotationRange.value = value;
                  if (rotationInput)
                      rotationInput.value = value;
              };
              const syncZoomControls = () => {
                  if (zoomRange) {
                      zoomRange.value = String(clampZoom(session.draftZoom ?? 1));
                  }
                  updateZoomLabel();
              };
              const setRotation = (value) => {
                  session.draftRotationDeg = clampRotation(value);
                  syncRotationControls();
                  updateTransformStyles();
              };
              const setZoom = (value) => {
                  session.draftZoom = clampZoom(value);
                  syncZoomControls();
                  updateTransformStyles();
              };
              const toggleFlip = (axis) => {
                  if (axis === 'horizontal') {
                      session.draftFlipHorizontal = !session.draftFlipHorizontal;
                  }
                  else {
                      session.draftFlipVertical = !session.draftFlipVertical;
                  }
                  updateTransformStyles();
              };
              const toggleGrid = () => {
                  session.showGrid = !session.showGrid;
                  updateTransformStyles();
                  const gridButton = modalContent.querySelector('[data-trim-tool="grid"]');
                  gridButton?.setAttribute('data-active', String(session.showGrid));
              };
              syncRotationControls();
              syncZoomControls();
              updateTransformStyles();
              const clampValue = (value, min, max) => Math.min(max, Math.max(min, value));
              const updateCropBoxStyles = () => {
                  const region = session.draftRegion;
                  cropBox.style.left = `${region.x * 100}%`;
                  cropBox.style.top = `${region.y * 100}%`;
                  cropBox.style.width = `${region.width * 100}%`;
                  cropBox.style.height = `${region.height * 100}%`;
              };
              const stopInteraction = (pointerMove, pointerUp) => {
                  window.removeEventListener('pointermove', pointerMove);
                  window.removeEventListener('pointerup', pointerUp);
              };
              const startMove = (event) => {
                  event.preventDefault();
                  const rect = stage.getBoundingClientRect();
                  const pointerId = event.pointerId ?? 1;
                  const start = { ...session.draftRegion };
                  const startX = event.clientX;
                  const startY = event.clientY;
                  const handleMove = (moveEvent) => {
                      if (moveEvent.pointerId !== pointerId)
                          return;
                      moveEvent.preventDefault();
                      const deltaX = (moveEvent.clientX - startX) / rect.width;
                      const deltaY = (moveEvent.clientY - startY) / rect.height;
                      const nextX = clampValue(start.x + deltaX, 0, 1 - start.width);
                      const nextY = clampValue(start.y + deltaY, 0, 1 - start.height);
                      session.draftRegion = { ...start, x: nextX, y: nextY };
                      updateCropBoxStyles();
                  };
                  const handleUp = (moveEvent) => {
                      if (moveEvent.pointerId !== pointerId)
                          return;
                      stopInteraction(handleMove, handleUp);
                  };
                  window.addEventListener('pointermove', handleMove);
                  window.addEventListener('pointerup', handleUp);
              };
              const startResize = (handle, event) => {
                  event.preventDefault();
                  const rect = stage.getBoundingClientRect();
                  const pointerId = event.pointerId ?? 1;
                  const start = { ...session.draftRegion };
                  const startX = event.clientX;
                  const startY = event.clientY;
                  const handleMove = (moveEvent) => {
                      if (moveEvent.pointerId !== pointerId)
                          return;
                      moveEvent.preventDefault();
                      const deltaX = (moveEvent.clientX - startX) / rect.width;
                      const deltaY = (moveEvent.clientY - startY) / rect.height;
                      let next = { ...start };
                      if (handle.includes('n')) {
                          const newY = clampValue(start.y + deltaY, 0, start.y + start.height - MIN_TRIM_REGION_SIZE);
                          next.height = clampValue(start.height + (start.y - newY), MIN_TRIM_REGION_SIZE, 1 - newY);
                          next.y = newY;
                      }
                      if (handle.includes('s')) {
                          const newHeight = clampValue(start.height + deltaY, MIN_TRIM_REGION_SIZE, 1 - start.y);
                          next.height = newHeight;
                      }
                      if (handle.includes('w')) {
                          const newX = clampValue(start.x + deltaX, 0, start.x + start.width - MIN_TRIM_REGION_SIZE);
                          next.width = clampValue(start.width + (start.x - newX), MIN_TRIM_REGION_SIZE, 1 - newX);
                          next.x = newX;
                      }
                      if (handle.includes('e')) {
                          const newWidth = clampValue(start.width + deltaX, MIN_TRIM_REGION_SIZE, 1 - start.x);
                          next.width = newWidth;
                      }
                      if (next.x + next.width > 1) {
                          next.width = 1 - next.x;
                      }
                      if (next.y + next.height > 1) {
                          next.height = 1 - next.y;
                      }
                      session.draftRegion = applyAspectConstraint(next, handle);
                      updateCropBoxStyles();
                  };
                  const handleUp = (moveEvent) => {
                      if (moveEvent.pointerId !== pointerId)
                          return;
                      stopInteraction(handleMove, handleUp);
                  };
                  window.addEventListener('pointermove', handleMove);
                  window.addEventListener('pointerup', handleUp);
              };
              cropBox.addEventListener('pointerdown', event => {
                  const target = event.target;
                  const handle = target?.dataset.trimHandle;
                  if (handle) {
                      startResize(handle, event);
                  }
                  else {
                      startMove(event);
                  }
              });
              modalContent.querySelector('[data-trim-reset]')?.addEventListener('click', () => {
                  session.draftRegion = applyAspectConstraint({ ...DEFAULT_TRIM_REGION }, 'center');
                  session.draftRotationDeg = 0;
                  session.draftZoom = 1;
                  session.draftFlipHorizontal = false;
                  session.draftFlipVertical = false;
                  session.draftAspectMode = 'free';
                  session.showGrid = false;
                  const gridButton = modalContent.querySelector('[data-trim-tool="grid"]');
                  gridButton?.setAttribute('data-active', 'false');
                  syncRotationControls();
                  syncZoomControls();
                  updateTransformStyles();
                  if (aspectSelect) {
                      aspectSelect.value = 'free';
                  }
                  updateCropBoxStyles();
              });
              modalContent.querySelector('[data-trim-cancel]')?.addEventListener('click', () => {
                  closeActiveModal();
              });
              modalContent.querySelector('[data-trim-save]')?.addEventListener('click', () => {
                  persistTrimSettings(session.nodeId, settings => {
                      settings.region = { ...session.draftRegion };
                      settings.rotationDeg = clampTrimRotation(session.draftRotationDeg ?? 0);
                      settings.zoom = clampTrimZoom(session.draftZoom ?? 1);
                      settings.flipHorizontal = Boolean(session.draftFlipHorizontal);
                      settings.flipVertical = Boolean(session.draftFlipVertical);
                      settings.aspectMode = session.draftAspectMode ?? 'free';
                  }, 'nodes.trim.toast.imageSaved');
              });
              rotationRange?.addEventListener('input', event => {
                  const value = Number(event.target.value);
                  setRotation(value);
              });
              rotationInput?.addEventListener('change', event => {
                  const value = Number(event.target.value);
                  setRotation(value);
              });
              zoomRange?.addEventListener('input', event => {
                  const value = Number(event.target.value);
                  setZoom(value);
              });
              aspectSelect?.addEventListener('change', event => {
                  const value = event.target.value;
                  session.draftAspectMode = value;
                  session.draftRegion = applyAspectConstraint(session.draftRegion, 'center');
                  updateCropBoxStyles();
              });
              toolbarButtons.forEach(button => {
                  const tool = button.dataset.trimTool;
                  button.addEventListener('click', () => {
                      switch (tool) {
                          case 'zoom-in':
                              setZoom((session.draftZoom ?? 1) + 0.1);
                              break;
                          case 'zoom-out':
                              setZoom((session.draftZoom ?? 1) - 0.1);
                              break;
                          case 'grid':
                              toggleGrid();
                              break;
                          case 'rotate-left':
                              setRotation((session.draftRotationDeg ?? 0) - 90);
                              break;
                          case 'rotate-right':
                              setRotation((session.draftRotationDeg ?? 0) + 90);
                              break;
                          case 'flip-horizontal':
                              toggleFlip('horizontal');
                              break;
                          case 'flip-vertical':
                              toggleFlip('vertical');
                              break;
                          case 'reset-transform':
                              session.draftRotationDeg = 0;
                              session.draftZoom = 1;
                              session.draftFlipHorizontal = false;
                              session.draftFlipVertical = false;
                              syncRotationControls();
                              syncZoomControls();
                              updateTransformStyles();
                              break;
                          default:
                              break;
                      }
                  });
              });
              session.draftRegion = applyAspectConstraint(session.draftRegion, 'center');
              updateCropBoxStyles();
          };
          const initializeTrimVideoControls = (session) => {
              if (!modalContentElement) {
                  return;
              }
              const cancelButton = modalContentElement.querySelector('[data-trim-cancel]');
              cancelButton?.addEventListener('click', () => {
                  closeActiveModal();
              });
              if (!session.sourcePreview || session.sourcePreview.kind !== 'video') {
                  return;
              }
              const videoElement = modalContentElement.querySelector('[data-trim-video-player]');
              const startInput = modalContentElement.querySelector('[data-trim-video-start]');
              const endInput = modalContentElement.querySelector('[data-trim-video-end]');
              const strictInput = modalContentElement.querySelector('[data-trim-video-strict]');
              const timeline = modalContentElement.querySelector('[data-trim-video-timeline]');
              const track = modalContentElement.querySelector('[data-trim-video-track]');
              const range = modalContentElement.querySelector('[data-trim-video-range]');
              const startHandle = modalContentElement.querySelector('[data-trim-video-handle="start"]');
              const endHandle = modalContentElement.querySelector('[data-trim-video-handle="end"]');
              const timecodeStart = modalContentElement.querySelector('[data-trim-video-timecode="start"]');
              const timecodeEnd = modalContentElement.querySelector('[data-trim-video-timecode="end"]');
              const timecodePlayhead = modalContentElement.querySelector('[data-trim-video-timecode="playhead"]');
              const playButton = modalContentElement.querySelector('[data-trim-video-play]');
              const jogButtons = Array.from(modalContentElement.querySelectorAll('[data-trim-video-jog]'));
              const resetButton = modalContentElement.querySelector('[data-trim-reset]');
              const saveButton = modalContentElement.querySelector('[data-trim-save]');
              if (!videoElement || !startInput || !endInput || !timeline || !track || !range) {
                  return;
              }
              const getDuration = () => {
                  if (typeof session.durationMs === 'number' && session.durationMs > 0) {
                      return session.durationMs;
                  }
                  const previewDuration = session.sourcePreview?.durationMs;
                  if (typeof previewDuration === 'number' && previewDuration > 0) {
                      session.durationMs = previewDuration;
                      return previewDuration;
                  }
                  if (Number.isFinite(videoElement.duration) && videoElement.duration > 0) {
                      const computed = Math.round(videoElement.duration * 1000);
                      session.durationMs = computed;
                      return computed;
                  }
                  return 0;
              };
              const clampValue = (value, min, max) => Math.min(max, Math.max(min, value));
              const normalizeRangeForSettings = (startValue, endValue, duration) => {
                  const sanitize = (value) => {
                      if (typeof value !== 'number' || !Number.isFinite(value)) {
                          return null;
                      }
                      return Math.max(0, Math.round(value));
                  };
                  let normalizedStart = sanitize(startValue);
                  let normalizedEnd = sanitize(endValue);
                  if (normalizedStart !== null && normalizedStart <= TRIM_VIDEO_DEFAULT_EPSILON_MS) {
                      normalizedStart = null;
                  }
                  if (duration && normalizedEnd !== null && Math.abs(normalizedEnd - duration) <= TRIM_VIDEO_DEFAULT_EPSILON_MS) {
                      normalizedEnd = null;
                  }
                  if (normalizedEnd !== null && normalizedStart !== null && normalizedEnd < normalizedStart) {
                      normalizedEnd = normalizedStart;
                  }
                  return { start: normalizedStart, end: normalizedEnd };
              };
              const ensureDraftBounds = () => {
                  const duration = getDuration();
                  const defaultEnd = duration > 0 ? duration : MIN_TRIM_VIDEO_RANGE_MS;
                  if (session.draftStart == null || session.draftStart < 0) {
                      session.draftStart = 0;
                  }
                  if (session.draftEnd == null || session.draftEnd <= session.draftStart) {
                      session.draftEnd = duration > 0 ? duration : session.draftStart + MIN_TRIM_VIDEO_RANGE_MS;
                  }
                  if (duration > 0 && session.draftEnd > duration) {
                      session.draftEnd = duration;
                  }
                  if ((session.draftEnd ?? defaultEnd) - (session.draftStart ?? 0) < MIN_TRIM_VIDEO_RANGE_MS) {
                      session.draftEnd = Math.min(duration > 0 ? duration : session.draftStart + MIN_TRIM_VIDEO_RANGE_MS, (session.draftStart ?? 0) + MIN_TRIM_VIDEO_RANGE_MS);
                  }
                  if (duration > 0 && (session.draftEnd ?? duration) > duration) {
                      session.draftEnd = duration;
                  }
              };
              const updateInputValues = () => {
                  startInput.value = (0, trim_shared_1.formatTrimTimecode)(session.draftStart ?? 0) || '00:00.000';
                  endInput.value =
                      (0, trim_shared_1.formatTrimTimecode)(session.draftEnd ?? session.draftStart ?? 0) || (0, trim_shared_1.formatTrimTimecode)(session.draftStart ?? 0);
                  if (strictInput) {
                      strictInput.checked = Boolean(session.draftStrict);
                  }
              };
              const updateTimelineStyles = () => {
                  const duration = getDuration();
                  if (!duration || !track || !range) {
                      timeline.dataset.disabled = 'true';
                      return;
                  }
                  timeline.dataset.disabled = 'false';
                  const rect = track.getBoundingClientRect();
                  const usable = Math.max(1, rect.width - TRIM_VIDEO_TIMELINE_PADDING * 2);
                  const startRatio = clampValue((session.draftStart ?? 0) / duration, 0, 1);
                  const endRatio = clampValue((session.draftEnd ?? duration) / duration, startRatio, 1);
                  const left = TRIM_VIDEO_TIMELINE_PADDING + startRatio * usable;
                  const width = Math.max(4, (endRatio - startRatio) * usable);
                  range.style.left = `${left}px`;
                  range.style.width = `${width}px`;
              };
              const updateTimecodeLabels = () => {
                  if (timecodeStart) {
                      timecodeStart.textContent = (0, trim_shared_1.formatTrimTimecode)(session.draftStart ?? 0) || '00:00.000';
                  }
                  if (timecodeEnd) {
                      const endValue = session.draftEnd ?? session.draftStart ?? 0;
                      timecodeEnd.textContent = (0, trim_shared_1.formatTrimTimecode)(endValue) || '--:--.---';
                  }
              };
              const updatePlayheadLabel = () => {
                  if (timecodePlayhead) {
                      timecodePlayhead.textContent =
                          (0, trim_shared_1.formatTrimTimecode)(Math.round(videoElement.currentTime * 1000)) || '00:00.000';
                  }
              };
              const refreshUi = () => {
                  ensureDraftBounds();
                  updateInputValues();
                  updateTimelineStyles();
                  updateTimecodeLabels();
                  updatePlayheadLabel();
              };
              const setDraftStart = (nextValue) => {
                  const duration = getDuration();
                  const maxStart = Math.max(0, (session.draftEnd ?? (duration || MIN_TRIM_VIDEO_RANGE_MS)) - MIN_TRIM_VIDEO_RANGE_MS);
                  session.draftStart = clampValue(Math.round(nextValue), 0, maxStart);
                  if ((session.draftEnd ?? session.draftStart) - session.draftStart < MIN_TRIM_VIDEO_RANGE_MS) {
                      session.draftEnd = session.draftStart + MIN_TRIM_VIDEO_RANGE_MS;
                  }
                  if (duration > 0 && (session.draftEnd ?? duration) > duration) {
                      session.draftEnd = duration;
                  }
                  refreshUi();
              };
              const setDraftEnd = (nextValue) => {
                  const duration = getDuration();
                  const minEnd = (session.draftStart ?? 0) + MIN_TRIM_VIDEO_RANGE_MS;
                  const maxEnd = duration || Math.max(nextValue, minEnd);
                  session.draftEnd = clampValue(Math.round(nextValue), minEnd, maxEnd);
                  refreshUi();
              };
              const setFromInput = (kind, raw) => {
                  const parsed = parseTrimTimecode(raw);
                  if (parsed == null) {
                      refreshUi();
                      return;
                  }
                  if (kind === 'start') {
                      setDraftStart(parsed);
                  }
                  else {
                      setDraftEnd(parsed);
                  }
              };
              startInput.addEventListener('change', () => setFromInput('start', startInput.value));
              startInput.addEventListener('blur', () => setFromInput('start', startInput.value));
              endInput.addEventListener('change', () => setFromInput('end', endInput.value));
              endInput.addEventListener('blur', () => setFromInput('end', endInput.value));
              strictInput?.addEventListener('change', () => {
                  session.draftStrict = Boolean(strictInput.checked);
              });
              const durationSync = () => {
                  const duration = getDuration();
                  if (!duration) {
                      return;
                  }
                  if (session.draftEnd == null || session.draftEnd > duration) {
                      session.draftEnd = duration;
                  }
                  refreshUi();
              };
              if (videoElement.readyState >= 1) {
                  durationSync();
              }
              else {
                  videoElement.addEventListener('loadedmetadata', () => {
                      durationSync();
                  });
              }
              const handlePointerDrag = (handle, event) => {
                  const duration = getDuration();
                  if (!duration) {
                      return;
                  }
                  event.preventDefault();
                  const rect = track.getBoundingClientRect();
                  const usable = Math.max(1, rect.width - TRIM_VIDEO_TIMELINE_PADDING * 2);
                  const pointerId = event.pointerId ?? 1;
                  const move = (moveEvent) => {
                      if (moveEvent.pointerId !== pointerId) {
                          return;
                      }
                      moveEvent.preventDefault();
                      const relative = clampValue(moveEvent.clientX - rect.left - TRIM_VIDEO_TIMELINE_PADDING, 0, usable);
                      const ratio = relative / usable;
                      const nextValue = ratio * duration;
                      if (handle === 'start') {
                          setDraftStart(nextValue);
                      }
                      else {
                          setDraftEnd(nextValue);
                      }
                  };
                  const stop = (moveEvent) => {
                      if (moveEvent.pointerId !== pointerId) {
                          return;
                      }
                      window.removeEventListener('pointermove', move);
                      window.removeEventListener('pointerup', stop);
                  };
                  window.addEventListener('pointermove', move);
                  window.addEventListener('pointerup', stop);
              };
              startHandle?.addEventListener('pointerdown', event => handlePointerDrag('start', event));
              endHandle?.addEventListener('pointerdown', event => handlePointerDrag('end', event));
              const updatePlayButtonState = () => {
                  if (!playButton) {
                      return;
                  }
                  playButton.textContent = videoElement.paused
                      ? t('nodes.trim.video.controls.play')
                      : t('nodes.trim.video.controls.pause');
              };
              const stopPlaybackIfNeeded = () => {
                  const end = session.draftEnd ?? getDuration();
                  if (!end) {
                      return;
                  }
                  if (videoElement.currentTime * 1000 >= end - 5) {
                      videoElement.pause();
                      videoElement.currentTime = end / 1000;
                      updatePlayButtonState();
                  }
              };
              playButton?.addEventListener('click', () => {
                  if (videoElement.paused) {
                      videoElement.currentTime = (session.draftStart ?? 0) / 1000;
                      void videoElement.play().catch(error => console.warn('[NodeVision] video preview play failed', error));
                  }
                  else {
                      videoElement.pause();
                  }
                  updatePlayButtonState();
              });
              videoElement.addEventListener('play', updatePlayButtonState);
              videoElement.addEventListener('pause', updatePlayButtonState);
              videoElement.addEventListener('timeupdate', () => {
                  updatePlayheadLabel();
                  stopPlaybackIfNeeded();
              });
              videoElement.addEventListener('ended', () => {
                  updatePlayButtonState();
                  updatePlayheadLabel();
              });
              jogButtons.forEach(button => {
                  const direction = button.dataset.trimVideoJog;
                  button.addEventListener('click', () => {
                      const duration = getDuration();
                      const delta = direction === 'back' ? -TRIM_VIDEO_JOG_STEP_MS : TRIM_VIDEO_JOG_STEP_MS;
                      const nextValue = clampValue(Math.round(videoElement.currentTime * 1000) + delta, 0, duration || Math.max(session.draftEnd ?? TRIM_VIDEO_JOG_STEP_MS, TRIM_VIDEO_JOG_STEP_MS));
                      videoElement.pause();
                      videoElement.currentTime = nextValue / 1000;
                      updatePlayButtonState();
                      updatePlayheadLabel();
                  });
              });
              resetButton?.addEventListener('click', () => {
                  const duration = getDuration();
                  session.draftStart = 0;
                  session.draftEnd = duration > 0 ? duration : MIN_TRIM_VIDEO_RANGE_MS;
                  session.draftStrict = false;
                  if (strictInput) {
                      strictInput.checked = false;
                  }
                  videoElement.pause();
                  videoElement.currentTime = 0;
                  updatePlayButtonState();
                  refreshUi();
              });
              refreshUi();
              saveButton?.addEventListener('click', () => {
                  if (saveButton.disabled) {
                      return;
                  }
                  const duration = getDuration() || session.durationMs || session.sourcePreview?.durationMs || null;
                  const normalized = normalizeRangeForSettings(session.draftStart, session.draftEnd, duration);
                  persistTrimSettings(session.nodeId, settings => {
                      settings.startMs = normalized.start;
                      settings.endMs = normalized.end;
                      settings.strictCut = Boolean(session.draftStrict);
                  }, 'nodes.trim.toast.videoSaved');
              });
          };
          const renderActiveModal = () => {
              if (!modalBackdrop || !modalContainer) {
                  return;
              }
              if (!activeModal) {
                  modalBackdrop.dataset.open = 'false';
                  modalContainer.setAttribute('aria-hidden', 'true');
                  return;
              }
              modalBackdrop.dataset.open = 'true';
              modalContainer.setAttribute('aria-hidden', 'false');
              if (activeModal.type === 'trim') {
                  renderTrimModalView(activeModal);
              }
              requestAnimationFrame(() => {
                  const focusTarget = modalContainer?.querySelector(MODAL_FOCUSABLE_SELECTORS) ?? modalCloseButton;
                  (focusTarget ?? modalContainer)?.focus();
              });
          };
          const openTrimModal = (mode, nodeId) => {
              ensureModalHost();
              modalLastFocused =
                  document.activeElement instanceof HTMLElement ? document.activeElement : null;
              const targetNode = state.nodes.find(entry => entry.id === nodeId);
              if (!targetNode) {
                  console.warn('[NodeVision] trim modal requested for missing node', nodeId);
                  return;
              }
              const settings = (0, trim_shared_1.ensureTrimSettings)(targetNode);
              if (mode === 'image') {
                  const sourcePreview = findTrimSourcePreview(nodeId);
                  activeModal = {
                      type: 'trim',
                      mode: 'image',
                      nodeId,
                      draftRegion: { ...(settings.region ?? DEFAULT_TRIM_REGION) },
                      sourcePreview: sourcePreview && sourcePreview.kind === 'image' ? sourcePreview : null,
                      draftRotationDeg: settings.rotationDeg ?? 0,
                      draftZoom: settings.zoom ?? 1,
                      draftFlipHorizontal: settings.flipHorizontal ?? false,
                      draftFlipVertical: settings.flipVertical ?? false,
                      draftAspectMode: settings.aspectMode ?? 'free',
                      showGrid: false
                  };
              }
              else {
                  const sourcePreview = findTrimSourcePreview(nodeId);
                  const videoPreview = sourcePreview && sourcePreview.kind === 'video' ? sourcePreview : null;
                  activeModal = {
                      type: 'trim',
                      mode: 'video',
                      nodeId,
                      draftStart: settings.startMs ?? null,
                      draftEnd: settings.endMs ?? null,
                      draftStrict: settings.strictCut ?? false,
                      sourcePreview: videoPreview,
                      durationMs: videoPreview?.durationMs ?? null
                  };
              }
              renderActiveModal();
          };
          let openSidebarPanel = null;
          let workflowNameDialogResolver = null;
          function getWorkflowDisplayName() {
              return state.workflowName || unsavedWorkflowLabel;
          }
          function formatWorkflowTimestamp(value) {
              if (!value)
                  return '';
              const date = new Date(value);
              if (Number.isNaN(date.getTime())) {
                  return value;
              }
              return date.toLocaleString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
          }
          function updateWorkflowNameUi() {
              const label = getWorkflowDisplayName();
              elements.workflowNameLabel.textContent = state.workflowDirty ? label + ' *' : label;
          }
          function syncUnsavedWorkflowLabel() {
              const previousLabel = unsavedWorkflowLabel;
              const translated = t('workflow.unsaved');
              unsavedWorkflowLabel = translated;
              if (!state.activeWorkflowId && (!state.workflowName || state.workflowName === previousLabel)) {
                  state.workflowName = translated;
              }
              updateWorkflowNameUi();
          }
          function markWorkflowDirty() {
              if (!state.workflowDirty) {
                  state.workflowDirty = true;
                  updateWorkflowNameUi();
              }
          }
          function setUnsavedWorkflow(options = {}) {
              state.activeWorkflowId = null;
              state.workflowName = unsavedWorkflowLabel;
              if (typeof options.dirty === 'boolean') {
                  state.workflowDirty = options.dirty;
              }
              updateWorkflowNameUi();
          }
          const sanitizeWorkflowRecords = (records) => {
              if (!Array.isArray(records)) {
                  return [];
              }
              return records
                  .map(item => {
                  if (!item || typeof item !== 'object') {
                      return null;
                  }
                  const record = item;
                  const id = typeof record.id === 'string' ? record.id : null;
                  const name = typeof record.name === 'string' ? record.name : null;
                  const data = typeof record.data === 'string' ? record.data : null;
                  if (!id || !name || !data) {
                      return null;
                  }
                  const updatedAtRaw = typeof record.updatedAt === 'string' ? record.updatedAt : null;
                  const parsed = updatedAtRaw ? new Date(updatedAtRaw) : null;
                  const updatedAt = parsed && !Number.isNaN(parsed.getTime()) ? parsed.toISOString() : new Date().toISOString();
                  return { id, name, data, updatedAt };
              })
                  .filter((workflow) => Boolean(workflow));
          };
          function readStoredWorkflowsFallback() {
              try {
                  if (typeof localStorage === 'undefined') {
                      return [];
                  }
                  const raw = localStorage.getItem(WORKFLOW_STORAGE_KEY);
                  if (!raw) {
                      return [];
                  }
                  const parsed = JSON.parse(raw);
                  return sanitizeWorkflowRecords(parsed);
              }
              catch (error) {
                  console.warn('[NodeVision] Failed to load workflows', error);
                  return [];
              }
          }
          function persistWorkflowsLocal() {
              try {
                  if (typeof localStorage === 'undefined') {
                      return;
                  }
                  localStorage.setItem(WORKFLOW_STORAGE_KEY, JSON.stringify(state.workflows));
              }
              catch (error) {
                  console.warn('[NodeVision] Failed to persist workflows', error);
              }
          }
          function persistWorkflows() {
              if (nodevision?.saveWorkflows) {
                  nodevision
                      .saveWorkflows(state.workflows)
                      .then(result => {
                      if (!result?.ok) {
                          console.warn('[NodeVision] Failed to persist workflows', result?.message ?? 'unknown error');
                      }
                  })
                      .catch(error => console.warn('[NodeVision] Failed to persist workflows', error));
                  return;
              }
              persistWorkflowsLocal();
          }
          function sortWorkflows() {
              state.workflows.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
          }
          function renderWorkflowList() {
              if (!elements.workflowList)
                  return;
              if (elements.workflowSearch) {
                  elements.workflowSearch.value = state.workflowSearch;
              }
              const term = state.workflowSearch.trim().toLowerCase();
              const filtered = state.workflows.filter(workflow => workflow.name.toLowerCase().includes(term));
              elements.workflowList.innerHTML = '';
              if (!filtered.length) {
                  elements.workflowEmpty.style.display = 'block';
                  return;
              }
              elements.workflowEmpty.style.display = 'none';
              filtered.forEach(workflow => {
                  const li = document.createElement('li');
                  const button = document.createElement('button');
                  button.type = 'button';
                  button.dataset.workflowId = workflow.id;
                  button.classList.toggle('active', state.activeWorkflowId === workflow.id);
                  button.innerHTML =
                      '<span class="workflow-item-name">' +
                          escapeHtml(workflow.name) +
                          '</span><br /><span class="workflow-item-meta">' +
                          escapeHtml(formatWorkflowTimestamp(workflow.updatedAt)) +
                          '</span>';
                  li.appendChild(button);
                  elements.workflowList.appendChild(li);
              });
          }
          function hydrateStoredWorkflows() {
              if (nodevision?.loadWorkflows) {
                  nodevision
                      .loadWorkflows()
                      .then(response => {
                      if (!response?.ok) {
                          console.warn('[NodeVision] Failed to load workflows via bridge', response?.message ?? 'unknown error');
                          state.workflows = readStoredWorkflowsFallback();
                      }
                      else {
                          state.workflows = sanitizeWorkflowRecords(response.workflows ?? []);
                      }
                      sortWorkflows();
                      renderWorkflowList();
                  })
                      .catch(error => {
                      console.warn('[NodeVision] Failed to load workflows via bridge', error);
                      state.workflows = readStoredWorkflowsFallback();
                      sortWorkflows();
                      renderWorkflowList();
                  });
                  return;
              }
              state.workflows = readStoredWorkflowsFallback();
              sortWorkflows();
              renderWorkflowList();
          }
          function toggleWorkflowMenu(force) {
              const next = typeof force === 'boolean' ? force : !state.workflowMenuOpen;
              state.workflowMenuOpen = next;
              elements.workflowMenu.dataset.open = next ? 'true' : 'false';
              elements.workflowMenu.setAttribute('aria-hidden', next ? 'false' : 'true');
              elements.workflowToggle.setAttribute('aria-expanded', next ? 'true' : 'false');
          }
          function closeWorkflowMenu() {
              if (state.workflowMenuOpen) {
                  toggleWorkflowMenu(false);
              }
          }
          function closeWorkflowContextMenu() {
              if (!state.workflowContextMenuOpen) {
                  state.workflowContextTargetId = null;
                  return;
              }
              state.workflowContextMenuOpen = false;
              state.workflowContextTargetId = null;
              elements.workflowContextMenu.dataset.open = 'false';
              elements.workflowContextMenu.setAttribute('aria-hidden', 'true');
          }
          function positionWorkflowContextMenu(clientX, clientY) {
              const padding = 12;
              const width = 200;
              const height = 80;
              const left = Math.max(padding, Math.min(window.innerWidth - width, clientX));
              const top = Math.max(padding, Math.min(window.innerHeight - height, clientY));
              elements.workflowContextMenu.style.left = `${left}px`;
              elements.workflowContextMenu.style.top = `${top}px`;
          }
          function openWorkflowContextMenu(workflowId, clientX, clientY) {
              closeWorkflowContextMenu();
              state.workflowContextTargetId = workflowId;
              state.workflowContextMenuOpen = true;
              positionWorkflowContextMenu(clientX, clientY);
              elements.workflowContextMenu.dataset.open = 'true';
              elements.workflowContextMenu.setAttribute('aria-hidden', 'false');
          }
          function openWorkflowBrowserPanel() {
              openSidebarPanel?.('panel-workflows');
          }
          function setWorkflowNameDialogVisibility(open) {
              elements.workflowNameDialog.dataset.open = open ? 'true' : 'false';
              elements.workflowNameDialog.setAttribute('aria-hidden', open ? 'false' : 'true');
              document.body.classList.toggle('modal-open', open);
          }
          const closeWorkflowNameDialog = (result) => {
              if (!workflowNameDialogResolver) {
                  return;
              }
              setWorkflowNameDialogVisibility(false);
              workflowNameDialogResolver(result);
              workflowNameDialogResolver = null;
          };
          const promptWorkflowName = (initial) => {
              if (workflowNameDialogResolver) {
                  workflowNameDialogResolver(null);
              }
              elements.workflowNameInput.value = initial ?? getWorkflowDisplayName();
              elements.workflowNameInput.dataset.invalid = 'false';
              setWorkflowNameDialogVisibility(true);
              setTimeout(() => {
                  elements.workflowNameInput.focus();
                  elements.workflowNameInput.select();
              }, 0);
              return new Promise(resolve => {
                  workflowNameDialogResolver = resolve;
              });
          };
          const submitWorkflowNameDialog = () => {
              const value = elements.workflowNameInput.value.trim();
              if (!value) {
                  elements.workflowNameInput.dataset.invalid = 'true';
                  elements.workflowNameInput.focus();
                  return;
              }
              elements.workflowNameInput.dataset.invalid = 'false';
              closeWorkflowNameDialog(value);
          };
          const cancelWorkflowNameDialog = () => {
              closeWorkflowNameDialog(null);
          };
          const deleteWorkflowById = (workflowId) => {
              if (!workflowId) {
                  return;
              }
              const current = findWorkflowById(workflowId);
              if (!current) {
                  return;
              }
              if (!window.confirm(t('workflow.confirmDelete', { name: current.name }))) {
                  return;
              }
              state.workflows = state.workflows.filter(workflow => workflow.id !== workflowId);
              persistWorkflowsAndRender();
              if (state.activeWorkflowId === workflowId) {
                  setUnsavedWorkflow({ dirty: true });
              }
              closeWorkflowContextMenu();
          };
          function persistWorkflowsAndRender() {
              sortWorkflows();
              persistWorkflows();
              renderWorkflowList();
          }
          function handleWorkflowSave() {
              if (!state.activeWorkflowId) {
                  void handleWorkflowSaveAs();
                  return;
              }
              const existing = findWorkflowById(state.activeWorkflowId);
              if (!existing) {
                  handleWorkflowSaveAs();
                  return;
              }
              const updated = {
                  ...existing,
                  data: getSerializedProjectJson(),
                  updatedAt: new Date().toISOString()
              };
              persistWorkflowRecord(updated);
              state.workflowName = updated.name;
              state.workflowDirty = false;
              updateWorkflowNameUi();
              renderWorkflowList();
              closeWorkflowMenu();
          }
          async function handleWorkflowSaveAs() {
              const name = await promptWorkflowName(state.workflowName);
              if (!name)
                  return;
              const entry = {
                  id: createId('workflow'),
                  name,
                  data: getSerializedProjectJson(),
                  updatedAt: new Date().toISOString()
              };
              persistWorkflowRecord(entry);
              state.activeWorkflowId = entry.id;
              state.workflowName = entry.name;
              state.workflowDirty = false;
              updateWorkflowNameUi();
              renderWorkflowList();
              closeWorkflowMenu();
          }
          async function handleWorkflowRename() {
              const workflow = findWorkflowById(state.activeWorkflowId);
              if (!workflow) {
                  await handleWorkflowSaveAs();
                  return;
              }
              const name = await promptWorkflowName(workflow.name);
              if (!name)
                  return;
              workflow.name = name;
              workflow.updatedAt = new Date().toISOString();
              persistWorkflowRecord(workflow);
              state.workflowName = name;
              state.workflowDirty = false;
              updateWorkflowNameUi();
              renderWorkflowList();
              closeWorkflowMenu();
          }
          function handleWorkflowClear() {
              if (!window.confirm(t('workflow.confirmClear'))) {
                  return;
              }
              const blank = {
                  schemaVersion: SCHEMA,
                  nodes: [],
                  connections: []
              };
              applyProjectJson(JSON.stringify(blank), { markDirty: false });
              setUnsavedWorkflow({ dirty: false });
              closeWorkflowMenu();
          }
          function handleWorkflowFileLoad() {
              const input = document.createElement('input');
              input.type = 'file';
              input.accept = '.json,application/json';
              input.style.position = 'fixed';
              input.style.left = '-1000px';
              const cleanup = () => {
                  input.remove();
              };
              input.addEventListener('change', () => {
                  const file = input.files && input.files[0];
                  if (!file) {
                      cleanup();
                      return;
                  }
                  const reader = new FileReader();
                  reader.addEventListener('error', () => {
                      alert(t('errors.jsonLoadFailed', { reason: reader.error?.message ?? 'unknown' }));
                      cleanup();
                  });
                  reader.addEventListener('load', () => {
                      try {
                          const text = typeof reader.result === 'string' ? reader.result : '';
                          elements.json.value = text;
                          loadFromTextarea();
                      }
                      catch (error) {
                          alert(t('errors.jsonLoadFailed', { reason: getErrorMessage(error) }));
                      }
                      finally {
                          cleanup();
                      }
                  });
                  reader.readAsText(file, 'utf-8');
              }, { once: true });
              document.body.appendChild(input);
              input.click();
          }
          function handleWorkflowMenuAction(action) {
              switch (action) {
                  case 'rename':
                      void handleWorkflowRename();
                      break;
                  case 'fileSave':
                      serializeAndDownload();
                      closeWorkflowMenu();
                      break;
                  case 'fileLoad':
                      closeWorkflowMenu();
                      handleWorkflowFileLoad();
                      break;
                  case 'saveAs':
                      void handleWorkflowSaveAs();
                      break;
                  case 'clear':
                      handleWorkflowClear();
                      break;
                  case 'browse':
                      closeWorkflowMenu();
                      openWorkflowBrowserPanel();
                      break;
                  default:
                      break;
              }
          }
          const formatTimestamp = (milliseconds) => {
              if (typeof milliseconds !== 'number' || Number.isNaN(milliseconds)) {
                  return '';
              }
              const date = new Date(milliseconds);
              return Number.isNaN(date.getTime()) ? '' : date.toLocaleTimeString();
          };
          const formatIsoTime = (value) => {
              if (!value) {
                  return '';
              }
              const date = new Date(value);
              return Number.isNaN(date.getTime()) ? '' : date.toLocaleTimeString();
          };
          const logLevelClass = (level) => {
              if (level === 'error')
                  return 'log-error';
              if (level === 'warn')
                  return 'log-warn';
              return 'log-info';
          };
          const showToast = (message, type = 'info') => {
              elements.toast.textContent = message;
              elements.toast.classList.remove('error');
              if (type === 'error') {
                  elements.toast.classList.add('error');
              }
              elements.toast.classList.add('visible');
              setTimeout(() => elements.toast.classList.remove('visible'), 3000);
          };
          const cleanupMediaPreview = (nodeId) => {
              const preview = state.mediaPreviews.get(nodeId);
              if (preview && preview.ownedUrl !== false && typeof URL?.revokeObjectURL === 'function') {
                  URL.revokeObjectURL(preview.url);
              }
              if (preview) {
                  state.mediaPreviews.delete(nodeId);
              }
          };
          const getMediaPreview = (nodeId) => state.mediaPreviews.get(nodeId);
          const cleanupAllMediaPreviews = () => {
              state.mediaPreviews.forEach(preview => {
                  if (preview.ownedUrl !== false && typeof URL?.revokeObjectURL === 'function') {
                      URL.revokeObjectURL(preview.url);
                  }
              });
              state.mediaPreviews.clear();
          };
          const trimPreviewTasks = new Map();
          const getPreviewWorkbench = () => {
              if (typeof document === 'undefined') {
                  return null;
              }
              let container = document.getElementById('nodevision-trim-previews');
              if (!container) {
                  container = document.createElement('div');
                  container.id = 'nodevision-trim-previews';
                  Object.assign(container.style, {
                      position: 'fixed',
                      left: '-9999px',
                      top: '-9999px',
                      width: '1px',
                      height: '1px',
                      overflow: 'hidden'
                  });
                  document.body.appendChild(container);
              }
              return container;
          };
          const captureImageFrame = (preview) => new Promise(resolve => {
              if (typeof document === 'undefined') {
                  resolve(null);
                  return;
              }
              const img = new Image();
              img.decoding = 'async';
              img.onload = () => {
                  const canvas = document.createElement('canvas');
                  const width = img.naturalWidth || img.width;
                  const height = img.naturalHeight || img.height;
                  canvas.width = width || 1;
                  canvas.height = height || 1;
                  const ctx = canvas.getContext('2d');
                  if (ctx) {
                      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                      resolve(canvas);
                      return;
                  }
                  resolve(null);
              };
              img.onerror = () => resolve(null);
              img.src = preview.url;
          });
          const captureVideoFrame = (preview, startMs) => new Promise(resolve => {
              if (typeof document === 'undefined') {
                  resolve(null);
                  return;
              }
              const workbench = getPreviewWorkbench();
              if (!workbench) {
                  resolve(null);
                  return;
              }
              const video = document.createElement('video');
              video.preload = 'auto';
              video.muted = true;
              video.playsInline = true;
              video.controls = false;
              video.style.width = '1px';
              video.style.height = '1px';
              const cleanup = () => {
                  video.pause();
                  video.removeAttribute('src');
                  try {
                      video.load();
                  }
                  catch {
                      /* noop */
                  }
                  video.remove();
              };
              const drawFrame = () => {
                  const width = video.videoWidth || 0;
                  const height = video.videoHeight || 0;
                  if (!width || !height) {
                      cleanup();
                      resolve(null);
                      return;
                  }
                  const canvas = document.createElement('canvas');
                  canvas.width = width;
                  canvas.height = height;
                  const ctx = canvas.getContext('2d');
                  if (!ctx) {
                      cleanup();
                      resolve(null);
                      return;
                  }
                  ctx.drawImage(video, 0, 0, width, height);
                  cleanup();
                  resolve(canvas);
              };
              const handleSeeked = () => {
                  video.removeEventListener('seeked', handleSeeked);
                  drawFrame();
              };
              video.onloadeddata = () => {
                  if (typeof startMs === 'number' && Number.isFinite(startMs) && startMs > 0) {
                      const seconds = startMs / 1000;
                      video.addEventListener('seeked', handleSeeked);
                      try {
                          video.currentTime = Math.max(0, seconds);
                      }
                      catch {
                          video.removeEventListener('seeked', handleSeeked);
                          drawFrame();
                      }
                      return;
                  }
                  drawFrame();
              };
              video.onerror = () => {
                  cleanup();
                  resolve(null);
              };
              workbench.appendChild(video);
              try {
                  video.src = preview.url;
                  video.load();
              }
              catch {
                  cleanup();
                  resolve(null);
              }
          });
          const captureFrameForPreview = (preview, startMs) => {
              if (preview.kind === 'image') {
                  return captureImageFrame(preview);
              }
              return captureVideoFrame(preview, startMs);
          };
          const clampRegionValue = (value, min = 0, max = 1) => Math.min(max, Math.max(min, value));
          const clampTrimRotation = (value) => {
              if (typeof value !== 'number' || Number.isNaN(value)) {
                  return 0;
              }
              return Math.max(-180, Math.min(180, value));
          };
          const clampTrimZoom = (value) => {
              if (typeof value !== 'number' || Number.isNaN(value)) {
                  return 1;
              }
              return Math.max(0.25, Math.min(4, value));
          };
          const applyTrimTransforms = (sourceCanvas, settings) => {
              const rotationDeg = clampTrimRotation(settings.rotationDeg);
              const zoomValue = clampTrimZoom(settings.zoom);
              const flipX = settings.flipHorizontal ? -1 : 1;
              const flipY = settings.flipVertical ? -1 : 1;
              const canvas = document.createElement('canvas');
              canvas.width = sourceCanvas.width;
              canvas.height = sourceCanvas.height;
              const ctx = canvas.getContext('2d');
              if (!ctx) {
                  return sourceCanvas;
              }
              ctx.save();
              ctx.translate(canvas.width / 2, canvas.height / 2);
              ctx.rotate((rotationDeg * Math.PI) / 180);
              ctx.scale(zoomValue * flipX, zoomValue * flipY);
              ctx.drawImage(sourceCanvas, -sourceCanvas.width / 2, -sourceCanvas.height / 2);
              ctx.restore();
              return canvas;
          };
          const cropCanvasToRegion = (sourceCanvas, region) => {
              const safeRegion = region ?? { x: 0, y: 0, width: 1, height: 1 };
              const normalizedWidth = clampRegionValue(safeRegion.width ?? 1, 0.01, 1);
              const normalizedHeight = clampRegionValue(safeRegion.height ?? 1, 0.01, 1);
              const startX = clampRegionValue(safeRegion.x ?? 0);
              const startY = clampRegionValue(safeRegion.y ?? 0);
              const width = Math.max(1, Math.round(sourceCanvas.width * normalizedWidth));
              const height = Math.max(1, Math.round(sourceCanvas.height * normalizedHeight));
              const offsetX = Math.min(sourceCanvas.width - width, Math.max(0, Math.round(sourceCanvas.width * startX)));
              const offsetY = Math.min(sourceCanvas.height - height, Math.max(0, Math.round(sourceCanvas.height * startY)));
              const canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              if (ctx) {
                  ctx.drawImage(sourceCanvas, offsetX, offsetY, width, height, 0, 0, width, height);
              }
              return canvas;
          };
          const buildTrimSignature = (sourceNodeId, sourcePreview, settings) => {
              const region = settings.region ?? { x: 0, y: 0, width: 1, height: 1 };
              return [
                  sourceNodeId,
                  sourcePreview.url,
                  sourcePreview.width ?? 'auto',
                  sourcePreview.height ?? 'auto',
                  settings.startMs ?? 'null',
                  settings.endMs ?? 'null',
                  region.x ?? 0,
                  region.y ?? 0,
                  region.width ?? 1,
                  region.height ?? 1,
                  clampTrimRotation(settings.rotationDeg),
                  clampTrimZoom(settings.zoom),
                  settings.flipHorizontal ? 'fh' : 'nh',
                  settings.flipVertical ? 'fv' : 'nv',
                  settings.aspectMode ?? 'free'
              ].join('|');
          };
          const findTrimSourcePreview = (nodeId) => {
              const connection = state.connections.find(conn => conn.toNodeId === nodeId && conn.toPortId === 'source');
              if (!connection) {
                  return null;
              }
              return state.mediaPreviews.get(connection.fromNodeId) ?? null;
          };
          const deriveTrimPreview = async (node) => {
              if (node.typeId !== 'trim') {
                  return;
              }
              const sourcePreview = findTrimSourcePreview(node.id);
              if (!sourcePreview) {
                  cleanupMediaPreview(node.id);
                  return;
              }
              const settings = (0, trim_shared_1.ensureTrimSettings)(node);
              const sourceId = state.connections.find(conn => conn.toNodeId === node.id && conn.toPortId === 'source')?.fromNodeId;
              const signature = buildTrimSignature(sourceId ?? node.id, sourcePreview, settings);
              const existing = state.mediaPreviews.get(node.id);
              if (existing?.derivedFrom === signature) {
                  return;
              }
              const frameCanvas = await captureFrameForPreview(sourcePreview, settings.startMs ?? null);
              if (!frameCanvas) {
                  cleanupMediaPreview(node.id);
                  state.mediaPreviews.set(node.id, {
                      ...sourcePreview,
                      ownedUrl: false,
                      derivedFrom: signature
                  });
                  renderNodes();
                  return;
              }
              const transformedCanvas = applyTrimTransforms(frameCanvas, settings);
              const croppedCanvas = cropCanvasToRegion(transformedCanvas, settings.region);
              const dataUrl = croppedCanvas.toDataURL('image/png');
              cleanupMediaPreview(node.id);
              state.mediaPreviews.set(node.id, {
                  ...sourcePreview,
                  url: dataUrl,
                  type: 'image/png',
                  kind: 'image',
                  width: croppedCanvas.width,
                  height: croppedCanvas.height,
                  ownedUrl: true,
                  derivedFrom: signature,
                  name: `${sourcePreview.name} (trim)`
              });
              renderNodes();
          };
          const scheduleTrimPreviewUpdate = (node) => {
              if (node.typeId !== 'trim') {
                  return;
              }
              if (trimPreviewTasks.has(node.id)) {
                  return;
              }
              const task = deriveTrimPreview(node)
                  .catch(error => console.warn('[NodeVision] trim preview update failed', error))
                  .finally(() => trimPreviewTasks.delete(node.id));
              trimPreviewTasks.set(node.id, task);
          };
          const getNodeChromePadding = (nodeId) => {
              const stored = state.nodeChrome.get(nodeId);
              if (typeof stored === 'number' && stored >= MIN_NODE_CHROME) {
                  return Math.min(NODE_MAX_HEIGHT, stored);
              }
              return DEFAULT_NODE_CHROME;
          };
          const getPreviewWidthForNodeWidth = (nodeWidth) => Math.max(MIN_PREVIEW_WIDTH, nodeWidth - HORIZONTAL_PREVIEW_PADDING);
          const getPreviewAspectRatio = (nodeId) => {
              const preview = state.mediaPreviews.get(nodeId);
              if (preview?.width && preview?.height) {
                  const ratio = preview.width / preview.height;
                  if (Number.isFinite(ratio) && ratio > 0) {
                      return ratio;
                  }
              }
              return PREVIEW_FRAME_RATIO;
          };
          const updateNodeMediaPreviewStyles = (node, element) => {
              const mediaBlocks = element.querySelectorAll('.node-media');
              if (!mediaBlocks.length) {
                  return;
              }
              const nodeSize = state.nodeSizes.get(node.id) ?? {
                  width: node.width ?? NODE_MIN_WIDTH,
                  height: node.height ?? NODE_MIN_HEIGHT
              };
              const chrome = getNodeChromePadding(node.id);
              let sourceNodeId = node.id;
              let reservedHeight = 0;
              let previewData = state.mediaPreviews.get(node.id);
              if (node.typeId === 'mediaPreview') {
                  const connection = state.connections.find(conn => conn.toNodeId === node.id && conn.toPortId === 'source');
                  sourceNodeId = connection?.fromNodeId ?? node.id;
                  previewData = sourceNodeId ? state.mediaPreviews.get(sourceNodeId) : undefined;
                  reservedHeight = (0, preview_layout_1.getMediaPreviewReservedHeight)(Boolean(previewData));
              }
              else if (LOAD_NODE_TYPE_IDS.has(node.typeId)) {
                  reservedHeight = (0, preview_layout_1.getLoadNodeReservedHeight)(Boolean(previewData));
              }
              else {
                  previewData = undefined;
              }
              const widthLimit = getPreviewWidthForNodeWidth(nodeSize.width);
              const ratio = getPreviewAspectRatio(sourceNodeId ?? node.id);
              let previewFillPortion = 0.6;
              if (node.typeId === 'mediaPreview') {
                  previewFillPortion = 0.95;
              }
              else if (LOAD_NODE_TYPE_IDS.has(node.typeId)) {
                  previewFillPortion = 0.85;
              }
              const previewBox = (0, preview_size_1.calculatePreviewSize)({
                  nodeWidth: nodeSize.width,
                  nodeHeight: nodeSize.height,
                  chromePadding: chrome,
                  reservedHeight,
                  widthLimit,
                  minHeight: MIN_PREVIEW_HEIGHT,
                  minWidth: MIN_PREVIEW_WIDTH,
                  aspectRatio: ratio,
                  originalWidth: previewData?.width ?? null,
                  originalHeight: previewData?.height ?? null,
                  minimumNodePortion: previewFillPortion
              });
              mediaBlocks.forEach(block => {
                  block.style.setProperty('--preview-width', `${previewBox.width}px`);
                  block.style.setProperty('--preview-height', `${previewBox.height}px`);
              });
          };
          if (typeof ResizeObserver === 'function') {
              nodeResizeObserver = new ResizeObserver(entries => {
                  entries.forEach(entry => {
                      const target = entry.target;
                      const nodeId = target?.dataset?.id;
                      if (!nodeId) {
                          return;
                      }
                      const node = state.nodes.find(item => item.id === nodeId);
                      if (!node) {
                          return;
                      }
                      updateNodeMediaPreviewStyles(node, target);
                  });
                  refreshSelectionOutline();
              });
          }
          const getMinimumHeightForWidth = (nodeId, width) => {
              const chrome = getNodeChromePadding(nodeId);
              const desiredPreviewWidth = getPreviewWidthForNodeWidth(width);
              const previewHeight = Math.max(MIN_PREVIEW_HEIGHT, desiredPreviewWidth / PREVIEW_FRAME_RATIO);
              const desired = previewHeight + chrome;
              return Math.max(NODE_MIN_HEIGHT, desired);
          };
          const pruneMediaPreviews = () => {
              const nodeIds = new Set(state.nodes.map(node => node.id));
              Array.from(state.mediaPreviews.keys()).forEach(nodeId => {
                  if (!nodeIds.has(nodeId)) {
                      cleanupMediaPreview(nodeId);
                  }
              });
          };
          const clampWidth = (value) => Math.min(NODE_MAX_WIDTH, Math.max(NODE_MIN_WIDTH, value));
          const clampHeight = (value) => Math.min(NODE_MAX_HEIGHT, Math.max(NODE_MIN_HEIGHT, value));
          const ensureNodeSize = (node) => {
              const stored = state.nodeSizes.get(node.id);
              const fallbackWidth = node.width ?? NODE_MIN_WIDTH;
              const fallbackHeight = node.height ?? NODE_MIN_HEIGHT;
              const width = clampWidth(stored?.width ?? fallbackWidth);
              const minHeight = getMinimumHeightForWidth(node.id, width);
              const height = Math.max(minHeight, clampHeight(stored?.height ?? fallbackHeight));
              const size = { width, height };
              if (!stored || stored.width !== width || stored.height !== height) {
                  state.nodeSizes.set(node.id, size);
              }
              node.width = width;
              node.height = height;
              return size;
          };
          const pruneNodeSizes = () => {
              const nodeIds = new Set(state.nodes.map(node => node.id));
              Array.from(state.nodeSizes.keys()).forEach(nodeId => {
                  if (!nodeIds.has(nodeId)) {
                      state.nodeSizes.delete(nodeId);
                  }
              });
          };
          const pruneNodeChrome = () => {
              const nodeIds = new Set(state.nodes.map(node => node.id));
              Array.from(state.nodeChrome.keys()).forEach(nodeId => {
                  if (!nodeIds.has(nodeId)) {
                      state.nodeChrome.delete(nodeId);
                  }
              });
          };
          const syncNodeChromePadding = () => {
              let needsRerender = false;
              elements.nodeLayer.querySelectorAll('.node').forEach(el => {
                  const nodeId = el.dataset.id;
                  if (!nodeId) {
                      return;
                  }
                  const previewEl = el.querySelector('.node-media-preview');
                  if (!previewEl) {
                      if (state.nodeChrome.has(nodeId)) {
                          state.nodeChrome.delete(nodeId);
                      }
                      return;
                  }
                  const previewHeight = Math.max(MIN_PREVIEW_HEIGHT, Math.round(previewEl.scrollHeight || previewEl.getBoundingClientRect().height));
                  const chromeCandidate = Math.max(MIN_NODE_CHROME, Math.round(el.scrollHeight - previewHeight));
                  const stored = state.nodeChrome.get(nodeId);
                  if (stored !== chromeCandidate) {
                      state.nodeChrome.set(nodeId, chromeCandidate);
                  }
                  const size = state.nodeSizes.get(nodeId);
                  if (size) {
                      const minHeight = Math.max(NODE_MIN_HEIGHT, previewHeight + chromeCandidate);
                      if (size.height < minHeight) {
                          size.height = minHeight;
                          const node = state.nodes.find(item => item.id === nodeId);
                          if (node) {
                              node.height = minHeight;
                          }
                          needsRerender = true;
                      }
                  }
              });
              return needsRerender;
          };
          const updateMediaPreviewDimensions = (nodeId, width, height, extra) => {
              const preview = state.mediaPreviews.get(nodeId);
              if (!preview) {
                  return;
              }
              state.mediaPreviews.set(nodeId, {
                  ...preview,
                  width,
                  height,
                  ...(extra ?? {})
              });
              renderNodes();
          };
          const renderQueue = () => {
              const renderJobs = (container, jobs, emptyKey) => {
                  if (!jobs?.length) {
                      container.innerHTML = `<p style="margin:4px 0;opacity:0.7;">${t(emptyKey)}</p>`;
                      return;
                  }
                  container.innerHTML = jobs
                      .map(job => `<div class="queue-row"><span>${escapeHtml(job.name ?? job.jobId ?? t('queue.defaultJob'))}</span><span class="queue-badge">${describeStatus(job.status)}</span></div>`)
                      .join('');
              };
              renderJobs(elements.queueRunning, state.queue.active, 'queue.emptyActive');
              renderJobs(elements.queueQueued, state.queue.queued, 'queue.emptyQueued');
              renderQueueHistory();
              renderQueueWarnings();
          };
          const renderQueueHistory = () => {
              const history = (state.queue.history ?? []).slice(0, 20);
              if (!history.length) {
                  elements.queueHistory.innerHTML = `<p style="opacity:0.7;">${t('queue.noHistory')}</p>`;
                  return;
              }
              elements.queueHistory.innerHTML = history
                  .map(entry => {
                  const level = entry.logLevel ?? 'info';
                  const message = entry.message ? escapeHtml(entry.message) : t('queue.noLogs');
                  const finishedAt = entry.finishedAt ?? entry.startedAt ?? null;
                  return `
                <div class="history-row">
                  <div class="history-row-main">
                    <span class="history-job">${escapeHtml(entry.name ?? t('queue.defaultJob'))}</span>
                    <span class="queue-badge">${describeStatus(entry.status)}</span>
                    <span class="log-level-badge ${logLevelClass(level)}">${level.toUpperCase()}</span>
                    <span class="history-time">${formatTimestamp(finishedAt ?? undefined)}</span>
                  </div>
                  <p class="history-message">${message}</p>
                </div>
              `;
              })
                  .join('');
          };
          const renderQueueWarnings = () => {
              const warnings = state.queue.warnings ?? [];
              const limits = state.queue.limits;
              if (!warnings.length) {
                  const timeoutSeconds = Math.round(limits.queueTimeoutMs / 1000);
                  elements.queueWarnings.innerHTML = `
              <div class="queue-warning queue-warning-info">
                <strong>${t('queue.stableTitle')}</strong>
                <span>${t('queue.stableSummary', {
                      queued: state.queue.queued?.length ?? 0,
                      limit: limits.maxQueueLength,
                      timeout: timeoutSeconds || 0
                  })}</span>
              </div>
            `;
                  return;
              }
              elements.queueWarnings.innerHTML = warnings
                  .map(warning => {
                  const levelClass = warning.level === 'error' ? 'queue-warning-error' : warning.level === 'warn' ? 'queue-warning-warn' : 'queue-warning-info';
                  return `
                <div class="queue-warning ${levelClass}">
                  <strong>${warning.type}</strong>
                  <span>${escapeHtml(warning.message)}</span>
                  <span class="history-time">${formatIsoTime(warning.occurredAt)}</span>
                </div>
              `;
              })
                  .join('');
          };
          const renderDiagnostics = () => {
              if (elements.crashConsent) {
                  elements.crashConsent.checked = !!state.diagnostics.collectCrashDumps;
              }
              if (elements.exportStatus) {
                  if (state.diagnostics.lastLogExportPath) {
                      const sha = state.diagnostics.lastExportSha ?? t('diagnostics.unknownSha');
                      elements.exportStatus.textContent = t('diagnostics.lastExport', {
                          path: state.diagnostics.lastLogExportPath,
                          sha
                      });
                  }
                  else {
                      elements.exportStatus.textContent = t('diagnostics.noExport');
                  }
              }
              if (elements.inspectHistory) {
                  const rows = (state.diagnostics.inspectHistory ?? [])
                      .slice(0, 20)
                      .map(item => {
                      const level = item.logLevel ?? 'info';
                      const infoParts = [
                          `HTTP ${item.statusCode}`,
                          item.responseCode ?? null,
                          typeof item.clipCount === 'number' ? t('diagnostics.clipCount', { count: item.clipCount }) : null,
                          item.remoteAddress ?? null
                      ].filter(Boolean);
                      return `
                  <div class="inspect-row">
                    <div class="inspect-row-main">
                      <span class="log-level-badge ${logLevelClass(level)}">${level.toUpperCase()}</span>
                      <span class="history-time">${formatIsoTime(item.timestamp)}</span>
                    </div>
                    <div class="inspect-row-meta">
                      <strong>${escapeHtml(item.tokenLabel ?? t('diagnostics.defaultToken'))}</strong>
                      <span>${infoParts.map(part => escapeHtml(part)).join('  ') || t('diagnostics.noDetails')}</span>
                    </div>
                  </div>
                `;
                  })
                      .join('');
                  elements.inspectHistory.innerHTML = rows || `<p style="opacity:0.7;">${t('diagnostics.historyEmpty')}</p>`;
              }
          };
          const getHighlightedNodeIds = () => {
              const ids = new Set();
              state.connections.forEach(connection => {
                  if (state.highlightedConnections.has(connection.id)) {
                      ids.add(connection.fromNodeId);
                      ids.add(connection.toNodeId);
                  }
              });
              if (state.pressedNodeId) {
                  ids.add(state.pressedNodeId);
              }
              return ids;
          };
          const applyNodeHighlightClasses = () => {
              const highlightedIds = getHighlightedNodeIds();
              elements.nodeLayer.querySelectorAll('.node').forEach(nodeEl => {
                  const nodeId = nodeEl.dataset.id;
                  if (!nodeId)
                      return;
                  nodeEl.classList.toggle('node-highlight', highlightedIds.has(nodeId));
              });
          };
          const renderConnections = () => {
              const activeIds = new Set(state.connections.map(connection => connection.id));
              state.highlightedConnections.forEach(id => {
                  if (!activeIds.has(id)) {
                      state.highlightedConnections.delete(id);
                  }
              });
              if (!state.connections.length) {
                  state.highlightedConnections.clear();
                  elements.connectionsList.innerHTML = '<li class="connections-empty">' + t('connections.empty') + '</li>';
                  renderConnectionPaths();
                  applyNodeHighlightClasses();
                  return;
              }
              elements.connectionsList.innerHTML = state.connections
                  .map(connection => {
                  const fromNode = state.nodes.find(node => node.id === connection.fromNodeId);
                  const toNode = state.nodes.find(node => node.id === connection.toNodeId);
                  const fromNodeTitle = fromNode ? getNodeTitle(fromNode) : connection.fromNodeId;
                  const fromPort = fromNode?.outputs?.find(port => port.id === connection.fromPortId);
                  const fromPortLabel = fromNode && fromPort ? getPortLabel(fromNode.typeId, fromPort) : connection.fromPortId;
                  const fromLabel = fromNodeTitle + '  ' + fromPortLabel;
                  const toNodeTitle = toNode ? getNodeTitle(toNode) : connection.toNodeId;
                  const toPort = toNode?.inputs?.find(port => port.id === connection.toPortId);
                  const toPortLabel = toNode && toPort ? getPortLabel(toNode.typeId, toPort) : connection.toPortId;
                  const toLabel = toNodeTitle + '  ' + toPortLabel;
                  const summary = t('connections.itemLabel', { from: fromLabel, to: toLabel });
                  const isHighlighted = state.highlightedConnections.has(connection.id);
                  const html = [
                      '<li>',
                      '<label class="connection-row">',
                      '<input type="checkbox" data-connection-check="', escapeHtml(connection.id), '" ',
                      isHighlighted ? 'checked aria-checked="true"' : '',
                      ' />',
                      '<span>', escapeHtml(summary), '</span>',
                      '</label>',
                      '</li>'
                  ];
                  return html.join('');
              })
                  .join('');
              applyPressedNodeStyles();
              renderConnectionPaths();
              applyNodeHighlightClasses();
          };
          const setupSidebarPanels = () => {
              const container = document.getElementById('sidebar-panels');
              const sidebarEl = document.querySelector('.sidebar');
              const mainEl = document.querySelector('main');
              if (!container || !sidebarEl || !mainEl) {
                  return;
              }
              const buttons = Array.from(document.querySelectorAll('.sidebar-icon'));
              const panels = new Map();
              buttons.forEach(button => {
                  const panelId = button.dataset.panel;
                  if (!panelId)
                      return;
                  const panelEl = document.getElementById(panelId);
                  if (panelEl) {
                      panels.set(panelId, panelEl);
                  }
              });
              let activePanelId = null;
              const setActivePanel = (panelId) => {
                  panels.forEach((panel, id) => {
                      const isActive = id === panelId;
                      panel.classList.toggle('active', isActive);
                      panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
                  });
                  buttons.forEach(button => {
                      const isActive = button.dataset.panel === panelId;
                      button.classList.toggle('active', isActive);
                      button.setAttribute('aria-expanded', isActive ? 'true' : 'false');
                  });
                  container.setAttribute('data-state', panelId ? 'open' : 'closed');
                  sidebarEl.setAttribute('data-panel-open', panelId ? 'true' : 'false');
                  mainEl.classList.toggle('sidebar-open', Boolean(panelId));
                  activePanelId = panelId;
              };
              openSidebarPanel = setActivePanel;
              buttons.forEach(button => {
                  button.addEventListener('click', () => {
                      const panelId = button.dataset.panel;
                      if (!panelId || !panels.has(panelId)) {
                          return;
                      }
                      setActivePanel(activePanelId === panelId ? null : panelId);
                  });
              });
              document.addEventListener('click', event => {
                  if (!activePanelId)
                      return;
                  const target = event.target;
                  if (!sidebarEl.contains(target)) {
                      setActivePanel(null);
                  }
              });
              document.addEventListener('keydown', event => {
                  if (!activePanelId)
                      return;
                  if (event.key === 'Escape') {
                      setActivePanel(null);
                  }
              });
          };
          const refreshQueue = async () => {
              if (!nodevision?.getQueueSnapshot)
                  return;
              try {
                  const snapshot = await nodevision.getQueueSnapshot();
                  if (snapshot) {
                      const nextQueue = {
                          active: snapshot.active ?? [],
                          queued: snapshot.queued ?? [],
                          history: snapshot.history ?? [],
                          warnings: snapshot.warnings ?? [],
                          limits: snapshot.limits ?? state.queue.limits
                      };
                      state.queue = nextQueue;
                      renderQueue();
                  }
              }
              catch (error) {
                  showToast(t('toast.queueRefreshFailed', { message: getErrorMessage(error) }), 'error');
              }
          };
          const snap = (value) => Math.round(value / SNAP) * SNAP;
          const renderStatus = () => {
              const items = [
                  `<li>FFmpeg: <strong>${BOOTSTRAP.status.ffmpeg.ffmpeg.path}</strong></li>`,
                  `<li>FFprobe: <strong>${BOOTSTRAP.status.ffmpeg.ffprobe.path}</strong></li>`,
                  `<li>tempRoot: ${BOOTSTRAP.status.settings.tempRoot}</li>`,
                  `<li>HTTP Port: ${BOOTSTRAP.status.settings.http.port}</li>`,
                  `<li>Token Label: ${BOOTSTRAP.status.token.label}</li>`
              ];
              elements.statusList.innerHTML = items.join('');
          };
          const renderAbout = () => {
              const metadata = BOOTSTRAP.status?.distribution?.ffmpeg;
              if (!metadata || !elements.aboutDistribution || !elements.aboutLicense) {
                  return;
              }
              const licenseKey = metadata.license ?? 'unknown';
              const licenseLabel = t(`about.licenseValue.${licenseKey}`) ?? t('about.licenseValue.unknown');
              const originKey = metadata.origin === 'bundled' ? 'about.origin.bundled' : 'about.origin.external';
              elements.aboutDistribution.textContent = t(originKey);
              elements.aboutLicense.textContent = licenseLabel;
              if (elements.aboutPath) {
                  elements.aboutPath.textContent = BOOTSTRAP.status.ffmpeg.ffmpeg.path;
              }
              if (elements.aboutVersion) {
                  elements.aboutVersion.textContent =
                      BOOTSTRAP.status.ffmpeg.ffmpeg.version ?? t('about.versionUnknown');
              }
              if (elements.aboutNotice) {
                  const noticeKey = metadata.origin === 'bundled' ? 'about.noticeBundled' : 'about.noticeExternal';
                  elements.aboutNotice.textContent = t(noticeKey, { license: licenseLabel });
              }
              if (elements.aboutLicenseLink && metadata.licenseUrl) {
                  elements.aboutLicenseLink.setAttribute('href', metadata.licenseUrl);
              }
              if (elements.aboutSourceLink && metadata.sourceUrl) {
                  elements.aboutSourceLink.setAttribute('href', metadata.sourceUrl);
              }
          };
          const setAutosaveMessage = (msg) => {
              elements.autosave.textContent = msg;
          };
          const updateAutosaveIdleMessage = () => {
              const seconds = state.isRunning ? 10 : 2;
              const key = state.isRunning ? 'autosave.running' : 'autosave.idle';
              setAutosaveMessage(t(key, { seconds }));
          };
          const scheduleAutosave = () => {
              if (!state.autosaveTimer) {
                  updateAutosaveIdleMessage();
              }
              const delay = state.isRunning ? 10000 : 2000;
              if (state.autosaveTimer) {
                  clearTimeout(state.autosaveTimer);
              }
              state.autosaveTimer = window.setTimeout(() => {
                  state.lastAutosave = new Date();
                  const savedAt = state.lastAutosave?.toLocaleTimeString() ?? '';
                  setAutosaveMessage(t('autosave.saved', { time: savedAt }));
                  state.autosaveTimer = null;
              }, delay);
          };
          const pushHistory = () => {
              state.history.splice(state.historyIndex + 1);
              state.history.push({
                  nodes: (0, state_1.deepClone)(state.nodes),
                  connections: (0, state_1.deepClone)(state.connections)
              });
              if (state.history.length > 100) {
                  state.history.shift();
              }
              state.historyIndex = state.history.length - 1;
              updateUndoRedoState();
          };
          const applySnapshot = (snapshot) => {
              state.nodes = (0, state_1.deepClone)(snapshot.nodes);
              state.connections = (0, state_1.deepClone)(snapshot.connections ?? []);
              state.pendingConnection = null;
              state.draggingConnection = null;
              setDropTarget(null);
              state.selection.clear();
              renderNodes();
              renderConnections();
              updatePendingHint();
              updateSelectionUi();
              updateJsonPreview();
          };
          const updateUndoRedoState = () => {
              elements.undo.disabled = state.historyIndex <= 0;
              elements.redo.disabled = state.historyIndex >= state.history.length - 1;
          };
          const undo = () => {
              if (state.historyIndex <= 0)
                  return;
              state.historyIndex -= 1;
              applySnapshot(state.history[state.historyIndex]);
          };
          const redo = () => {
              if (state.historyIndex >= state.history.length - 1)
                  return;
              state.historyIndex += 1;
              applySnapshot(state.history[state.historyIndex]);
          };
          const applyPressedNodeStyles = () => {
              elements.nodeLayer.querySelectorAll('.node').forEach(nodeEl => {
                  const id = nodeEl.dataset.id ?? '';
                  nodeEl.classList.toggle('node-pressed', !!state.pressedNodeId && state.pressedNodeId === id);
              });
          };
          const setPressedNode = (nodeId) => {
              if (state.pressedNodeId === nodeId)
                  return;
              state.pressedNodeId = nodeId;
              applyPressedNodeStyles();
              renderConnectionPaths();
          };
          const updateSelectionUi = () => {
              elements.nodeLayer.querySelectorAll('.node').forEach(nodeEl => {
                  const id = nodeEl.dataset.id ?? '';
                  nodeEl.classList.toggle('selected', state.selection.has(id));
              });
              document.querySelectorAll('[data-align]').forEach(button => {
                  button.disabled = state.selection.size === 0 || state.readonly;
              });
              refreshSelectionOutline();
              renderConnectionPaths();
          };
          const removeNodeById = (nodeId) => {
              const index = state.nodes.findIndex(node => node.id === nodeId);
              if (index < 0) {
                  return;
              }
              if (state.readonly) {
                  return;
              }
              const targetNode = state.nodes[index];
              const renderer = getNodeRenderer(targetNode.typeId);
              renderer?.onBeforeNodeRemove?.(nodeId);
              if (state.resizing?.nodeId === nodeId) {
                  cancelResize();
              }
              cleanupMediaPreview(nodeId);
              state.nodeSizes.delete(nodeId);
              state.nodeChrome.delete(nodeId);
              state.selection.delete(nodeId);
              if (state.pressedNodeId === nodeId) {
                  setPressedNode(null);
              }
              if (state.pendingConnection && state.pendingConnection.fromNodeId === nodeId) {
                  state.pendingConnection = null;
                  updatePendingHint();
                  refreshPendingPortUi();
              }
              state.connections = state.connections.filter(connection => {
                  if (connection.fromNodeId === nodeId || connection.toNodeId === nodeId) {
                      state.highlightedConnections.delete(connection.id);
                      return false;
                  }
                  return true;
              });
              state.nodes.splice(index, 1);
              commitState();
          };
          const describePort = (node, port, direction) => t('ports.portLabel', {
              direction: t(direction === 'input' ? 'ports.direction.input' : 'ports.direction.output'),
              label: getPortLabel(node.typeId, port),
              dataType: port.dataType
          });
          const portIsConnected = (nodeId, portId, direction) => direction === 'input'
              ? state.connections.some(connection => connection.toNodeId === nodeId && connection.toPortId === portId)
              : state.connections.some(connection => connection.fromNodeId === nodeId && connection.fromPortId === portId);
          const portButtonHtml = (node, port, direction) => {
              const pending = direction === 'output' &&
                  state.pendingConnection &&
                  state.pendingConnection.fromNodeId === node.id &&
                  state.pendingConnection.fromPortId === port.id;
              const connected = portIsConnected(node.id, port.id, direction);
              const classes = ['port', `port-${direction}`];
              if (pending) {
                  classes.push('port-pending');
              }
              if (connected) {
                  classes.push('port-connected');
              }
              const ariaPressed = direction === 'output' ? String(pending) : 'false';
              const portLabel = getPortLabel(node.typeId, port);
              const dot = '<span class="port-dot" aria-hidden="true"></span>';
              const labelHtml = `<span class="port-label">${escapeHtml(portLabel)}</span>`;
              const inner = direction === 'input' ? `${dot}${labelHtml}` : `${labelHtml}${dot}`;
              return `
            <button
              type="button"
              class="${classes.join(' ')}"
              role="button"
              data-node-id="${node.id}"
              data-port-id="${port.id}"
              data-direction="${direction}"
              aria-pressed="${ariaPressed}"
              aria-label="${escapeHtml(describePort(node, port, direction))}"
            >
              ${inner}
            </button>
          `;
          };
          const buildPortGroup = (node, ports, direction) => {
              const displayTitle = getNodeTitle(node);
              const labelKey = direction === 'input' ? 'ports.inputsLabel' : 'ports.outputsLabel';
              const label = escapeHtml(t(labelKey, { title: displayTitle }));
              if (!ports || !ports.length)
                  return '';
              return `
            <div class="ports ${direction}" role="group" aria-label="${label}">
              ${ports.map(port => portButtonHtml(node, port, direction)).join('')}
            </div>
          `;
          };
          const getRelativePoint = (event) => {
              const rect = elements.canvas.getBoundingClientRect();
              return {
                  x: event.clientX - rect.left,
                  y: event.clientY - rect.top
              };
          };
          const getPortAnchorPoint = (portEl) => {
              if (!portEl)
                  return null;
              const dot = portEl.querySelector('.port-dot');
              const target = dot ?? portEl;
              const rect = target.getBoundingClientRect();
              const canvasRect = elements.canvas.getBoundingClientRect();
              return {
                  x: rect.left - canvasRect.left + rect.width / 2,
                  y: rect.top - canvasRect.top + rect.height / 2
              };
          };
          const buildCurvePath = (start, end) => {
              const dx = end.x - start.x;
              const direction = Math.sign(dx || 1);
              const offset = Math.max(Math.abs(dx) * 0.5, 48);
              const c1x = start.x + direction * offset;
              const c2x = end.x - direction * offset;
              return ('M ' +
                  start.x +
                  ' ' +
                  start.y +
                  ' C ' +
                  c1x +
                  ' ' +
                  start.y +
                  ' ' +
                  c2x +
                  ' ' +
                  end.y +
                  ' ' +
                  end.x +
                  ' ' +
                  end.y);
          };
          const findPortElement = (nodeId, portId, direction) => {
              const selector = '.port[data-node-id="' +
                  cssEscape(nodeId) +
                  '"][data-port-id="' +
                  cssEscape(portId) +
                  '"][data-direction="' +
                  direction +
                  '"]';
              return elements.nodeLayer.querySelector(selector);
          };
          const findIncomingConnection = (nodeId, portId) => state.connections.find(connection => connection.toNodeId === nodeId && connection.toPortId === portId);
          const renderConnectionPaths = () => {
              if (!elements.connectionLayer)
                  return;
              const rect = elements.canvas.getBoundingClientRect();
              elements.connectionLayer.setAttribute('viewBox', '0 0 ' + rect.width + ' ' + rect.height);
              elements.connectionLayer.setAttribute('width', String(rect.width));
              elements.connectionLayer.setAttribute('height', String(rect.height));
              const segments = [];
              const pushPath = (start, end, extraClass = '') => {
                  if (!start || !end)
                      return;
                  const pathMarkup = '<path class="connection-path' +
                      extraClass +
                      '" d="' +
                      buildCurvePath(start, end) +
                      '" />';
                  segments.push(pathMarkup);
              };
              state.connections.forEach(connection => {
                  const fromEl = findPortElement(connection.fromNodeId, connection.fromPortId, 'output');
                  const toEl = findPortElement(connection.toNodeId, connection.toPortId, 'input');
                  const touchesPressed = state.pressedNodeId &&
                      (state.pressedNodeId === connection.fromNodeId || state.pressedNodeId === connection.toNodeId);
                  const glow = state.highlightedConnections.has(connection.id) || Boolean(touchesPressed);
                  const extraClass = glow ? ' connection-highlight' : '';
                  pushPath(getPortAnchorPoint(fromEl), getPortAnchorPoint(toEl), extraClass);
              });
              if (state.draggingConnection) {
                  const fromEl = findPortElement(state.draggingConnection.fromNodeId, state.draggingConnection.fromPortId, 'output');
                  const startPoint = getPortAnchorPoint(fromEl);
                  const endPoint = state.draggingConnection.cursor ?? startPoint;
                  pushPath(startPoint, endPoint, ' connection-preview');
              }
              elements.connectionLayer.innerHTML = segments.join('');
          };
          const INTERACTIVE_TAGS = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'LABEL']);
          const isInteractiveTarget = (target) => {
              if (!(target instanceof HTMLElement)) {
                  return false;
              }
              if (INTERACTIVE_TAGS.has(target.tagName)) {
                  return true;
              }
              if (target.closest('[data-node-interactive="true"]')) {
                  return true;
              }
              if (target.hasAttribute('contenteditable')) {
                  return true;
              }
              return false;
          };
          const clampZoom = (value) => Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, value));
          const modulo = (value, modulus) => {
              if (!Number.isFinite(modulus) || modulus === 0) {
                  return 0;
              }
              return ((value % modulus) + modulus) % modulus;
          };
          const updateGridBackdrop = () => {
              const minor = Math.max(1, GRID_MINOR_BASE * state.zoom);
              const major = Math.max(minor * GRID_MAJOR_FACTOR, minor);
              elements.canvasGrid.style.setProperty('--grid-minor-size', `${minor}px`);
              elements.canvasGrid.style.setProperty('--grid-major-size', `${major}px`);
              const offsetX = modulo(state.viewport.x, minor);
              const offsetY = modulo(state.viewport.y, minor);
              elements.canvasGrid.style.setProperty('--grid-offset-x', `${offsetX}px`);
              elements.canvasGrid.style.setProperty('--grid-offset-y', `${offsetY}px`);
          };
          const updateCanvasTransform = () => {
              elements.canvas.style.transform = `translate(${state.viewport.x}px, ${state.viewport.y}px) scale(${state.zoom})`;
              updateGridBackdrop();
              refreshSelectionOutline();
          };
          const updateZoomUi = () => {
              const percent = Math.round(state.zoom * 100);
              elements.zoomDisplay.textContent = percent + '%';
              elements.zoomInput.value = String(percent);
          };
          const openZoomMenu = () => {
              zoomMenuOpen = true;
              elements.zoomMenu.dataset.open = 'true';
              elements.zoomMenu.setAttribute('aria-hidden', 'false');
              elements.zoomDisplay.setAttribute('aria-expanded', 'true');
              elements.zoomInput.focus();
              elements.zoomInput.select();
          };
          const closeZoomMenu = () => {
              if (!zoomMenuOpen) {
                  elements.zoomMenu.dataset.open = 'false';
                  elements.zoomMenu.setAttribute('aria-hidden', 'true');
                  elements.zoomDisplay.setAttribute('aria-expanded', 'false');
                  return;
              }
              zoomMenuOpen = false;
              elements.zoomMenu.dataset.open = 'false';
              elements.zoomMenu.setAttribute('aria-hidden', 'true');
              elements.zoomDisplay.setAttribute('aria-expanded', 'false');
          };
          const toggleZoomMenu = (force) => {
              if (typeof force === 'boolean') {
                  if (force) {
                      openZoomMenu();
                  }
                  else {
                      closeZoomMenu();
                  }
                  return;
              }
              if (zoomMenuOpen) {
                  closeZoomMenu();
              }
              else {
                  openZoomMenu();
              }
          };
          const setActiveTool = (tool) => {
              state.activeTool = tool;
              elements.toolSelect.classList.toggle('active', tool === 'select');
              elements.toolSelect.setAttribute('aria-pressed', tool === 'select' ? 'true' : 'false');
              elements.toolPan.classList.toggle('active', tool === 'pan');
              elements.toolPan.setAttribute('aria-pressed', tool === 'pan' ? 'true' : 'false');
              if (document.body) {
                  document.body.dataset.canvasTool = tool;
              }
          };
          const resetViewport = () => {
              state.viewport.x = 0;
              state.viewport.y = 0;
              updateCanvasTransform();
          };
          const getViewportSize = () => {
              const wrap = elements.canvas.parentElement;
              if (!wrap) {
                  return { width: window.innerWidth || 1, height: window.innerHeight || 1 };
              }
              const rect = wrap.getBoundingClientRect();
              return { width: rect.width || 1, height: rect.height || 1 };
          };
          const getWorldPoint = (event) => {
              const rect = elements.canvas.getBoundingClientRect();
              return {
                  x: (event.clientX - rect.left) / state.zoom,
                  y: (event.clientY - rect.top) / state.zoom
              };
          };
          const getCanvasCenterAnchor = () => {
              const rect = elements.canvas.getBoundingClientRect();
              return { clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2 };
          };
          const getNodeSizeForSelection = (node) => {
              const stored = state.nodeSizes.get(node.id);
              if (stored)
                  return stored;
              return {
                  width: node.width ?? NODE_MIN_WIDTH,
                  height: node.height ?? NODE_MIN_HEIGHT
              };
          };
          const getSelectionPadding = () => SELECTION_PADDING / (state.zoom || 1);
          const refreshSelectionOutline = () => {
              if (!elements.selectionOutline)
                  return;
              if (!state.selection.size) {
                  elements.selectionOutline.style.display = 'none';
                  return;
              }
              const nodeEls = Array.from(elements.nodeLayer.querySelectorAll('.node.selected'));
              if (!nodeEls.length) {
                  elements.selectionOutline.style.display = 'none';
                  return;
              }
              const canvasRect = elements.canvas.getBoundingClientRect();
              const zoom = state.zoom || 1;
              let minX = Number.POSITIVE_INFINITY;
              let minY = Number.POSITIVE_INFINITY;
              let maxX = Number.NEGATIVE_INFINITY;
              let maxY = Number.NEGATIVE_INFINITY;
              nodeEls.forEach(nodeEl => {
                  const rect = nodeEl.getBoundingClientRect();
                  const localMinX = (rect.left - canvasRect.left) / zoom;
                  const localMinY = (rect.top - canvasRect.top) / zoom;
                  const localMaxX = (rect.right - canvasRect.left) / zoom;
                  const localMaxY = (rect.bottom - canvasRect.top) / zoom;
                  minX = Math.min(minX, localMinX);
                  minY = Math.min(minY, localMinY);
                  maxX = Math.max(maxX, localMaxX);
                  maxY = Math.max(maxY, localMaxY);
              });
              if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
                  elements.selectionOutline.style.display = 'none';
                  return;
              }
              const padding = getSelectionPadding();
              elements.selectionOutline.style.display = 'block';
              elements.selectionOutline.style.transform = `translate(${minX - padding}px, ${minY - padding}px)`;
              elements.selectionOutline.style.width = `${Math.max(0, maxX - minX + padding * 2)}px`;
              elements.selectionOutline.style.height = `${Math.max(0, maxY - minY + padding * 2)}px`;
          };
          const drawSelectionRect = (start, end) => {
              const minX = Math.min(start.x, end.x);
              const minY = Math.min(start.y, end.y);
              const maxX = Math.max(start.x, end.x);
              const maxY = Math.max(start.y, end.y);
              elements.selectionRect.style.display = 'block';
              elements.selectionRect.style.transform = `translate(${minX}px, ${minY}px)`;
              elements.selectionRect.style.width = `${Math.max(1, maxX - minX)}px`;
              elements.selectionRect.style.height = `${Math.max(1, maxY - minY)}px`;
              return { minX, minY, maxX, maxY };
          };
          const applyMarqueeSelection = (session, rect) => {
              const nextSelection = session.additive ? new Set(session.baseSelection) : new Set();
              state.selection.clear();
              nextSelection.forEach(id => state.selection.add(id));
              state.nodes.forEach(node => {
                  const size = getNodeSizeForSelection(node);
                  const minX = node.position.x;
                  const minY = node.position.y;
                  const maxX = minX + size.width;
                  const maxY = minY + size.height;
                  const intersects = !(maxX < rect.minX || minX > rect.maxX || maxY < rect.minY || minY > rect.maxY);
                  if (intersects) {
                      state.selection.add(node.id);
                  }
              });
              updateSelectionUi();
          };
          const stopMarqueeTracking = () => {
              window.removeEventListener('pointermove', handleMarqueePointerMove);
              window.removeEventListener('pointerup', completeMarqueeSelection);
              window.removeEventListener('pointercancel', cancelMarqueeSelection);
              elements.selectionRect.style.display = 'none';
          };
          const handleMarqueePointerMove = (event) => {
              if (!marqueeSession) {
                  return;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== marqueeSession.pointerId) {
                  return;
              }
              event.preventDefault();
              const current = getWorldPoint(event);
              marqueeSession.lastRect = drawSelectionRect(marqueeSession.start, current);
              applyMarqueeSelection(marqueeSession, marqueeSession.lastRect);
          };
          const completeMarqueeSelection = (event) => {
              if (!marqueeSession) {
                  return;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== marqueeSession.pointerId) {
                  return;
              }
              event.preventDefault();
              if (!marqueeSession.lastRect) {
                  state.selection.clear();
                  if (marqueeSession.additive) {
                      marqueeSession.baseSelection.forEach(id => state.selection.add(id));
                  }
                  updateSelectionUi();
              }
              stopMarqueeTracking();
              marqueeSession = null;
          };
          const cancelMarqueeSelection = (event) => {
              if (!marqueeSession) {
                  return;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== marqueeSession.pointerId) {
                  return;
              }
              stopMarqueeTracking();
              state.selection.clear();
              marqueeSession.baseSelection.forEach(id => state.selection.add(id));
              updateSelectionUi();
              marqueeSession = null;
          };
          const maybeStartMarquee = (event) => {
              if (state.readonly)
                  return false;
              if (state.activeTool !== 'select')
                  return false;
              if (event.button !== 0)
                  return false;
              const target = event.target;
              if (target && (target.closest('.node') || target.closest('.canvas-controls'))) {
                  return false;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              const worldPoint = getWorldPoint(event);
              marqueeSession = {
                  pointerId,
                  start: worldPoint,
                  additive: event.shiftKey,
                  baseSelection: new Set(state.selection),
                  lastRect: null
              };
              event.preventDefault();
              elements.selectionRect.style.display = 'block';
              elements.selectionRect.style.transform = `translate(${worldPoint.x}px, ${worldPoint.y}px)`;
              elements.selectionRect.style.width = '0px';
              elements.selectionRect.style.height = '0px';
              window.addEventListener('pointermove', handleMarqueePointerMove);
              window.addEventListener('pointerup', completeMarqueeSelection);
              window.addEventListener('pointercancel', cancelMarqueeSelection);
              return true;
          };
          const shouldPanFromEvent = (event) => {
              const wantsPan = (state.activeTool === 'pan' && event.button === 0) || event.button === 1;
              if (!wantsPan) {
                  return false;
              }
              if (isInteractiveTarget(event.target) &&
                  !(state.activeTool === 'pan' && event.button === 0) &&
                  event.button !== 1) {
                  return false;
              }
              if (event.target instanceof HTMLElement && event.target.closest('.canvas-controls')) {
                  return false;
              }
              return true;
          };
          const matchesKey = (event, matcher) => {
              const codes = matcher.codes ?? [];
              const keys = matcher.keys ?? [];
              if (codes.some(code => code === event.code)) {
                  return true;
              }
              if (keys.some(key => key === event.key)) {
                  return true;
              }
              return false;
          };
          const isZoomInShortcut = (event) => event.altKey &&
              !event.metaKey &&
              !event.ctrlKey &&
              matchesKey(event, {
                  codes: ['Equal', 'NumpadAdd', 'Semicolon'],
                  keys: ['=', '+', '']
              });
          const isZoomOutShortcut = (event) => event.altKey &&
              !event.metaKey &&
              !event.ctrlKey &&
              matchesKey(event, {
                  codes: ['Minus', 'NumpadSubtract', 'Backquote'],
                  keys: ['-', '_', '', '', '', '~', '']
              });
          const handlePanPointerMove = (event) => {
              if (!panSession) {
                  return;
              }
              if ((event.pointerId ?? 1) !== panSession.pointerId) {
                  return;
              }
              event.preventDefault();
              const deltaX = event.clientX - panSession.start.x;
              const deltaY = event.clientY - panSession.start.y;
              state.viewport.x = panSession.startViewport.x + deltaX;
              state.viewport.y = panSession.startViewport.y + deltaY;
              updateCanvasTransform();
          };
          let dragSession = null;
          const stopDragSessionListeners = () => {
              window.removeEventListener('pointermove', handleSelectionDragMove);
              window.removeEventListener('pointerup', finishSelectionDrag);
              window.removeEventListener('pointercancel', cancelSelectionDrag);
          };
          const beginSelectionDrag = (event, anchorNode, anchorEl) => {
              if (state.readonly)
                  return false;
              if (event.button !== 0)
                  return false;
              if (state.activeTool === 'pan')
                  return false;
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              const selectedIds = state.selection.size
                  ? Array.from(state.selection)
                  : anchorNode
                      ? [anchorNode.id]
                      : [];
              if (!selectedIds.length) {
                  return false;
              }
              const dragTargets = state.nodes.filter(node => selectedIds.includes(node.id));
              if (anchorNode && !dragTargets.some(node => node.id === anchorNode.id)) {
                  dragTargets.push(anchorNode);
              }
              if (!dragTargets.length) {
                  return false;
              }
              const startPositions = new Map();
              dragTargets.forEach(target => {
                  startPositions.set(target.id, { x: target.position.x, y: target.position.y });
              });
              const nodeElementCache = new Map();
              if (anchorNode && anchorEl) {
                  nodeElementCache.set(anchorNode.id, anchorEl);
              }
              let minX = Number.POSITIVE_INFINITY;
              let minY = Number.POSITIVE_INFINITY;
              let maxX = Number.NEGATIVE_INFINITY;
              let maxY = Number.NEGATIVE_INFINITY;
              dragTargets.forEach(target => {
                  const size = getNodeSizeForSelection(target);
                  minX = Math.min(minX, target.position.x);
                  minY = Math.min(minY, target.position.y);
                  maxX = Math.max(maxX, target.position.x + size.width);
                  maxY = Math.max(maxY, target.position.y + size.height);
              });
              const startBounds = Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY)
                  ? { minX, minY, maxX, maxY }
                  : null;
              dragSession = {
                  pointerId,
                  start: getWorldPoint(event),
                  targets: dragTargets,
                  startPositions,
                  nodeElementCache,
                  dragging: false,
                  moved: false,
                  anchorNodeId: anchorNode?.id ?? null,
                  startBounds
              };
              event.preventDefault();
              stopDragSessionListeners();
              window.addEventListener('pointermove', handleSelectionDragMove);
              window.addEventListener('pointerup', finishSelectionDrag);
              window.addEventListener('pointercancel', cancelSelectionDrag);
              if (document.body && !document.body.classList.contains('node-dragging')) {
                  document.body.classList.add('node-dragging');
              }
              refreshSelectionOutline();
              return true;
          };
          const handleSelectionDragMove = (event) => {
              if (!dragSession) {
                  return;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== dragSession.pointerId) {
                  return;
              }
              event.preventDefault();
              const current = getWorldPoint(event);
              const deltaX = current.x - dragSession.start.x;
              const deltaY = current.y - dragSession.start.y;
              if (!dragSession.dragging) {
                  const distance = Math.hypot(deltaX, deltaY);
                  if (distance < DRAG_THRESHOLD) {
                      return;
                  }
                  dragSession.dragging = true;
              }
              let anyChanged = false;
              dragSession.targets.forEach(target => {
                  const startPos = dragSession.startPositions.get(target.id);
                  if (!startPos) {
                      return;
                  }
                  const nextX = snap(startPos.x + deltaX);
                  const nextY = snap(startPos.y + deltaY);
                  if (nextX === target.position.x && nextY === target.position.y) {
                      return;
                  }
                  target.position.x = nextX;
                  target.position.y = nextY;
                  anyChanged = true;
                  let targetEl = dragSession.nodeElementCache.get(target.id);
                  if (!targetEl) {
                      const found = elements.nodeLayer.querySelector(`.node[data-id="${cssEscape(target.id)}"]`);
                      if (found) {
                          dragSession.nodeElementCache.set(target.id, found);
                          targetEl = found;
                      }
                  }
                  if (targetEl) {
                      targetEl.style.transform = `translate(${nextX}px, ${nextY}px)`;
                  }
              });
              if (anyChanged) {
                  dragSession.moved = true;
                  refreshSelectionOutline();
                  renderConnectionPaths();
              }
              else {
                  refreshSelectionOutline();
              }
          };
          const finishSelectionDrag = (event) => {
              if (!dragSession) {
                  return;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== dragSession.pointerId) {
                  return;
              }
              event.preventDefault();
              stopDragSessionListeners();
              if (dragSession.anchorNodeId) {
                  setPressedNode(null);
              }
              if (dragSession.dragging && dragSession.moved) {
                  suppressChromeMeasurement = true;
                  commitState();
              }
              document.body?.classList.remove('node-dragging');
              dragSession = null;
          };
          const cancelSelectionDrag = (event) => {
              if (!dragSession) {
                  return;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== dragSession.pointerId) {
                  return;
              }
              stopDragSessionListeners();
              if (dragSession.anchorNodeId) {
                  setPressedNode(null);
              }
              document.body?.classList.remove('node-dragging');
              dragSession = null;
          };
          const endPanSession = (event) => {
              if (!panSession) {
                  return;
              }
              if ((event.pointerId ?? 1) !== panSession.pointerId) {
                  return;
              }
              window.removeEventListener('pointermove', handlePanPointerMove);
              window.removeEventListener('pointerup', endPanSession);
              window.removeEventListener('pointercancel', endPanSession);
              if (document.body) {
                  document.body.classList.remove('is-panning');
              }
              panSession = null;
          };
          const startPanSession = (event) => {
              if (panSession || !shouldPanFromEvent(event)) {
                  return false;
              }
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              panSession = {
                  pointerId,
                  start: { x: event.clientX, y: event.clientY },
                  startViewport: { x: state.viewport.x, y: state.viewport.y }
              };
              event.preventDefault();
              if (document.body) {
                  document.body.classList.add('is-panning');
              }
              window.addEventListener('pointermove', handlePanPointerMove);
              window.addEventListener('pointerup', endPanSession);
              window.addEventListener('pointercancel', endPanSession);
              return true;
          };
          updateCanvasTransform();
          updateZoomUi();
          closeZoomMenu();
          setActiveTool(state.activeTool);
          const buildResizeHandles = (nodeId) => ['nw', 'ne', 'sw', 'se']
              .map(handle => `<div class="node-resize-handle node-resize-${handle}" data-resize-handle="${handle}" data-node-id="${escapeHtml(nodeId)}" data-node-interactive="true" aria-hidden="true"></div>`)
              .join('');
          const startResize = (node, handle, element, event) => {
              if (state.readonly)
                  return;
              event.preventDefault();
              event.stopPropagation();
              const size = ensureNodeSize(node);
              state.resizing = {
                  nodeId: node.id,
                  handle,
                  startPointer: { x: event.clientX, y: event.clientY },
                  startSize: size,
                  startPosition: { x: node.position.x, y: node.position.y },
                  element
              };
              window.addEventListener('pointermove', handleResizePointerMove);
              window.addEventListener('pointerup', finishResize);
              window.addEventListener('pointercancel', cancelResize);
          };
          const handleResizePointerMove = (event) => {
              const session = state.resizing;
              if (!session) {
                  return;
              }
              event.preventDefault();
              const node = state.nodes.find(item => item.id === session.nodeId);
              if (!node) {
                  return;
              }
              const deltaX = (event.clientX - session.startPointer.x) / state.zoom;
              const deltaY = (event.clientY - session.startPointer.y) / state.zoom;
              let width = session.startSize.width;
              let height = session.startSize.height;
              let posX = session.startPosition.x;
              let posY = session.startPosition.y;
              if (session.handle.includes('e')) {
                  width = clampWidth(session.startSize.width + deltaX);
              }
              if (session.handle.includes('w')) {
                  const candidate = session.startSize.width - deltaX;
                  const clamped = clampWidth(candidate);
                  const applied = session.startSize.width - clamped;
                  width = clamped;
                  posX = snap(session.startPosition.x + applied);
              }
              const minHeightForWidth = getMinimumHeightForWidth(node.id, width);
              if (session.handle.includes('s')) {
                  height = clampHeight(session.startSize.height + deltaY);
              }
              if (session.handle.includes('n')) {
                  const candidate = session.startSize.height - deltaY;
                  const clamped = clampHeight(candidate);
                  const applied = session.startSize.height - clamped;
                  height = clamped;
                  posY = snap(session.startPosition.y + applied);
              }
              height = Math.max(minHeightForWidth, height);
              node.position.x = posX;
              node.position.y = posY;
              const enforcedHeight = Math.max(minHeightForWidth, height);
              if (session.handle.includes('n') && enforcedHeight !== height) {
                  posY = snap(session.startPosition.y + (session.startSize.height - enforcedHeight));
              }
              node.width = width;
              node.height = enforcedHeight;
              const storedSize = state.nodeSizes.get(node.id);
              if (!storedSize || storedSize.width !== width || storedSize.height !== enforcedHeight) {
                  state.nodeSizes.set(node.id, { width, height: enforcedHeight });
              }
              session.element.style.width = `${width}px`;
              session.element.style.height = `${enforcedHeight}px`;
              session.element.style.transform = `translate(${node.position.x}px, ${node.position.y}px)`;
              updateNodeMediaPreviewStyles(node, session.element);
              renderConnectionPaths();
          };
          const endResizeSession = (commit) => {
              if (!state.resizing) {
                  return;
              }
              window.removeEventListener('pointermove', handleResizePointerMove);
              window.removeEventListener('pointerup', finishResize);
              window.removeEventListener('pointercancel', cancelResize);
              state.resizing = null;
              if (commit) {
                  commitState({ skipRender: true });
              }
          };
          const finishResize = () => endResizeSession(true);
          const cancelResize = () => endResizeSession(false);
          let suppressChromeMeasurement = false;
          const renderNodes = (attempt = 0) => {
              const host = elements.nodeLayer;
              pruneMediaPreviews();
              pruneNodeSizes();
              pruneNodeChrome();
              setDropTarget(null);
              if (nodeResizeObserver) {
                  nodeResizeObserver.disconnect();
              }
              host.innerHTML = '';
              state.nodes.forEach(node => {
                  const localizedTitle = getNodeTitle(node);
                  const template = templates.find(item => item.typeId === node.typeId);
                  const description = template ? getTemplateDescription(template) : '';
                  const nodeVersion = node.nodeVersion ?? '1.0.0';
                  const metaText = node.typeId + '  v' + nodeVersion;
                  const el = document.createElement('div');
                  el.className = 'node';
                  el.dataset.id = node.id;
                  el.dataset.typeId = node.typeId;
                  el.setAttribute('data-type-id', node.typeId);
                  el.classList.add(toNodeTypeClass(node.typeId));
                  el.tabIndex = 0;
                  el.setAttribute('role', 'group');
                  el.setAttribute('aria-label', t('nodes.ariaLabel', { title: localizedTitle }));
                  el.style.transform = 'translate(' + node.position.x + 'px, ' + node.position.y + 'px)';
                  const inputsGroup = buildPortGroup(node, node.inputs, 'input');
                  const outputsGroup = buildPortGroup(node, node.outputs, 'output');
                  const descriptionHtml = description
                      ? '<p class="node-description">' + escapeHtml(description) + '</p>'
                      : '';
                  const nodeSize = ensureNodeSize(node);
                  const nodeWidth = nodeSize.width;
                  const nodeHeight = nodeSize.height;
                  const deleteButton = `<button type="button" class="node-delete-btn${state.readonly ? ' disabled' : ''}" data-remove-node="${escapeHtml(node.id)}" data-node-interactive="true" aria-label="${escapeHtml(t('nodes.delete'))}" ${state.readonly ? 'disabled' : ''}></button>`;
                  const renderer = getNodeRenderer(node.typeId);
                  const extension = renderer?.render(node) ?? null;
                  const htmlParts = [
                      '<header class="node-header">',
                      deleteButton,
                      '<div class="node-header-main">',
                      '<p class="node-title">', escapeHtml(localizedTitle), '</p>',
                      '<p class="node-meta">', escapeHtml(metaText), '</p>',
                      descriptionHtml,
                      '</div>',
                      '<span class="node-chip">v', escapeHtml(nodeVersion), '</span>',
                      '</header>',
                      '<div class="node-ports">',
                      inputsGroup,
                      outputsGroup,
                      '</div>'
                  ];
                  if (extension?.afterPortsHtml) {
                      htmlParts.push(extension.afterPortsHtml);
                  }
                  htmlParts.push(buildResizeHandles(node.id));
                  el.innerHTML = htmlParts.join('');
                  el.style.width = `${nodeWidth}px`;
                  el.style.height = `${nodeHeight}px`;
                  el.style.minWidth = `${NODE_MIN_WIDTH}px`;
                  el.style.maxWidth = `${NODE_MAX_WIDTH}px`;
                  el.style.minHeight = `${NODE_MIN_HEIGHT}px`;
                  el.style.maxHeight = `${NODE_MAX_HEIGHT}px`;
                  if (state.selection.has(node.id)) {
                      el.classList.add('selected');
                  }
                  attachNodeEvents(el, node);
                  attachPortEvents(el);
                  const deleteButtonEl = el.querySelector('[data-remove-node]');
                  deleteButtonEl?.addEventListener('click', event => {
                      event.stopPropagation();
                      event.preventDefault();
                      removeNodeById(node.id);
                  });
                  el.querySelectorAll('[data-resize-handle]').forEach(handle => {
                      handle.addEventListener('pointerdown', event => {
                          const direction = handle.getAttribute('data-resize-handle') ?? 'se';
                          startResize(node, direction, el, event);
                      });
                  });
                  host.appendChild(el);
                  extension?.afterRender?.(el);
                  if (nodeResizeObserver && el.querySelector('.node-media')) {
                      nodeResizeObserver.observe(el);
                  }
                  if (node.typeId === 'trim') {
                      scheduleTrimPreviewUpdate(node);
                  }
              });
              const needsSync = !suppressChromeMeasurement && syncNodeChromePadding();
              suppressChromeMeasurement = false;
              if (needsSync && attempt < MAX_CHROME_SYNC_ATTEMPTS) {
                  renderNodes(attempt + 1);
                  return;
              }
              renderConnectionPaths();
              applyNodeHighlightClasses();
              refreshPendingPortUi();
          };
          const initializeNodeRenderers = () => {
              nodeRendererByType.clear();
              const modules = (0, nodes_1.createNodeRenderers)({
                  state,
                  t,
                  escapeHtml,
                  showToast,
                  renderNodes,
                  cleanupMediaPreview,
                  updateMediaPreviewDimensions,
                  getNodeChromePadding,
                  getPreviewWidthForNodeWidth,
                  getPreviewAspectRatio,
                  minPreviewHeight: MIN_PREVIEW_HEIGHT,
                  minPreviewWidth: MIN_PREVIEW_WIDTH,
                  getTemplateByType,
                  getMediaPreview,
                  openTrimModal
              });
              modules.forEach(module => {
                  module.typeIds.forEach(typeId => {
                      nodeRendererByType.set(typeId, module);
                  });
              });
          };
          const attachNodeEvents = (el, node) => {
              const onPointerDown = (event) => {
                  if (startPanSession(event)) {
                      return;
                  }
                  if (state.readonly)
                      return;
                  if (event.button !== 0)
                      return;
                  if (isInteractiveTarget(event.target)) {
                      return;
                  }
                  const additive = event.shiftKey;
                  if (additive) {
                      if (state.selection.has(node.id)) {
                          state.selection.delete(node.id);
                      }
                      else {
                          state.selection.add(node.id);
                      }
                  }
                  else {
                      if (!state.selection.has(node.id)) {
                          state.selection.clear();
                          state.selection.add(node.id);
                      }
                  }
                  updateSelectionUi();
                  setPressedNode(node.id);
                  beginSelectionDrag(event, node, el);
              };
              el.addEventListener('pointerdown', onPointerDown);
              el.addEventListener('click', event => {
                  if (state.activeTool === 'pan') {
                      event.preventDefault();
                      return;
                  }
                  if (state.readonly)
                      return;
                  if (isInteractiveTarget(event.target)) {
                      return;
                  }
                  if (!state.selection.has(node.id)) {
                      state.selection.clear();
                      state.selection.add(node.id);
                      updateSelectionUi();
                  }
              });
              el.addEventListener('keydown', (event) => {
                  if (event.key === 'Enter') {
                      event.preventDefault();
                      el.click();
                  }
              });
          };
          const attachPortEvents = (container) => {
              container.querySelectorAll('.port').forEach(portEl => {
                  portEl.addEventListener('click', (event) => {
                      if (state.activeTool === 'pan') {
                          event.preventDefault();
                          return;
                      }
                      event.preventDefault();
                      event.stopPropagation();
                      handlePortActivation(portEl);
                  });
                  portEl.addEventListener('pointerdown', (event) => {
                      if (startPanSession(event)) {
                          return;
                      }
                      if (state.readonly)
                          return;
                      const direction = portEl.getAttribute('data-direction');
                      if (direction === 'input') {
                          const nodeId = portEl.getAttribute('data-node-id');
                          const portId = portEl.getAttribute('data-port-id');
                          if (nodeId && portId) {
                              const existing = findIncomingConnection(nodeId, portId);
                              if (existing) {
                                  startRewireFromInput(existing, event);
                                  return;
                              }
                          }
                      }
                      startConnectionDrag(portEl, event);
                  });
                  portEl.addEventListener('pointerenter', () => {
                      if (state.draggingConnection && portEl.getAttribute('data-direction') === 'input') {
                          setDropTarget(portEl);
                      }
                  });
                  portEl.addEventListener('pointerleave', () => {
                      if (dropTargetPort === portEl) {
                          setDropTarget(null);
                      }
                  });
                  portEl.addEventListener('keydown', (event) => {
                      if (state.activeTool === 'pan') {
                          return;
                      }
                      if (event.key === 'Enter' || event.key === ' ') {
                          event.preventDefault();
                          handlePortActivation(portEl);
                      }
                      else if (event.key === 'Escape' && state.pendingConnection) {
                          event.preventDefault();
                          clearPendingConnection();
                      }
                  });
              });
          };
          const updatePendingHint = () => {
              if (!state.pendingConnection) {
                  elements.connectionHint.textContent = t('connections.ready');
                  return;
              }
              const pending = state.pendingConnection;
              const fromNode = state.nodes.find(node => node.id === pending.fromNodeId);
              const fromLabel = fromNode ? getNodeTitle(fromNode) : pending.fromNodeId;
              elements.connectionHint.textContent = t('connections.pending', {
                  from: fromLabel
              });
          };
          const refreshPendingPortUi = () => {
              (0, ports_1.syncPendingPortHighlight)(elements.nodeLayer, state.pendingConnection);
          };
          const setDropTarget = (target) => {
              if (dropTargetPort === target) {
                  return;
              }
              if (dropTargetPort) {
                  dropTargetPort.classList.remove('port-drop-target');
              }
              dropTargetPort = target ?? null;
              if (dropTargetPort) {
                  dropTargetPort.classList.add('port-drop-target');
              }
          };
          const primePendingConnection = (nodeId, portId) => {
              if (state.pendingConnection &&
                  state.pendingConnection.fromNodeId === nodeId &&
                  state.pendingConnection.fromPortId === portId) {
                  return;
              }
              state.pendingConnection = { fromNodeId: nodeId, fromPortId: portId };
              updatePendingHint();
              refreshPendingPortUi();
          };
          const handleConnectionDragMove = (event) => {
              if (!activeConnectionDrag)
                  return;
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== activeConnectionDrag.pointerId) {
                  return;
              }
              if (!activeConnectionDrag.started) {
                  const distance = Math.hypot(event.clientX - activeConnectionDrag.origin.x, event.clientY - activeConnectionDrag.origin.y);
                  if (distance > 3) {
                      const nodeId = activeConnectionDrag.portEl.getAttribute('data-node-id');
                      const portId = activeConnectionDrag.portEl.getAttribute('data-port-id');
                      if (nodeId && portId) {
                          primePendingConnection(nodeId, portId);
                          activeConnectionDrag.started = true;
                          state.draggingConnection = {
                              fromNodeId: nodeId,
                              fromPortId: portId,
                              cursor: getRelativePoint(event)
                          };
                          renderConnectionPaths();
                      }
                  }
                  return;
              }
              if (state.draggingConnection) {
                  state.draggingConnection.cursor = getRelativePoint(event);
                  renderConnectionPaths();
              }
          };
          const handleConnectionDragUp = (event) => {
              if (!activeConnectionDrag)
                  return;
              const pointerId = typeof event.pointerId === 'number' ? event.pointerId : 1;
              if (pointerId !== activeConnectionDrag.pointerId) {
                  return;
              }
              if (activeConnectionDrag.started && dropTargetPort) {
                  handlePortActivation(dropTargetPort);
              }
              else if (activeConnectionDrag.started) {
                  const shouldDetach = Boolean(state.pendingConnection?.detachedConnectionId);
                  clearPendingConnection(shouldDetach ? { detachExisting: true } : undefined);
              }
              endConnectionDrag();
          };
          const endConnectionDrag = () => {
              if (activeConnectionDrag) {
                  window.removeEventListener('pointermove', handleConnectionDragMove);
                  window.removeEventListener('pointerup', handleConnectionDragUp);
                  activeConnectionDrag = null;
              }
              state.draggingConnection = null;
              setDropTarget(null);
              renderConnectionPaths();
          };
          const startConnectionDrag = (portEl, event, options) => {
              if (state.readonly)
                  return;
              if (portEl.getAttribute('data-direction') !== 'output')
                  return;
              if (typeof event.button === 'number' && event.button !== 0) {
                  return;
              }
              event.preventDefault();
              event.stopPropagation();
              activeConnectionDrag = {
                  portEl,
                  pointerId: typeof event.pointerId === 'number' ? event.pointerId : 1,
                  origin: { x: event.clientX, y: event.clientY },
                  started: !!options?.forceStart
              };
              if (activeConnectionDrag.started) {
                  const nodeId = portEl.getAttribute('data-node-id');
                  const portId = portEl.getAttribute('data-port-id');
                  if (nodeId && portId) {
                      state.draggingConnection = {
                          fromNodeId: nodeId,
                          fromPortId: portId,
                          cursor: options?.cursorOverride ?? getRelativePoint(event)
                      };
                      renderConnectionPaths();
                  }
              }
              window.addEventListener('pointermove', handleConnectionDragMove);
              window.addEventListener('pointerup', handleConnectionDragUp);
          };
          const startRewireFromInput = (connection, event) => {
              if (typeof event.button === 'number' && event.button !== 0) {
                  return;
              }
              event.preventDefault();
              event.stopPropagation();
              const fromEl = findPortElement(connection.fromNodeId, connection.fromPortId, 'output');
              if (!fromEl) {
                  state.connections = [connection, ...state.connections];
                  renderConnections();
                  return;
              }
              state.connections = state.connections.filter(conn => conn.id !== connection.id);
              renderConnections();
              const cursorPoint = getRelativePoint(event);
              state.pendingConnection = {
                  fromNodeId: connection.fromNodeId,
                  fromPortId: connection.fromPortId,
                  detachedConnectionId: connection.id
              };
              updatePendingHint();
              renderNodes();
              state.draggingConnection = {
                  fromNodeId: connection.fromNodeId,
                  fromPortId: connection.fromPortId,
                  cursor: cursorPoint
              };
              startConnectionDrag(fromEl, event, { forceStart: true, cursorOverride: cursorPoint });
          };
          const clearPendingConnection = (options) => {
              if (!state.pendingConnection)
                  return;
              const pending = state.pendingConnection;
              const detach = options?.detachExisting ?? false;
              let removed = false;
              if (detach) {
                  let nextConnections;
                  if (pending.detachedConnectionId) {
                      nextConnections = state.connections.filter(connection => connection.id !== pending.detachedConnectionId);
                  }
                  else {
                      nextConnections = state.connections.filter(connection => !(connection.fromNodeId === pending.fromNodeId && connection.fromPortId === pending.fromPortId));
                  }
                  removed = nextConnections.length !== state.connections.length;
                  state.connections = nextConnections;
                  if (!removed && pending.detachedConnectionId) {
                      removed = true;
                  }
              }
              state.pendingConnection = null;
              updatePendingHint();
              endConnectionDrag();
              refreshPendingPortUi();
              if (removed) {
                  commitState();
              }
          };
          const handlePortActivation = (portEl) => {
              const nodeId = portEl.getAttribute('data-node-id');
              const portId = portEl.getAttribute('data-port-id');
              const direction = portEl.getAttribute('data-direction');
              if (!nodeId || !portId || !direction)
                  return;
              if (state.readonly)
                  return;
              if (direction === 'output') {
                  if (state.pendingConnection && state.pendingConnection.fromNodeId === nodeId && state.pendingConnection.fromPortId === portId) {
                      clearPendingConnection();
                      return;
                  }
                  primePendingConnection(nodeId, portId);
                  return;
              }
              if (!state.pendingConnection) {
                  return;
              }
              const pending = state.pendingConnection;
              if (pending.fromNodeId === nodeId && pending.fromPortId === portId) {
                  return;
              }
              const exists = state.connections.some(connection => connection.fromNodeId === pending.fromNodeId &&
                  connection.fromPortId === pending.fromPortId &&
                  connection.toNodeId === nodeId &&
                  connection.toPortId === portId);
              if (exists) {
                  state.pendingConnection = null;
                  updatePendingHint();
                  endConnectionDrag();
                  refreshPendingPortUi();
                  return;
              }
              const connection = {
                  id: createId('connection'),
                  fromNodeId: pending.fromNodeId,
                  fromPortId: pending.fromPortId,
                  toNodeId: nodeId,
                  toPortId: portId
              };
              state.connections = [connection, ...state.connections];
              state.pendingConnection = null;
              updatePendingHint();
              endConnectionDrag();
              commitState();
          };
          const commitState = (options = {}) => {
              if (!options.skipRender) {
                  renderNodes();
                  renderConnections();
              }
              else {
                  renderConnectionPaths();
                  applyNodeHighlightClasses();
              }
              updateSelectionUi();
              updateJsonPreview();
              pushHistory();
              scheduleAutosave();
              if (!options.skipDirtyFlag) {
                  markWorkflowDirty();
              }
          };
          const serializeProject = () => ({
              schemaVersion: SCHEMA,
              nodes: state.nodes.map(node => ({
                  id: node.id,
                  typeId: node.typeId,
                  nodeVersion: node.nodeVersion,
                  title: node.title,
                  position: node.position,
                  settings: cloneNodeSettings(node.settings)
              })),
              connections: state.connections.map(connection => (0, state_1.deepClone)(connection)),
              metadata: {
                  name: 'NodeVision Demo',
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString(),
                  readonly: state.readonly
              }
          });
          const updateJsonPreview = () => {
              elements.json.value = JSON.stringify(serializeProject(), null, 2);
          };
          const addNodeFromTemplate = (template) => {
              const position = { x: snap(120 + Math.random() * 320), y: snap(80 + Math.random() * 220) };
              const templateTokens = template.searchTokens ?? [];
              const node = {
                  id: createId(template.typeId),
                  typeId: template.typeId,
                  nodeVersion: template.nodeVersion,
                  title: template.title,
                  position,
                  width: template.width ?? 220,
                  height: template.height ?? 120,
                  searchTokens: templateTokens,
                  inputs: (0, state_1.clonePorts)(template.inputs),
                  outputs: (0, state_1.clonePorts)(template.outputs),
                  settings: template.defaultSettings ? (0, state_1.deepClone)(template.defaultSettings) : undefined
              };
              state.nodes.push(node);
              state.selection = new Set([node.id]);
              commitState();
          };
          const updateSuggestions = (query) => {
              const normalized = query.trim().toLowerCase();
              const results = templates
                  .filter(template => {
                  if (!normalized)
                      return true;
                  const localizedTitle = getTemplateTitle(template).toLowerCase();
                  const localizedDescription = getTemplateDescription(template).toLowerCase();
                  const haystacks = [
                      template.title.toLowerCase(),
                      (template.description ?? '').toLowerCase(),
                      localizedTitle,
                      localizedDescription,
                      ...(template.keywords ?? []).map((keyword) => keyword.toLowerCase())
                  ];
                  return haystacks.some(text => text && text.includes(normalized));
              })
                  .slice(0, 6);
              elements.suggestions.innerHTML = '';
              results.forEach((template, index) => {
                  const li = document.createElement('li');
                  li.role = 'option';
                  li.id = `suggestion-${index}`;
                  const localizedTitle = getTemplateTitle(template);
                  const localizedDescription = getTemplateDescription(template);
                  li.textContent = `${localizedTitle}  ${localizedDescription}`;
                  li.addEventListener('click', () => addNodeFromTemplate(template));
                  elements.suggestions.appendChild(li);
              });
              return results;
          };
          const copySelection = () => {
              if (!state.selection.size)
                  return;
              state.clipboard = state.nodes
                  .filter(node => state.selection.has(node.id))
                  .map(node => (0, state_1.deepClone)(node));
          };
          const pasteSelection = (offset = { x: 40, y: 40 }) => {
              if (!state.clipboard.length || state.readonly)
                  return;
              const newNodes = state.clipboard.map((node, index) => ({
                  ...(0, state_1.deepClone)(node),
                  id: createId(node.typeId + '-' + index),
                  position: {
                      x: snap(node.position.x + offset.x),
                      y: snap(node.position.y + offset.y)
                  }
              }));
              state.nodes.push(...newNodes);
              state.selection = new Set(newNodes.map(node => node.id));
              commitState();
          };
          const duplicateSelection = () => {
              copySelection();
              pasteSelection({ x: 24, y: 24 });
          };
          const alignSelection = (mode) => {
              if (!state.selection.size)
                  return;
              const nodes = state.nodes.filter(node => state.selection.has(node.id));
              if (!nodes.length)
                  return;
              const aligners = {
                  left: () => Math.min(...nodes.map(node => node.position.x)),
                  top: () => Math.min(...nodes.map(node => node.position.y)),
                  center: () => (nodes.reduce((sum, node) => sum + node.position.x + (node.width ?? 200) / 2, 0) / nodes.length)
              };
              if (mode === 'left') {
                  const minX = aligners.left();
                  nodes.forEach(node => (node.position.x = snap(minX)));
              }
              else if (mode === 'top') {
                  const minY = aligners.top();
                  nodes.forEach(node => (node.position.y = snap(minY)));
              }
              else if (mode === 'center') {
                  const center = aligners.center();
                  nodes.forEach(node => (node.position.x = snap(center - (node.width ?? 200) / 2)));
              }
              commitState();
          };
          const setZoom = (value, anchor) => {
              const rect = elements.canvas.getBoundingClientRect();
              const wrapLeft = rect.left - state.viewport.x;
              const wrapTop = rect.top - state.viewport.y;
              const target = clampZoom(value);
              const previousZoom = state.zoom;
              if (anchor) {
                  const anchorWorld = {
                      x: (anchor.clientX - rect.left) / previousZoom,
                      y: (anchor.clientY - rect.top) / previousZoom
                  };
                  state.viewport.x = anchor.clientX - wrapLeft - anchorWorld.x * target;
                  state.viewport.y = anchor.clientY - wrapTop - anchorWorld.y * target;
              }
              state.zoom = target;
              updateCanvasTransform();
              updateZoomUi();
          };
          const stepZoom = (direction, anchor) => {
              const delta = direction * ZOOM_STEP;
              setZoom(state.zoom + delta, anchor);
          };
          const applyZoomInputValue = () => {
              const raw = elements.zoomInput.value.trim();
              if (!raw.length) {
                  elements.zoomInput.value = String(Math.round(state.zoom * 100));
                  return;
              }
              const value = Number(raw);
              if (!Number.isFinite(value)) {
                  elements.zoomInput.value = String(Math.round(state.zoom * 100));
                  return;
              }
              setZoom(value / 100);
              closeZoomMenu();
          };
          const fitSelection = () => {
              if (!state.selection.size) {
                  setZoom(1);
                  resetViewport();
                  return;
              }
              const nodes = state.nodes.filter(node => state.selection.has(node.id));
              const minX = Math.min(...nodes.map(node => node.position.x));
              const maxX = Math.max(...nodes.map(node => node.position.x + (node.width ?? 200)));
              const minY = Math.min(...nodes.map(node => node.position.y));
              const maxY = Math.max(...nodes.map(node => node.position.y + (node.height ?? 120)));
              const boxWidth = maxX - minX + 64;
              const boxHeight = maxY - minY + 64;
              const view = getViewportSize();
              const scale = Math.min(view.width / boxWidth, view.height / boxHeight, 1);
              setZoom(scale);
              const centerX = minX + boxWidth / 2;
              const centerY = minY + boxHeight / 2;
              state.viewport.x = view.width / 2 - centerX * state.zoom;
              state.viewport.y = view.height / 2 - centerY * state.zoom;
              updateCanvasTransform();
          };
          const serializeAndDownload = () => {
              const blob = new Blob([elements.json.value], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = url;
              link.download = `nodevision-project-${Date.now()}.json`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
          };
          const getSerializedProjectJson = () => JSON.stringify(serializeProject());
          const findWorkflowById = (id) => id ? state.workflows.find(workflow => workflow.id === id) : undefined;
          const persistWorkflowRecord = (workflow) => {
              const index = state.workflows.findIndex(item => item.id === workflow.id);
              if (index >= 0) {
                  state.workflows[index] = workflow;
              }
              else {
                  state.workflows.push(workflow);
              }
              persistWorkflowsAndRender();
          };
          const loadWorkflowEntry = (workflow) => {
              try {
                  applyProjectJson(workflow.data, { markDirty: false });
                  state.activeWorkflowId = workflow.id;
                  state.workflowName = workflow.name;
                  state.workflowDirty = false;
                  updateWorkflowNameUi();
                  renderWorkflowList();
                  closeWorkflowMenu();
              }
              catch (error) {
                  alert(t('errors.jsonLoadFailed', { reason: getErrorMessage(error) }));
              }
          };
          const buildNodeFromSerialized = (node) => {
              const template = templates.find(item => item.typeId === node.typeId);
              const templateTokens = template?.searchTokens ?? [];
              return {
                  id: node.id,
                  typeId: node.typeId,
                  nodeVersion: node.nodeVersion ?? '1.0.0',
                  title: node.title ?? node.typeId,
                  position: {
                      x: snap(node.position?.x ?? 0),
                      y: snap(node.position?.y ?? 0)
                  },
                  width: template?.width ?? 220,
                  height: template?.height ?? 120,
                  searchTokens: templateTokens,
                  inputs: (0, state_1.clonePorts)(template?.inputs),
                  outputs: (0, state_1.clonePorts)(template?.outputs),
                  settings: cloneNodeSettings(node.settings ?? template?.defaultSettings)
              };
          };
          const applyProjectJson = (json, options = {}) => {
              const parsed = JSON.parse(json);
              if (!parsed.schemaVersion) {
                  throw new Error(t('errors.schemaMissing'));
              }
              state.readonly = parsed.schemaVersion !== SCHEMA;
              cleanupAllMediaPreviews();
              state.nodes = (parsed.nodes ?? []).map(buildNodeFromSerialized);
              state.connections = (parsed.connections ?? []).map(state_1.cloneConnection);
              state.pendingConnection = null;
              state.selection.clear();
              updateReadonlyUi();
              renderNodes();
              renderConnections();
              updatePendingHint();
              commitState({ skipDirtyFlag: true });
              state.workflowDirty = options.markDirty ?? false;
              updateWorkflowNameUi();
          };
          const loadFromTextarea = () => {
              try {
                  applyProjectJson(elements.json.value, { markDirty: true });
                  setUnsavedWorkflow({ dirty: true });
              }
              catch (error) {
                  alert(t('errors.jsonLoadFailed', { reason: getErrorMessage(error) }));
              }
          };
          const updateReadonlyUi = () => {
              document.body.classList.toggle('readonly', state.readonly);
              if (state.readonly && state.pendingConnection) {
                  state.pendingConnection = null;
                  updatePendingHint();
                  refreshPendingPortUi();
              }
          };
          const handleKeydown = (event) => {
              if (workflowNameDialogResolver) {
                  if (event.key === 'Escape') {
                      event.preventDefault();
                      cancelWorkflowNameDialog();
                  }
                  else if (event.key === 'Enter' && event.target === elements.workflowNameInput && !event.isComposing) {
                      event.preventDefault();
                      submitWorkflowNameDialog();
                  }
                  return;
              }
              if (state.workflowContextMenuOpen && event.key === 'Escape') {
                  event.preventDefault();
                  closeWorkflowContextMenu();
                  return;
              }
              const modifier = event.metaKey || event.ctrlKey;
              if (modifier && event.key.toLowerCase() === 'c') {
                  event.preventDefault();
                  copySelection();
              }
              else if (modifier && event.key.toLowerCase() === 'v') {
                  event.preventDefault();
                  pasteSelection();
              }
              else if (modifier && event.key.toLowerCase() === 'd') {
                  event.preventDefault();
                  duplicateSelection();
              }
              else if (isZoomInShortcut(event)) {
                  event.preventDefault();
                  const anchor = getCanvasCenterAnchor();
                  stepZoom(1, anchor);
              }
              else if (isZoomOutShortcut(event)) {
                  event.preventDefault();
                  const anchor = getCanvasCenterAnchor();
                  stepZoom(-1, anchor);
              }
              else if (event.key === '1' && !event.shiftKey && !modifier) {
                  setZoom(1);
              }
              else if ((event.key === '1' || event.key === '!') && event.shiftKey) {
                  fitSelection();
              }
              else if (!modifier && !event.altKey && event.key === '.') {
                  event.preventDefault();
                  fitSelection();
              }
              else if (!modifier && !event.altKey && event.key.toLowerCase() === 'h') {
                  event.preventDefault();
                  setActiveTool('pan');
              }
              else if (!modifier && !event.altKey && event.key.toLowerCase() === 'v') {
                  event.preventDefault();
                  setActiveTool('select');
              }
              else if (event.key === 'Escape' && zoomMenuOpen) {
                  event.preventDefault();
                  closeZoomMenu();
              }
              else if (event.key === 'Escape' && state.workflowMenuOpen) {
                  event.preventDefault();
                  closeWorkflowMenu();
              }
              else if (event.key === 'Escape' && state.pendingConnection) {
                  event.preventDefault();
                  clearPendingConnection();
              }
          };
          elements.canvas.addEventListener('pointerdown', event => {
              if (maybeStartMarquee(event)) {
                  return;
              }
              startPanSession(event);
          });
          const handleCanvasWheel = (event) => {
              if (!(event.ctrlKey || event.metaKey || event.altKey)) {
                  return;
              }
              if (!isEventInsideCanvas(event)) {
                  return;
              }
              event.preventDefault();
              const anchor = { clientX: event.clientX, clientY: event.clientY };
              const direction = event.deltaY < 0 ? 1 : -1;
              stepZoom(direction, anchor);
          };
          window.addEventListener('wheel', handleCanvasWheel, { passive: false });
          elements.canvasControls.addEventListener('pointerdown', startCanvasControlsDrag);
          window.addEventListener('resize', handleCanvasControlsResize);
          elements.toolSelect.addEventListener('click', () => setActiveTool('select'));
          elements.toolPan.addEventListener('click', () => setActiveTool('pan'));
          elements.fitView.addEventListener('click', () => fitSelection());
          elements.zoomDisplay.addEventListener('click', () => toggleZoomMenu());
          elements.zoomIn.addEventListener('click', () => {
              stepZoom(1);
          });
          elements.zoomOut.addEventListener('click', () => {
              stepZoom(-1);
          });
          elements.zoomFitMenu.addEventListener('click', () => {
              fitSelection();
          });
          elements.zoomApply.addEventListener('click', () => applyZoomInputValue());
          elements.zoomInput.addEventListener('keydown', event => {
              if (event.key === 'Enter') {
                  event.preventDefault();
                  applyZoomInputValue();
              }
          });
          document.addEventListener('pointerdown', event => {
              if (!zoomMenuOpen) {
                  return;
              }
              const target = event.target;
              if (!target) {
                  return;
              }
              if (target === elements.zoomDisplay) {
                  return;
              }
              if (target.closest('#zoom-menu')) {
                  return;
              }
              closeZoomMenu();
          });
          elements.selectionOutline.addEventListener('pointerdown', event => {
              if (!state.selection.size) {
                  return;
              }
              event.preventDefault();
              event.stopPropagation();
              beginSelectionDrag(event);
          });
          elements.searchInput.addEventListener('input', event => {
              const target = event.target;
              updateSuggestions(target.value);
          });
          elements.searchInput.addEventListener('keydown', event => {
              const results = updateSuggestions(elements.searchInput.value);
              if (event.key === 'Enter' && results.length) {
                  addNodeFromTemplate(results[0]);
                  elements.searchInput.select();
              }
          });
          document.querySelectorAll('[data-align]').forEach(button => {
              button.addEventListener('click', event => {
                  const current = event.currentTarget;
                  const mode = current.getAttribute('data-align');
                  if (mode) {
                      alignSelection(mode);
                  }
              });
          });
          elements.workflowToggle.addEventListener('click', event => {
              event.preventDefault();
              toggleWorkflowMenu();
          });
          const workflowMenuButtons = [
              { button: elements.workflowMenuRename, action: 'rename' },
              { button: elements.workflowMenuFileSave, action: 'fileSave' },
              { button: elements.workflowMenuFileLoad, action: 'fileLoad' },
              { button: elements.workflowMenuSaveAs, action: 'saveAs' },
              { button: elements.workflowMenuClear, action: 'clear' },
              { button: elements.workflowMenuBrowse, action: 'browse' }
          ];
          workflowMenuButtons.forEach(entry => {
              entry.button.addEventListener('click', event => {
                  event.preventDefault();
                  event.stopPropagation();
                  handleWorkflowMenuAction(entry.action);
              });
          });
          elements.workflowSearch.addEventListener('input', event => {
              const target = event.target;
              state.workflowSearch = target.value;
              renderWorkflowList();
          });
          elements.workflowList.addEventListener('click', event => {
              const button = event.target?.closest('button[data-workflow-id]');
              if (!button) {
                  return;
              }
              event.preventDefault();
              const workflow = findWorkflowById(button.dataset.workflowId ?? null);
              if (workflow) {
                  loadWorkflowEntry(workflow);
              }
          });
          elements.workflowList.addEventListener('contextmenu', event => {
              const button = event.target?.closest('button[data-workflow-id]');
              if (!button) {
                  return;
              }
              event.preventDefault();
              const workflowId = button.dataset.workflowId;
              if (!workflowId) {
                  return;
              }
              openWorkflowContextMenu(workflowId, event.clientX, event.clientY);
          });
          elements.workflowCreate.addEventListener('click', () => {
              if (state.activeWorkflowId) {
                  handleWorkflowSave();
              }
              else {
                  void handleWorkflowSaveAs();
              }
          });
          elements.workflowNameConfirm.addEventListener('click', submitWorkflowNameDialog);
          elements.workflowNameCancel.addEventListener('click', cancelWorkflowNameDialog);
          elements.workflowNameDialog.addEventListener('click', event => {
              if (event.target === elements.workflowNameDialog) {
                  cancelWorkflowNameDialog();
              }
          });
          elements.workflowNameInput.addEventListener('input', () => {
              elements.workflowNameInput.dataset.invalid = 'false';
          });
          elements.workflowNameInput.addEventListener('keydown', event => {
              if (event.key === 'Enter' && !event.isComposing) {
                  event.preventDefault();
                  submitWorkflowNameDialog();
              }
          });
          elements.workflowContextDelete.addEventListener('click', () => {
              deleteWorkflowById(state.workflowContextTargetId);
          });
          document.addEventListener('pointerdown', event => {
              const target = event.target;
              if (state.workflowMenuOpen) {
                  if (!target || !target.closest('.workflow-dropdown')) {
                      closeWorkflowMenu();
                  }
              }
              if (state.workflowContextMenuOpen) {
                  if (!target || !elements.workflowContextMenu.contains(target)) {
                      closeWorkflowContextMenu();
                  }
              }
          });
          elements.localeSelect.value = state.locale;
          elements.localeSelect.addEventListener('change', event => {
              const target = event.target;
              const next = target.value;
              if (next && TRANSLATIONS[next]) {
                  setLocale(next);
              }
          });
          elements.undo.addEventListener('click', undo);
          elements.redo.addEventListener('click', redo);
          elements.runningToggle.addEventListener('change', event => {
              const target = event.target;
              state.isRunning = target.checked;
              scheduleAutosave();
          });
          const enqueueDemoJob = async () => {
              if (!nodevision?.enqueueDemoJob) {
                  showToast(t('toast.demoJobMissing'), 'error');
                  return;
              }
              const response = await nodevision.enqueueDemoJob({ name: t('demo.jobName') });
              if (response?.ok) {
                  showToast(t('toast.demoJobAdded'));
              }
              else if (response?.code === 'QUEUE_FULL') {
                  showToast(t('toast.queueFull', { code: response.code }), 'error');
              }
              else {
                  const reason = response?.error ?? response?.message ?? 'unknown';
                  showToast(t('toast.demoJobFailed', { reason }), 'error');
              }
              refreshQueue();
          };
          const cancelAllJobs = async () => {
              if (!nodevision?.cancelAllJobs)
                  return;
              await nodevision.cancelAllJobs();
              showToast(t('toast.cancelAll'));
              refreshQueue();
          };
          const refreshLocaleDependentViews = () => {
              applyTranslations();
              syncUnsavedWorkflowLabel();
              renderStatus();
              renderAbout();
              renderNodes();
              renderConnections();
              renderWorkflowList();
              updatePendingHint();
              updateSuggestions(elements.searchInput.value ?? '');
              updateJsonPreview();
              renderQueue();
              renderDiagnostics();
              updateAutosaveIdleMessage();
          };
          const persistLocale = (locale) => {
              try {
                  if (typeof localStorage === 'undefined') {
                      return;
                  }
                  localStorage.setItem(LOCALE_STORAGE_KEY, locale);
              }
              catch (error) {
                  console.warn('[NodeVision] persist locale failed', error);
              }
          };
          const setLocale = (locale) => {
              if (!TRANSLATIONS[locale]) {
                  return;
              }
              if (state.locale === locale) {
                  persistLocale(locale);
                  return;
              }
              state.locale = locale;
              persistLocale(locale);
              refreshLocaleDependentViews();
              if (elements.localeSelect) {
                  elements.localeSelect.value = locale;
              }
          };
          const exportLogs = async () => {
              if (!nodevision?.exportLogs) {
                  showToast(t('toast.exportMissing'), 'error');
                  return;
              }
              const password = elements.logPassword.value?.trim() || null;
              const response = await nodevision.exportLogs(password);
              if (!response) {
                  showToast(t('toast.exportFailed', { reason: 'unknown' }), 'error');
                  return;
              }
              if (response.ok) {
                  if (response.diagnostics) {
                      state.diagnostics = {
                          ...state.diagnostics,
                          ...response.diagnostics,
                          lastExportSha: response.diagnostics.lastExportSha ?? state.diagnostics.lastExportSha
                      };
                      renderDiagnostics();
                  }
                  const exportPath = response.result?.outputPath ?? t('diagnostics.defaultPath');
                  const sha = response.result?.sha256 ?? state.diagnostics.lastExportSha ?? null;
                  const shaSuffix = sha ? t('toast.logsExportedSha', { sha }) : '';
                  showToast(t('toast.logsExported', { path: exportPath, shaSuffix }));
              }
              else {
                  const reason = response.message ?? 'unknown';
                  showToast(t('toast.exportFailed', { reason }), 'error');
              }
          };
          elements.demoJob.addEventListener('click', enqueueDemoJob);
          elements.cancelAll.addEventListener('click', cancelAllJobs);
          elements.exportLogs.addEventListener('click', exportLogs);
          elements.crashConsent.addEventListener('change', async (event) => {
              if (!nodevision?.setCrashDumpConsent)
                  return;
              const target = event.target;
              const enabled = target.checked;
              const result = await nodevision.setCrashDumpConsent(enabled);
              state.diagnostics.collectCrashDumps = result.collectCrashDumps;
              renderDiagnostics();
              showToast(result.collectCrashDumps ? t('toast.crashOn') : t('toast.crashOff'));
          });
          elements.connectionsList.addEventListener('change', event => {
              const target = event.target;
              if (!target || target.getAttribute('data-connection-check') === null)
                  return;
              const connectionId = target.getAttribute('data-connection-check');
              if (!connectionId)
                  return;
              if (target.checked) {
                  state.highlightedConnections.add(connectionId);
              }
              else {
                  state.highlightedConnections.delete(connectionId);
              }
              renderConnectionPaths();
              applyNodeHighlightClasses();
          });
          window.addEventListener('beforeunload', cleanupAllMediaPreviews);
          document.addEventListener('keydown', handleKeydown);
          setupSidebarPanels();
          renderStatus();
          renderAbout();
          initializeNodeRenderers();
          renderNodes();
          renderConnections();
          updatePendingHint();
          updateSuggestions('');
          pushHistory();
          updateJsonPreview();
          renderQueue();
          renderDiagnostics();
          refreshQueue();
          setInterval(refreshQueue, 4000);
      })();

        },
        './dom': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.captureDomElements = void 0;
      const getElement = (id) => {
          const element = document.getElementById(id);
          if (!element) {
              throw new Error(`NodeVision renderer missing #${id}`);
          }
          return element;
      };
      const captureDomElements = () => ({
          canvasControls: getElement('canvas-controls'),
          statusList: getElement('status-list'),
          canvas: getElement('canvas'),
          canvasGrid: getElement('canvas-grid'),
          selectionRect: getElement('selection-rect'),
          selectionOutline: getElement('selection-outline'),
          nodeLayer: getElement('node-layer'),
          connectionLayer: getElement('connection-layer'),
          toolSelect: getElement('tool-select'),
          toolPan: getElement('tool-pan'),
          fitView: getElement('btn-fit-view'),
          zoomDisplay: getElement('zoom-display'),
          zoomMenu: getElement('zoom-menu'),
          zoomIn: getElement('zoom-in'),
          zoomOut: getElement('zoom-out'),
          zoomFitMenu: getElement('zoom-fit-menu'),
          zoomApply: getElement('zoom-apply'),
          zoomInput: getElement('zoom-input'),
          searchInput: getElement('node-search'),
          suggestions: getElement('search-suggestions'),
          autosave: getElement('autosave-indicator'),
          undo: getElement('btn-undo'),
          redo: getElement('btn-redo'),
          json: getElement('project-json'),
          runningToggle: getElement('running-toggle'),
          localeSelect: getElement('locale-select'),
          readonlyBanner: getElement('readonly-banner'),
          queueRunning: getElement('queue-running'),
          queueQueued: getElement('queue-queued'),
          queueHistory: getElement('queue-history'),
          queueWarnings: getElement('queue-warnings'),
          crashConsent: getElement('crash-consent'),
          logPassword: getElement('log-password'),
          exportLogs: getElement('btn-export-logs'),
          exportStatus: getElement('export-status'),
          inspectHistory: getElement('inspect-history'),
          connectionsList: getElement('connection-list'),
          connectionHint: getElement('connection-pending'),
          demoJob: getElement('btn-demo-job'),
          cancelAll: getElement('btn-cancel-all'),
          toast: getElement('toast'),
          aboutDistribution: getElement('about-distribution'),
          aboutLicense: getElement('about-license'),
          aboutPath: getElement('about-path'),
          aboutVersion: getElement('about-version'),
          aboutNotice: getElement('about-notice'),
          aboutLicenseLink: getElement('about-license-link'),
          aboutSourceLink: getElement('about-source-link'),
          workflowToggle: getElement('workflow-toggle'),
          workflowMenu: getElement('workflow-menu'),
          workflowNameLabel: getElement('workflow-name-label'),
          workflowMenuRename: getElement('workflow-menu-rename'),
          workflowMenuFileSave: getElement('workflow-menu-file-save'),
          workflowMenuFileLoad: getElement('workflow-menu-file-load'),
          workflowMenuSaveAs: getElement('workflow-menu-save-as'),
          workflowMenuClear: getElement('workflow-menu-clear'),
          workflowMenuBrowse: getElement('workflow-menu-browse'),
          workflowSearch: getElement('workflow-search'),
          workflowList: getElement('workflow-list'),
          workflowEmpty: getElement('workflow-empty'),
          workflowCreate: getElement('workflow-create'),
          workflowContextMenu: getElement('workflow-context-menu'),
          workflowContextDelete: getElement('workflow-context-delete'),
          workflowNameDialog: getElement('workflow-name-dialog'),
          workflowNameInput: getElement('workflow-name-input'),
          workflowNameConfirm: getElement('workflow-name-confirm'),
          workflowNameCancel: getElement('workflow-name-cancel')
      });
      exports.captureDomElements = captureDomElements;

        },
        './i18n': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UI_TRANSLATIONS = void 0;
      exports.UI_TRANSLATIONS = {
          'en-US': {
              'common.close': 'Close',
              'actions.save': 'Save',
              'actions.cancel': 'Cancel',
              'actions.reset': 'Reset',
              'app.title': 'NodeVision Editor',
              'toolbar.alignLeft': 'Align left',
              'toolbar.alignTop': 'Align top',
              'toolbar.alignCenter': 'Align center',
              'toolbar.undo': 'Undo',
              'toolbar.redo': 'Redo',
              'toolbar.runningMode': 'Running mode',
              'toolbar.localeLabel': 'Language',
              'toolbar.locale.en': 'English',
              'toolbar.locale.ja': 'Japanese',
              'workflow.unsaved': 'Unsaved Workflow',
              'workflow.menu.rename': 'Rename',
              'workflow.menu.fileSave': 'Save to file',
              'workflow.menu.fileLoad': 'Load from file',
              'workflow.menu.saveAs': 'Save as',
              'workflow.menu.clear': 'Clear workflow',
              'workflow.menu.openList': 'Browse workflows',
              'workflow.context.delete': 'Delete workflow',
              'workflow.modal.title': 'Workflow name',
              'workflow.modal.placeholder': 'Name your workflow',
              'workflow.modal.cancel': 'Cancel',
              'workflow.modal.confirm': 'Save',
              'workflow.promptName': 'Workflow name',
              'workflow.confirmDelete': 'Delete workflow "{{name}}"?',
              'workflow.confirmClear': 'Clear the current workflow? This removes all nodes.',
              'workflow.errorNameRequired': 'Please enter a workflow name.',
              'workflows.title': 'Workflows',
              'workflows.saveCurrent': 'Save current workflow',
              'workflows.searchLabel': 'Search workflows',
              'workflows.searchPlaceholder': 'Search workflows',
              'workflows.empty': 'No saved workflows yet',
              'autosave.pending': 'Waiting for changes...',
              'autosave.running': 'Monitoring changes while running ({{seconds}}s)',
              'autosave.idle': 'Watching for edits ({{seconds}}s)',
              'autosave.saved': 'Autosaved at {{time}}',
              'sidebar.ariaLabel': 'Node search and help',
              'sidebar.searchLabel': 'Node search',
              'sidebar.searchPlaceholder': 'Load, Trim, Resize...',
              'sidebar.suggestionsLabel': 'Node suggestions',
              'help.shortcutsTitle': 'Shortcuts',
              'help.copy': 'Copy node',
              'help.paste': 'Paste (4px snap)',
              'help.duplicate': 'Duplicate',
              'help.zoomReset': 'Zoom 100%',
              'help.fitSelection': 'Fit selection',
              'help.zoomIn': 'Canvas zoom in',
              'help.zoomOut': 'Canvas zoom out',
              'help.guideTitle': 'Guided actions',
              'help.guideHtml': ' Drag nodes to move (4px snap)<br /> Press Enter to add highlighted suggestions<br /> Use Tab to focus cards.',
              'readonly.banner': 'Read-only because the schema version differs. Editing is disabled.',
              'queue.ariaLabel': 'Job queue',
              'queue.title': 'Job queue',
              'queue.demoJob': 'Add demo job',
              'queue.cancelAll': 'Cancel all',
              'queue.status.running': 'Running',
              'queue.status.queued': 'Queued',
              'queue.status.coolingDown': 'Cooling down',
              'queue.status.failed': 'Failed',
              'queue.status.canceled': 'Canceled',
              'queue.historyTitle': 'History (20 entries)',
              'queue.emptyActive': 'No active jobs',
              'queue.emptyQueued': 'No queued jobs',
              'queue.noHistory': 'No history yet',
              'queue.noLogs': 'No logs yet',
              'queue.defaultJob': 'Job',
              'queue.stableTitle': 'Queue Stable',
              'queue.stableSummary': 'Queued {{queued}}/{{limit}}  Timeout {{timeout}}s',
              'nodes.ariaLabel': '{{title}} node',
              'nodes.load.selectButton': 'Choose a file to upload',
              'nodes.load.empty': 'No media selected yet',
              'nodes.load.previewMeta': '{{name}}  {{size}}  {{type}}',
              'nodes.load.unknownType': 'unknown format',
              'nodes.load.noFile': 'No file chosen',
              'nodes.load.aspectUnknown': 'Size unknown',
              'nodes.mediaPreview.noInput': 'Connect a media node to preview it here.',
              'nodes.mediaPreview.waiting': 'Waiting for upstream media',
              'nodes.mediaPreview.disconnected': 'No source connected',
              'nodes.mediaPreview.sourceLabel': 'Source: {{title}}',
              'nodes.mediaPreview.metaUnknown': 'Size unknown',
              'nodes.delete': 'Delete node',
              'nodes.status.connected': 'Connected',
              'nodes.status.missing': 'Missing',
              'nodes.trim.tip': 'Connect a source clip and edit it using the trim modals before applying heavy effects.',
              'nodes.trim.imageButton': 'Image Trim',
              'nodes.trim.videoButton': 'Video Trim',
              'nodes.trim.status.empty': 'No adjustments yet',
              'nodes.trim.status.imageEdited': 'Image crop ready',
              'nodes.trim.status.videoEdited': 'Video trim ready',
              'nodes.trim.status.imageSummary': 'Image crop {{width}}%  {{height}}%',
              'nodes.trim.status.videoSummary': 'Video {{start}}  {{end}}{{strict}}',
              'nodes.trim.status.videoEndLabel': 'end',
              'nodes.trim.status.videoStrictSuffix': '(strict)',
              'nodes.trim.imageTools.zoomIn': 'Zoom in',
              'nodes.trim.imageTools.zoomOut': 'Zoom out',
              'nodes.trim.imageTools.grid': 'Grid',
              'nodes.trim.imageTools.rotateLeft': 'Rotate left',
              'nodes.trim.imageTools.rotateRight': 'Rotate right',
              'nodes.trim.imageTools.flipHorizontal': 'Flip horizontally',
              'nodes.trim.imageTools.flipHorizontalShort': '',
              'nodes.trim.imageTools.flipVertical': 'Flip vertically',
              'nodes.trim.imageTools.flipVerticalShort': '',
              'nodes.trim.imageTools.reset': 'Reset transform',
              'nodes.trim.imageControls.rotation': 'Rotation',
              'nodes.trim.imageControls.zoom': 'Zoom',
              'nodes.trim.imageControls.aspect': 'Aspect ratio',
              'nodes.trim.imageControls.aspectOption.free': 'Free',
              'nodes.trim.imageControls.aspectOption.original': 'Original',
              'nodes.trim.imageControls.aspectOption.square': 'Square',
              'nodes.trim.imageControls.aspectOption.4:3': '4:3',
              'nodes.trim.imageControls.aspectOption.16:9': '16:9',
              'nodes.trim.imageControls.aspectOption.9:16': '9:16',
              'nodes.trim.modalPlaceholder.image': 'Drag the highlighted box or its corners to crop the displayed image.',
              'nodes.trim.modalPlaceholder.video': 'Video trim modal is coming soonset accurate in/out ranges in a dedicated workspace.',
              'nodes.trim.toast.imageSaved': 'Image crop updated.',
              'nodes.trim.toast.videoSaved': 'Video trim updated.',
              'nodes.trim.modalPlaceholder.noImage': 'Load an image source and connect it to this Trim node to enable cropping.',
              'nodes.mediaPreview.trimmedBadge': 'Trimmed output',
              'nodes.mediaPreview.trimmedRange': 'Range {{start}}  {{end}}{{strict}}',
              'nodes.mediaPreview.trimmedCrop': 'Crop {{width}}%  {{height}}%',
              'nodes.trim.modalPlaceholder.noVideo': 'Connect a video Load node and capture a preview before trimming.',
              'nodes.trim.modalHint.video': 'Use the handles or enter exact timecodes, then save to refresh downstream previews.',
              'nodes.trim.video.previewFallback': 'Video source',
              'nodes.trim.video.startLabel': 'Start time',
              'nodes.trim.video.endLabel': 'End time',
              'nodes.trim.video.durationUnknown': 'Duration unknown',
              'nodes.trim.video.strictLabel': 'Strict cut',
              'nodes.trim.video.strictHint': 'Discard frames outside the saved range.',
              'nodes.trim.video.controls.play': 'Play',
              'nodes.trim.video.controls.pause': 'Pause',
              'nodes.trim.video.controls.stepBack': 'Step back',
              'nodes.trim.video.controls.stepForward': 'Step forward',
              'nodes.trim.video.startHandle': 'Adjust start handle',
              'nodes.trim.video.endHandle': 'Adjust end handle',
              'nodes.resize.tip': 'Keep Resize nodes near export to avoid repeated resampling.',
              'nodes.overlay.tip': 'Attach both Base and Layer inputsalpha channels stay intact.',
              'nodes.text.tip': 'Text Overlay renders crisp vector titles on top of the background clip.',
              'nodes.crop.tip': 'Crop defines the visible frame; pair it with Resize or Export to lock the aspect.',
              'nodes.speed.tip': 'Speed changes alter downstream duration, so reconnect jobs after tweaking ratios.',
              'nodes.changeFps.tip': 'Normalize variable frame rate footage before export to keep audio in sync.',
              'nodes.export.tip': 'Only flows that reach Export will generate a rendered file.',
              'ports.inputsLabel': '{{title}} inputs',
              'ports.outputsLabel': '{{title}} outputs',
              'ports.emptyInputs': 'No inputs',
              'ports.emptyOutputs': 'No outputs',
              'ports.direction.input': 'Input',
              'ports.direction.output': 'Output',
              'ports.portLabel': '{{direction}} port {{label}} ({{dataType}})',
              'connections.title': 'Connections',
              'connections.ariaLabel': 'Connection list',
              'connections.empty': 'No connections yet',
              'connections.ready': 'Select an output port to start connecting',
              'connections.remove': 'Remove connection',
              'connections.itemLabel': '{{from}}  {{to}}',
              'connections.pending': 'Select an input port to finish connection from {{from}}',
              'diagnostics.ariaLabel': 'Logs and diagnostics',
              'diagnostics.title': 'Logs & diagnostics',
              'diagnostics.crashConsent': 'Include crash dumps',
              'diagnostics.passwordPlaceholder': 'Export password',
              'diagnostics.exportButton': 'Export logs',
              'diagnostics.inspectHistoryTitle': 'Inspect history (20 entries)',
              'diagnostics.noExport': 'No exports yet',
              'diagnostics.lastExport': 'Last export: {{path}} (SHA {{sha}})',
              'diagnostics.unknownSha': 'unknown',
              'diagnostics.historyEmpty': 'No inspect history yet',
              'diagnostics.noDetails': 'No details',
              'diagnostics.defaultToken': 'token?',
              'diagnostics.clipCount': '{{count}} clips',
              'diagnostics.defaultPath': 'diagnostics folder',
              'json.banner': 'Manage JSON saves and loads here. schemaVersion=1.0.7 is preserved.',
              'json.export': 'Export JSON',
              'json.import': 'Import JSON',
              'json.editorLabel': 'JSON for save/load',
              'canvas.ariaLabel': 'Node canvas',
              'canvas.controls': 'Canvas controls',
              'canvas.toolSelectTooltip': 'Select tool (V)',
              'canvas.toolPanTooltip': 'Pan view (H)',
              'canvas.fitViewTooltip': 'Fit selection (.)',
              'canvas.zoomDisplayLabel': 'Zoom options (+~ / +Shift+; for zoom in  += / +Shift+= for zoom out)',
              'canvas.zoomIn': 'Zoom in (+~ / +Shift+;)',
              'canvas.zoomOut': 'Zoom out (+= / +Shift+=)',
              'canvas.zoomToFit': 'Zoom to fit selection',
              'canvas.zoomApply': 'Apply',
              'canvas.zoomInputLabel': 'Zoom percent',
              'canvas.zoomInputPlaceholder': 'e.g. 150',
              'toast.queueRefreshFailed': 'Failed to refresh queue: {{message}}',
              'toast.demoJobMissing': 'Demo job API is unavailable',
              'toast.demoJobAdded': 'Demo job added',
              'toast.queueFull': '{{code}}: queue is full',
              'toast.demoJobFailed': 'Failed to add job: {{reason}}',
              'toast.cancelAll': 'All jobs canceled',
              'toast.mediaSelected': 'Loaded {{name}}',
              'toast.mediaFailed': 'Could not open the file picker. Try again or restart.',
              'toast.mediaWrongTypeImage': 'This node only accepts image files.',
              'toast.mediaWrongTypeVideo': 'This node only accepts video files.',
              'toast.exportMissing': 'Export API is not connected',
              'toast.exportFailed': 'Export failed: {{reason}}',
              'toast.logsExported': 'Logs exported to {{path}}{{shaSuffix}}',
              'toast.logsExportedSha': ' (SHA256: {{sha}})',
              'toast.crashOn': 'Crash dumps will be included',
              'toast.crashOff': 'Crash dumps will be excluded',
              'errors.schemaMissing': 'schemaVersion is missing',
              'errors.jsonLoadFailed': 'Failed to load JSON: {{reason}}',
              'about.title': 'About & licensing',
              'about.ariaLabel': 'About and licensing',
              'about.distributionLabel': 'FFmpeg distribution',
              'about.licenseLabel': 'License',
              'about.pathLabel': 'FFmpeg path',
              'about.versionLabel': 'FFmpeg version',
              'about.origin.bundled': 'Bundled with NodeVision',
              'about.origin.external': 'External/system binary',
              'about.noticeBundled': 'NodeVision ships FFmpeg compiled under the LGPL v2.1+. Use the links below to review the license text and download matching source code.',
              'about.noticeExternal': 'FFmpeg was detected on this system. Confirm that the {{license}} license suits your redistribution requirements.',
              'about.licenseLinkLabel': 'License text',
              'about.sourceLinkLabel': 'FFmpeg source',
              'about.versionUnknown': 'Unknown',
              'about.licenseValue.lgpl': 'LGPL v2.1+',
              'about.licenseValue.gpl': 'GPL v3+',
              'about.licenseValue.nonfree': 'Nonfree build (--enable-nonfree)',
              'about.licenseValue.unknown': 'Unknown license',
              'nodeTemplate.loadMedia.title': 'Load Media',
              'nodeTemplate.loadMedia.description': 'Open a local image or video file',
              'nodeTemplate.loadMedia.port.media': 'Media',
              'nodeTemplate.loadImage.title': 'Load Image',
              'nodeTemplate.loadImage.description': 'Open a local image file',
              'nodeTemplate.loadImage.port.media': 'Image',
              'nodeTemplate.loadVideo.title': 'Load Video',
              'nodeTemplate.loadVideo.description': 'Open a local video file',
              'nodeTemplate.loadVideo.port.media': 'Video',
              'nodeTemplate.mediaPreview.title': 'Media Preview',
              'nodeTemplate.mediaPreview.description': 'Display the connected image or video inside the graph',
              'nodeTemplate.mediaPreview.port.source': 'Source',
              'nodeTemplate.trim.title': 'Trim',
              'nodeTemplate.trim.description': 'Cut media between in/out points',
              'nodeTemplate.trim.port.source': 'Source',
              'nodeTemplate.trim.port.result': 'Result',
              'nodeTemplate.resize.title': 'Resize',
              'nodeTemplate.resize.description': 'Resize media with aspect ratio controls',
              'nodeTemplate.resize.port.source': 'Source',
              'nodeTemplate.resize.port.resized': 'Resized',
              'nodeTemplate.overlay.title': 'Overlay',
              'nodeTemplate.overlay.description': 'Blend two sources with position controls',
              'nodeTemplate.overlay.port.base': 'Base',
              'nodeTemplate.overlay.port.layer': 'Layer',
              'nodeTemplate.overlay.port.composite': 'Composite',
              'nodeTemplate.text.title': 'Text Overlay',
              'nodeTemplate.text.description': 'Render titles or captions with font and color controls',
              'nodeTemplate.text.port.background': 'Background',
              'nodeTemplate.text.port.titled': 'Titled',
              'nodeTemplate.crop.title': 'Crop',
              'nodeTemplate.crop.description': 'Trim the visible area to a custom frame',
              'nodeTemplate.crop.port.source': 'Source',
              'nodeTemplate.crop.port.cropped': 'Cropped',
              'nodeTemplate.speed.title': 'Speed',
              'nodeTemplate.speed.description': 'Ramp playback speed for slow/fast motion',
              'nodeTemplate.speed.port.source': 'Source',
              'nodeTemplate.speed.port.retimed': 'Retimed',
              'nodeTemplate.changeFps.title': 'Change FPS',
              'nodeTemplate.changeFps.description': 'Convert variable frame rate clips to constant FPS',
              'nodeTemplate.changeFps.port.source': 'Source',
              'nodeTemplate.changeFps.port.normalized': 'Normalized',
              'nodeTemplate.export.title': 'Export Media',
              'nodeTemplate.export.description': 'Finalize and export the edited result',
              'nodeTemplate.export.port.program': 'Program',
              'nodeTemplate.export.port.delivery': 'Exported',
              'demo.jobName': 'FFmpeg demo render'
          },
          'ja-JP': {
              'common.close': '',
              'actions.save': '',
              'actions.cancel': '',
              'actions.reset': '',
              'app.title': 'NodeVision',
              'toolbar.alignLeft': '',
              'toolbar.alignTop': '',
              'toolbar.alignCenter': '',
              'toolbar.undo': '',
              'toolbar.redo': '',
              'toolbar.runningMode': '',
              'toolbar.localeLabel': '',
              'toolbar.locale.en': '',
              'toolbar.locale.ja': '',
              'workflow.unsaved': '',
              'workflow.menu.rename': '',
              'workflow.menu.fileSave': '',
              'workflow.menu.fileLoad': '',
              'workflow.menu.saveAs': '',
              'workflow.menu.clear': '',
              'workflow.menu.openList': '',
              'workflow.context.delete': '',
              'workflow.modal.title': '',
              'workflow.modal.placeholder': '',
              'workflow.modal.cancel': '',
              'workflow.modal.confirm': '',
              'workflow.promptName': '',
              'workflow.confirmDelete': '{{name}}',
              'workflow.confirmClear': '',
              'workflow.errorNameRequired': '',
              'workflows.title': '',
              'workflows.saveCurrent': '',
              'workflows.searchLabel': '',
              'workflows.searchPlaceholder': '',
              'workflows.empty': '',
              'autosave.pending': '...',
              'autosave.running': ' ({{seconds}})',
              'autosave.idle': ' ({{seconds}})',
              'autosave.saved': '{{time}} ',
              'sidebar.ariaLabel': '',
              'sidebar.searchLabel': '',
              'sidebar.searchPlaceholder': '',
              'sidebar.suggestionsLabel': '',
              'help.shortcutsTitle': '',
              'help.copy': '',
              'help.paste': '4px',
              'help.duplicate': '',
              'help.zoomReset': ' 100%',
              'help.fitSelection': '',
              'help.zoomIn': '',
              'help.zoomOut': '',
              'help.guideTitle': '',
              'help.guideHtml': '4px<br />Enter<br />Tab',
              'readonly.banner': '',
              'queue.ariaLabel': '',
              'queue.title': '',
              'queue.demoJob': '',
              'queue.cancelAll': '',
              'queue.status.running': '',
              'queue.status.queued': '',
              'queue.status.coolingDown': '',
              'queue.status.failed': '',
              'queue.status.canceled': '',
              'queue.historyTitle': ' (20)',
              'queue.emptyActive': '',
              'queue.emptyQueued': '',
              'queue.noHistory': '',
              'queue.noLogs': '',
              'queue.defaultJob': '',
              'queue.stableTitle': '',
              'queue.stableSummary': ' {{queued}}/{{limit}}   {{timeout}}',
              'nodes.ariaLabel': '{{title}} ',
              'nodes.load.selectButton': '',
              'nodes.load.empty': '',
              'nodes.load.previewMeta': '{{name}}  {{size}}  {{type}}',
              'nodes.load.unknownType': '',
              'nodes.load.noFile': '',
              'nodes.load.aspectUnknown': '',
              'nodes.mediaPreview.noInput': '',
              'nodes.mediaPreview.waiting': '',
              'nodes.mediaPreview.disconnected': '',
              'nodes.mediaPreview.sourceLabel': ': {{title}}',
              'nodes.mediaPreview.metaUnknown': '',
              'nodes.delete': '',
              'nodes.status.connected': '',
              'nodes.status.missing': '',
              'nodes.trim.tip': 'IN/OUT',
              'nodes.trim.imageButton': '',
              'nodes.trim.videoButton': '',
              'nodes.trim.status.empty': '',
              'nodes.trim.status.imageEdited': '',
              'nodes.trim.status.videoEdited': '',
              'nodes.trim.status.imageSummary': ' {{width}}%  {{height}}% ',
              'nodes.trim.status.videoSummary': ' {{start}}  {{end}}{{strict}}',
              'nodes.trim.status.videoEndLabel': '',
              'nodes.trim.status.videoStrictSuffix': '',
              'nodes.trim.imageTools.zoomIn': '',
              'nodes.trim.imageTools.zoomOut': '',
              'nodes.trim.imageTools.grid': '',
              'nodes.trim.imageTools.rotateLeft': '',
              'nodes.trim.imageTools.rotateRight': '',
              'nodes.trim.imageTools.flipHorizontal': '',
              'nodes.trim.imageTools.flipHorizontalShort': '',
              'nodes.trim.imageTools.flipVertical': '',
              'nodes.trim.imageTools.flipVerticalShort': '',
              'nodes.trim.imageTools.reset': '',
              'nodes.trim.imageControls.rotation': '',
              'nodes.trim.imageControls.zoom': '',
              'nodes.trim.imageControls.aspect': '',
              'nodes.trim.imageControls.aspectOption.free': '',
              'nodes.trim.imageControls.aspectOption.original': '',
              'nodes.trim.imageControls.aspectOption.square': '',
              'nodes.trim.imageControls.aspectOption.4:3': '4:3',
              'nodes.trim.imageControls.aspectOption.16:9': '16:9',
              'nodes.trim.imageControls.aspectOption.9:16': '9:16',
              'nodes.trim.modalPlaceholder.image': '',
              'nodes.trim.modalPlaceholder.video': 'IN/OUT',
              'nodes.trim.modalPlaceholder.noImage': '',
              'nodes.trim.toast.imageSaved': '',
              'nodes.trim.toast.videoSaved': '',
              'nodes.mediaPreview.trimmedBadge': '',
              'nodes.mediaPreview.trimmedRange': ' {{start}}  {{end}}{{strict}}',
              'nodes.mediaPreview.trimmedCrop': ' {{width}}%  {{height}}%',
              'nodes.trim.modalPlaceholder.noVideo': '',
              'nodes.trim.modalHint.video': 'IN/OUT',
              'nodes.trim.video.previewFallback': '',
              'nodes.trim.video.startLabel': '',
              'nodes.trim.video.endLabel': '',
              'nodes.trim.video.durationUnknown': '',
              'nodes.trim.video.strictLabel': '',
              'nodes.trim.video.strictHint': '',
              'nodes.trim.video.controls.play': '',
              'nodes.trim.video.controls.pause': '',
              'nodes.trim.video.controls.stepBack': '1',
              'nodes.trim.video.controls.stepForward': '1',
              'nodes.trim.video.startHandle': '',
              'nodes.trim.video.endHandle': '',
              'nodes.resize.tip': '',
              'nodes.overlay.tip': '',
              'nodes.text.tip': 'GPU',
              'nodes.crop.tip': '',
              'nodes.speed.tip': '',
              'nodes.changeFps.tip': 'FPS',
              'nodes.export.tip': '',
              'ports.inputsLabel': '{{title}} ',
              'ports.outputsLabel': '{{title}} ',
              'ports.emptyInputs': '',
              'ports.emptyOutputs': '',
              'ports.direction.input': '',
              'ports.direction.output': '',
              'ports.portLabel': '{{direction}} {{label}} ({{dataType}})',
              'connections.title': '',
              'connections.ariaLabel': '',
              'connections.empty': '',
              'connections.ready': '',
              'connections.remove': '',
              'connections.itemLabel': '{{from}}  {{to}}',
              'connections.pending': '{{from}} ',
              'diagnostics.ariaLabel': '',
              'diagnostics.title': ' & ',
              'diagnostics.crashConsent': '',
              'diagnostics.passwordPlaceholder': '',
              'diagnostics.exportButton': '',
              'diagnostics.inspectHistoryTitle': 'inspect (20)',
              'diagnostics.noExport': '',
              'diagnostics.lastExport': ': {{path}} (SHA {{sha}})',
              'diagnostics.unknownSha': '',
              'diagnostics.historyEmpty': '',
              'diagnostics.noDetails': '',
              'diagnostics.defaultToken': '?',
              'diagnostics.clipCount': '{{count}} ',
              'diagnostics.defaultPath': '',
              'json.banner': 'JSON/schemaVersion=1.0.7 ',
              'json.export': 'JSON',
              'json.import': 'JSON',
              'json.editorLabel': 'JSON',
              'canvas.ariaLabel': '',
              'canvas.controls': '',
              'canvas.toolSelectTooltip': ' (V)',
              'canvas.toolPanTooltip': ' (H)',
              'canvas.fitViewTooltip': ' (.)',
              'canvas.zoomDisplayLabel': ': + / +Shift+  : += / +Shift+=',
              'canvas.zoomIn': ' (+ / +Shift+)',
              'canvas.zoomOut': ' (+= / +Shift+=)',
              'canvas.zoomToFit': '',
              'canvas.zoomApply': '',
              'canvas.zoomInputLabel': ' %',
              'canvas.zoomInputPlaceholder': ': 150',
              'toast.queueRefreshFailed': ': {{message}}',
              'toast.demoJobMissing': 'API',
              'toast.demoJobAdded': '',
              'toast.queueFull': '{{code}}: ',
              'toast.demoJobFailed': ': {{reason}}',
              'toast.cancelAll': '',
              'toast.mediaSelected': '{{name}} ',
              'toast.mediaFailed': '',
              'toast.mediaWrongTypeImage': '',
              'toast.mediaWrongTypeVideo': '',
              'toast.exportMissing': 'Export API',
              'toast.exportFailed': ': {{reason}}',
              'toast.logsExported': ' {{path}}{{shaSuffix}} ',
              'toast.logsExportedSha': ' (SHA256: {{sha}})',
              'toast.crashOn': '',
              'toast.crashOff': '',
              'errors.schemaMissing': 'schemaVersion ',
              'errors.jsonLoadFailed': 'JSON: {{reason}}',
              'about.title': '',
              'about.ariaLabel': '',
              'about.distributionLabel': 'FFmpeg',
              'about.licenseLabel': '',
              'about.pathLabel': 'FFmpeg',
              'about.versionLabel': 'FFmpeg',
              'about.origin.bundled': 'NodeVision (LGPL)',
              'about.origin.external': '/',
              'about.noticeBundled': 'NodeVisionLGPL v2.1+FFmpeg',
              'about.noticeExternal': 'FFmpeg: {{license}}',
              'about.licenseLinkLabel': '',
              'about.sourceLinkLabel': 'FFmpeg',
              'about.versionUnknown': '',
              'about.licenseValue.lgpl': 'LGPL v2.1+',
              'about.licenseValue.gpl': 'GPL v3+',
              'about.licenseValue.nonfree': ' (--enable-nonfree)',
              'about.licenseValue.unknown': '',
              'nodeTemplate.loadMedia.title': '',
              'nodeTemplate.loadMedia.description': '',
              'nodeTemplate.loadMedia.port.media': '',
              'nodeTemplate.loadImage.title': '',
              'nodeTemplate.loadImage.description': '',
              'nodeTemplate.loadImage.port.media': '',
              'nodeTemplate.loadVideo.title': '',
              'nodeTemplate.loadVideo.description': '',
              'nodeTemplate.loadVideo.port.media': '',
              'nodeTemplate.mediaPreview.title': '',
              'nodeTemplate.mediaPreview.description': '',
              'nodeTemplate.mediaPreview.port.source': '',
              'nodeTemplate.trim.title': '',
              'nodeTemplate.trim.description': 'IN/OUT',
              'nodeTemplate.trim.port.source': '',
              'nodeTemplate.trim.port.result': '',
              'nodeTemplate.resize.title': '',
              'nodeTemplate.resize.description': '',
              'nodeTemplate.resize.port.source': '',
              'nodeTemplate.resize.port.resized': '',
              'nodeTemplate.overlay.title': '',
              'nodeTemplate.overlay.description': '2',
              'nodeTemplate.overlay.port.base': '',
              'nodeTemplate.overlay.port.layer': '',
              'nodeTemplate.overlay.port.composite': '',
              'nodeTemplate.text.title': '',
              'nodeTemplate.text.description': '',
              'nodeTemplate.text.port.background': '',
              'nodeTemplate.text.port.titled': '',
              'nodeTemplate.crop.title': '',
              'nodeTemplate.crop.description': '',
              'nodeTemplate.crop.port.source': '',
              'nodeTemplate.crop.port.cropped': '',
              'nodeTemplate.speed.title': '',
              'nodeTemplate.speed.description': '/',
              'nodeTemplate.speed.port.source': '',
              'nodeTemplate.speed.port.retimed': '',
              'nodeTemplate.changeFps.title': '',
              'nodeTemplate.changeFps.description': '',
              'nodeTemplate.changeFps.port.source': '',
              'nodeTemplate.changeFps.port.normalized': '',
              'nodeTemplate.export.title': '',
              'nodeTemplate.export.description': '',
              'nodeTemplate.export.port.program': '',
              'nodeTemplate.export.port.delivery': '',
              'demo.jobName': 'FFmpeg '
          }
      };

        },
        './nodes/change-fps': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createChangeFpsNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createChangeFpsNodeRenderer = (context) => ({
          id: 'change-fps-info',
          typeIds: ['changeFps'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.changeFps.tip' })
          })
      });
      exports.createChangeFpsNodeRenderer = createChangeFpsNodeRenderer;

        },
        './nodes/crop': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createCropNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createCropNodeRenderer = (context) => ({
          id: 'crop-info',
          typeIds: ['crop'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.crop.tip' })
          })
      });
      exports.createCropNodeRenderer = createCropNodeRenderer;

        },
        './nodes/export-node': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createExportNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createExportNodeRenderer = (context) => ({
          id: 'export-info',
          typeIds: ['export'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.export.tip' })
          })
      });
      exports.createExportNodeRenderer = createExportNodeRenderer;

        },
        './nodes/index': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createNodeRenderers = void 0;
      const load_1 = require("./load");
      const trim_1 = require("./trim");
      const resize_1 = require("./resize");
      const overlay_1 = require("./overlay");
      const text_1 = require("./text");
      const crop_1 = require("./crop");
      const speed_1 = require("./speed");
      const change_fps_1 = require("./change-fps");
      const export_node_1 = require("./export-node");
      const media_preview_1 = require("./media-preview");
      const createNodeRenderers = (context) => [
          (0, load_1.createLoadNodeRenderer)(context),
          (0, trim_1.createTrimNodeRenderer)(context),
          (0, resize_1.createResizeNodeRenderer)(context),
          (0, overlay_1.createOverlayNodeRenderer)(context),
          (0, text_1.createTextNodeRenderer)(context),
          (0, crop_1.createCropNodeRenderer)(context),
          (0, speed_1.createSpeedNodeRenderer)(context),
          (0, change_fps_1.createChangeFpsNodeRenderer)(context),
          (0, export_node_1.createExportNodeRenderer)(context),
          (0, media_preview_1.createMediaPreviewNodeRenderer)(context)
      ];
      exports.createNodeRenderers = createNodeRenderers;

        },
        './nodes/load': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createLoadNodeRenderer = void 0;
      const preview_layout_1 = require("./preview-layout");
      const preview_size_1 = require("./preview-size");
      const LOAD_NODE_TYPES = ['loadImage', 'loadVideo', 'loadMedia'];
      const IMAGE_LOAD_TYPES = new Set(['loadImage', 'loadMedia']);
      const VIDEO_EXTENSIONS = new Set(['mp4', 'mov', 'm4v', 'mkv', 'webm', 'avi', 'flv']);
      const getLoadNodeKindFromType = (typeId) => {
          if (typeId === 'loadVideo') {
              return 'video';
          }
          if (IMAGE_LOAD_TYPES.has(typeId)) {
              return 'image';
          }
          return 'any';
      };
      const inferMediaKind = (file) => {
          if (file.type?.startsWith('video/')) {
              return 'video';
          }
          if (file.type?.startsWith('image/')) {
              return 'image';
          }
          const ext = file.name?.split('.').pop()?.toLowerCase() ?? '';
          if (VIDEO_EXTENSIONS.has(ext)) {
              return 'video';
          }
          return 'image';
      };
      let measurementContainer = null;
      const getMeasurementContainer = () => {
          if (!document?.body) {
              return null;
          }
          if (measurementContainer && document.body.contains(measurementContainer)) {
              return measurementContainer;
          }
          measurementContainer = document.createElement('div');
          measurementContainer.id = 'nodevision-media-measurements';
          Object.assign(measurementContainer.style, {
              position: 'fixed',
              width: '1px',
              height: '1px',
              overflow: 'hidden',
              pointerEvents: 'none',
              opacity: '0',
              zIndex: '-1'
          });
          document.body.appendChild(measurementContainer);
          return measurementContainer;
      };
      const createLoadNodeRenderer = (context) => {
          const { state, t, escapeHtml, showToast, renderNodes, cleanupMediaPreview, updateMediaPreviewDimensions, getNodeChromePadding, getPreviewWidthForNodeWidth, getPreviewAspectRatio, minPreviewHeight, minPreviewWidth } = context;
          const getLoadNodeKindById = (nodeId) => {
              const node = state.nodes.find(item => item.id === nodeId);
              return node ? getLoadNodeKindFromType(node.typeId) : 'any';
          };
          const measureImageDimensions = (nodeId, file, url) => {
              if (typeof window.createImageBitmap === 'function') {
                  void window
                      .createImageBitmap(file)
                      .then(bitmap => {
                      updateMediaPreviewDimensions(nodeId, bitmap.width, bitmap.height);
                      if (typeof bitmap.close === 'function') {
                          bitmap.close();
                      }
                  })
                      .catch(() => {
                      const img = new Image();
                      img.decoding = 'async';
                      img.onload = () => {
                          updateMediaPreviewDimensions(nodeId, img.naturalWidth || img.width, img.naturalHeight || img.height);
                          img.src = '';
                      };
                      img.onerror = () => {
                          updateMediaPreviewDimensions(nodeId, null, null);
                      };
                      img.src = url;
                  });
                  return;
              }
              const fallbackImg = new Image();
              fallbackImg.decoding = 'async';
              fallbackImg.onload = () => {
                  updateMediaPreviewDimensions(nodeId, fallbackImg.naturalWidth || fallbackImg.width, fallbackImg.naturalHeight || fallbackImg.height);
                  fallbackImg.src = '';
              };
              fallbackImg.onerror = () => {
                  updateMediaPreviewDimensions(nodeId, null, null);
              };
              fallbackImg.src = url;
          };
          const measureVideoDimensions = (nodeId, url) => {
              const video = document.createElement('video');
              video.preload = 'metadata';
              video.muted = true;
              video.playsInline = true;
              video.controls = false;
              video.setAttribute('aria-hidden', 'true');
              Object.assign(video.style, {
                  position: 'fixed',
                  left: '-9999px',
                  top: '-9999px',
                  width: '1px',
                  height: '1px',
                  pointerEvents: 'none'
              });
              const container = getMeasurementContainer();
              if (container) {
                  container.appendChild(video);
              }
              const cleanup = (warn) => {
                  video.onloadedmetadata = null;
                  video.onerror = null;
                  try {
                      video.pause();
                  }
                  catch (error) {
                      console.warn('[NodeVision] video pause failed', error);
                  }
                  video.removeAttribute('src');
                  try {
                      video.load();
                  }
                  catch (error) {
                      console.warn('[NodeVision] video load reset failed', error);
                  }
                  if (video.parentNode) {
                      video.parentNode.removeChild(video);
                  }
                  if (warn) {
                      console.warn('[NodeVision]', warn);
                  }
              };
              video.onloadedmetadata = () => {
                  const durationMs = Number.isFinite(video.duration) && video.duration > 0 ? Math.round(video.duration * 1000) : null;
                  updateMediaPreviewDimensions(nodeId, video.videoWidth || null, video.videoHeight || null, {
                      durationMs
                  });
                  cleanup();
              };
              video.onerror = () => {
                  updateMediaPreviewDimensions(nodeId, null, null, { durationMs: null });
                  cleanup('Failed to read video metadata for preview');
              };
              try {
                  video.src = url;
                  video.load();
              }
              catch (error) {
                  cleanup('Unable to schedule video metadata probe');
              }
          };
          const ingestMediaFile = (nodeId, file) => {
              const mode = getLoadNodeKindById(nodeId);
              const kind = inferMediaKind(file);
              if (mode === 'image' && kind !== 'image') {
                  showToast(t('toast.mediaWrongTypeImage'), 'error');
                  return;
              }
              if (mode === 'video' && kind !== 'video') {
                  showToast(t('toast.mediaWrongTypeVideo'), 'error');
                  return;
              }
              if (typeof URL?.createObjectURL !== 'function') {
                  console.error('[NodeVision] URL.createObjectURL unavailable for media preview');
                  showToast(t('toast.mediaFailed'), 'error');
                  return;
              }
              cleanupMediaPreview(nodeId);
              let objectUrl;
              try {
                  objectUrl = URL.createObjectURL(file);
              }
              catch (error) {
                  console.error('[NodeVision] failed to create preview URL', error);
                  showToast(t('toast.mediaFailed'), 'error');
                  return;
              }
              const fallbackType = file.name?.split('.').pop()?.toUpperCase() ?? '';
              const resolvedType = file.type || fallbackType;
              state.mediaPreviews.set(nodeId, {
                  url: objectUrl,
                  name: file.name || 'media',
                  size: file.size ?? 0,
                  type: resolvedType,
                  kind,
                  width: null,
                  height: null,
                  ownedUrl: true
              });
              renderNodes();
              if (kind === 'image') {
                  measureImageDimensions(nodeId, file, objectUrl);
              }
              else {
                  measureVideoDimensions(nodeId, objectUrl);
              }
              if (file.name) {
                  showToast(t('toast.mediaSelected', { name: file.name }));
              }
          };
          const handleMediaInputChange = (nodeId, input) => {
              if (state.readonly) {
                  input.value = '';
                  return;
              }
              const file = input.files?.[0];
              if (!file) {
                  input.value = '';
                  return;
              }
              ingestMediaFile(nodeId, file);
              input.value = '';
          };
          const buildLoadNodeMediaSection = (node) => {
              const nodeId = node.id;
              const preview = state.mediaPreviews.get(nodeId);
              const nodeSize = state.nodeSizes.get(nodeId) ?? { width: 0, height: 0 };
              const chrome = getNodeChromePadding(nodeId);
              const reservedHeight = (0, preview_layout_1.getLoadNodeReservedHeight)(Boolean(preview));
              const nodeKind = getLoadNodeKindFromType(node.typeId);
              const ratio = getPreviewAspectRatio(nodeId);
              const widthLimit = getPreviewWidthForNodeWidth(nodeSize.width);
              const previewBox = (0, preview_size_1.calculatePreviewSize)({
                  nodeWidth: nodeSize.width || node.width || 0,
                  nodeHeight: nodeSize.height || node.height || 0,
                  chromePadding: chrome,
                  reservedHeight,
                  widthLimit,
                  minHeight: minPreviewHeight,
                  minWidth: minPreviewWidth,
                  aspectRatio: ratio,
                  originalWidth: preview?.width ?? null,
                  originalHeight: preview?.height ?? null,
                  minimumNodePortion: 0.85
              });
              const inlineStyle = ` style="--preview-width:${previewBox.width}px;--preview-height:${previewBox.height}px"`;
              const acceptAttr = nodeKind === 'image' ? 'image/*' : nodeKind === 'video' ? 'video/*' : 'image/*,video/*';
              const disabledAttr = state.readonly ? 'disabled' : '';
              const uploadControl = `
            <label class="node-media-upload${state.readonly ? ' disabled' : ''}">
              <span>${escapeHtml(t('nodes.load.selectButton'))}</span>
              <input type="file" accept="${acceptAttr}" ${disabledAttr} data-media-input="${escapeHtml(nodeId)}" />
            </label>
          `;
              const fileLabel = escapeHtml(preview?.name ?? t('nodes.load.noFile'));
              const aspectText = preview?.width && preview?.height
                  ? `${preview.width}  ${preview.height}`
                  : t('nodes.load.aspectUnknown');
              const aspectHtml = `<p class="node-media-aspect">${escapeHtml(aspectText)}</p>`;
              const toolbar = `
            <div class="node-media-toolbar">
              <button type="button" class="node-media-arrow" disabled aria-hidden="true"></button>
              <span class="node-media-filename" title="${fileLabel}">${fileLabel}</span>
              <button type="button" class="node-media-arrow" disabled aria-hidden="true"></button>
            </div>
          `;
              if (!preview) {
                  return `<div class="node-media" data-node-id="${escapeHtml(nodeId)}"${inlineStyle}>
              ${toolbar}
              ${uploadControl}
              <p class="node-media-empty">${escapeHtml(t('nodes.load.empty'))}</p>
              ${aspectHtml}
            </div>`;
              }
              const kind = preview.kind === 'video' ? 'video' : 'image';
              const mediaTag = kind === 'video'
                  ? `<video src="${preview.url}" controls playsinline preload="metadata" muted></video>`
                  : `<img src="${preview.url}" alt="${escapeHtml(preview.name)}" />`;
              return `<div class="node-media" data-node-id="${escapeHtml(nodeId)}"${inlineStyle}>
            ${toolbar}
            ${uploadControl}
            <div class="node-media-frame">
              <div class="node-media-preview" data-kind="${kind}">
                ${mediaTag}
              </div>
            </div>
            ${aspectHtml}
          </div>`;
          };
          const renderMediaSection = (node) => ({
              afterPortsHtml: buildLoadNodeMediaSection(node),
              afterRender: element => {
                  element
                      .querySelectorAll('input[data-media-input]')
                      .forEach(input => input.addEventListener('change', () => handleMediaInputChange(node.id, input)));
              }
          });
          return {
              id: 'load-media',
              typeIds: LOAD_NODE_TYPES,
              render: renderMediaSection,
              onBeforeNodeRemove: (nodeId) => {
                  cleanupMediaPreview(nodeId);
              }
          };
      };
      exports.createLoadNodeRenderer = createLoadNodeRenderer;

        },
        './nodes/media-preview': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMediaPreviewNodeRenderer = void 0;
      const preview_layout_1 = require("./preview-layout");
      const preview_size_1 = require("./preview-size");
      const trim_shared_1 = require("./trim-shared");
      const MEDIA_PREVIEW_NODE_TYPE = 'mediaPreview';
      const resolveNodeTitle = (node, context) => {
          if (!node) {
              return context.t('nodes.mediaPreview.disconnected');
          }
          const key = `nodeTemplate.${node.typeId}.title`;
          const translated = context.t(key);
          if (translated && translated !== key) {
              return translated;
          }
          return node.title ?? node.typeId;
      };
      const createMediaPreviewNodeRenderer = (context) => {
          const { state, t, escapeHtml, getNodeChromePadding, getPreviewWidthForNodeWidth, getPreviewAspectRatio, minPreviewHeight, minPreviewWidth, getMediaPreview } = context;
          const buildTrimHints = (sourceNode) => {
              if (!sourceNode || sourceNode.typeId !== 'trim') {
                  return null;
              }
              const settings = (0, trim_shared_1.ensureTrimSettings)(sourceNode);
              const region = settings.region ?? { x: 0, y: 0, width: 1, height: 1 };
              const hasImageEdit = region.x !== 0 || region.y !== 0 || region.width !== 1 || region.height !== 1;
              const hasVideoEdit = settings.startMs !== null || settings.endMs !== null || settings.strictCut;
              if (!hasImageEdit && !hasVideoEdit) {
                  return null;
              }
              const messages = [];
              if (hasImageEdit) {
                  messages.push(t('nodes.mediaPreview.trimmedCrop', {
                      width: Math.round(region.width * 100),
                      height: Math.round(region.height * 100)
                  }));
              }
              if (hasVideoEdit) {
                  const startLabel = (0, trim_shared_1.formatTrimTimecode)(settings.startMs ?? 0);
                  const endLabel = settings.endMs === null ? t('nodes.trim.status.videoEndLabel') : (0, trim_shared_1.formatTrimTimecode)(settings.endMs);
                  const strictSuffix = settings.strictCut ? ` ${t('nodes.trim.status.videoStrictSuffix')}` : '';
                  messages.push(t('nodes.mediaPreview.trimmedRange', {
                      start: startLabel,
                      end: endLabel,
                      strict: strictSuffix
                  }));
              }
              return { badge: t('nodes.mediaPreview.trimmedBadge'), messages };
          };
          const buildPreviewSection = (node) => {
              const connection = state.connections.find(conn => conn.toNodeId === node.id && conn.toPortId === 'source');
              const sourceNodeId = connection?.fromNodeId ?? null;
              const sourceNode = sourceNodeId ? state.nodes.find(entry => entry.id === sourceNodeId) : undefined;
              const preview = sourceNodeId ? getMediaPreview(sourceNodeId) : undefined;
              const nodeSize = state.nodeSizes.get(node.id) ?? { width: node.width ?? 0, height: node.height ?? 0 };
              const chrome = getNodeChromePadding(node.id);
              const nodeWidth = nodeSize.width || node.width || 0;
              const nodeHeight = nodeSize.height || node.height || 0;
              const reservedHeight = (0, preview_layout_1.getMediaPreviewReservedHeight)(Boolean(preview));
              const widthLimit = getPreviewWidthForNodeWidth(Math.max(nodeWidth, 0));
              const ratio = getPreviewAspectRatio(sourceNodeId ?? node.id);
              const previewBox = (0, preview_size_1.calculatePreviewSize)({
                  nodeWidth,
                  nodeHeight,
                  chromePadding: chrome,
                  reservedHeight,
                  widthLimit,
                  minHeight: minPreviewHeight,
                  minWidth: minPreviewWidth,
                  aspectRatio: ratio,
                  originalWidth: preview?.width ?? null,
                  originalHeight: preview?.height ?? null,
                  minimumNodePortion: 0.95
              });
              const inlineStyle = ` style="--preview-width:${previewBox.width}px;--preview-height:${previewBox.height}px"`;
              const sourceTitle = resolveNodeTitle(sourceNode, context);
              const fileLabel = escapeHtml(preview?.name ?? sourceTitle);
              const trimHints = buildTrimHints(sourceNode);
              const trimHintHtml = trimHints
                  ? `
              <div class="node-media-hints">
                <p class="node-media-hint accent">${escapeHtml(trimHints.badge)}</p>
                ${trimHints.messages.map(message => `<p class="node-media-hint">${escapeHtml(message)}</p>`).join('')}
              </div>
            `
                  : '';
              const toolbar = `
            <div class="node-media-toolbar">
              <span class="node-media-filename" title="${fileLabel}">${fileLabel}</span>
            </div>
            <p class="node-media-aspect">${escapeHtml(t('nodes.mediaPreview.sourceLabel', { title: sourceTitle }))}</p>
            ${trimHintHtml}
          `;
              const aspectText = preview?.width && preview?.height
                  ? `${preview.width}  ${preview.height}`
                  : t('nodes.mediaPreview.metaUnknown');
              const aspectHtml = `<p class="node-media-aspect">${escapeHtml(aspectText)}</p>`;
              if (!preview) {
                  const messageKey = sourceNodeId ? 'nodes.mediaPreview.waiting' : 'nodes.mediaPreview.noInput';
                  return `<div class="node-media" data-node-id="${escapeHtml(node.id)}"${inlineStyle}>
              ${toolbar}
              <p class="node-media-empty">${escapeHtml(t(messageKey))}</p>
              ${aspectHtml}
            </div>`;
              }
              const kind = preview.kind === 'video' ? 'video' : 'image';
              const mediaTag = kind === 'video'
                  ? `<video src="${preview.url}" controls playsinline preload="metadata" muted></video>`
                  : `<img src="${preview.url}" alt="${escapeHtml(preview.name)}" />`;
              return `<div class="node-media" data-node-id="${escapeHtml(node.id)}"${inlineStyle}>
            ${toolbar}
            <div class="node-media-frame">
              <div class="node-media-preview" data-kind="${kind}">
                ${mediaTag}
              </div>
            </div>
            ${aspectHtml}
          </div>`;
          };
          const render = (node) => ({
              afterPortsHtml: buildPreviewSection(node)
          });
          return {
              id: 'media-preview',
              typeIds: [MEDIA_PREVIEW_NODE_TYPE],
              render
          };
      };
      exports.createMediaPreviewNodeRenderer = createMediaPreviewNodeRenderer;

        },
        './nodes/overlay': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createOverlayNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createOverlayNodeRenderer = (context) => ({
          id: 'overlay-info',
          typeIds: ['overlay'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.overlay.tip' })
          })
      });
      exports.createOverlayNodeRenderer = createOverlayNodeRenderer;

        },
        './nodes/preview-layout': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getMediaPreviewReservedHeight = exports.getLoadNodeReservedHeight = void 0;
      const getLoadNodeReservedHeight = (hasPreview) => hasPreview ? 120 : 150;
      exports.getLoadNodeReservedHeight = getLoadNodeReservedHeight;
      const getMediaPreviewReservedHeight = (hasPreview) => hasPreview ? 80 : 110;
      exports.getMediaPreviewReservedHeight = getMediaPreviewReservedHeight;

        },
        './nodes/preview-size': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.calculatePreviewSize = void 0;
      const SAFE_RATIO_FALLBACK = 0.01;
      const MAX_RATIO = 4;
      const MIN_RATIO = 0.25;
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const calculatePreviewSize = (input) => {
          const { nodeWidth, nodeHeight, chromePadding, reservedHeight, widthLimit, minHeight, minWidth, aspectRatio, originalWidth, originalHeight, minimumNodePortion = 0.6 } = input;
          const safeRatio = clamp(Math.abs(aspectRatio) || SAFE_RATIO_FALLBACK, MIN_RATIO, MAX_RATIO);
          const availableWidth = Math.max(0, Math.min(widthLimit, nodeWidth));
          const baseHeight = nodeHeight * minimumNodePortion;
          const availableHeight = Math.max(baseHeight, nodeHeight - chromePadding - reservedHeight);
          if (availableWidth === 0 || availableHeight === 0) {
              return { width: 0, height: 0 };
          }
          const originalWidthLimit = originalWidth && originalWidth > 0 ? originalWidth : Number.POSITIVE_INFINITY;
          const originalHeightLimit = originalHeight && originalHeight > 0 ? originalHeight : Number.POSITIVE_INFINITY;
          const maxWidth = Math.min(availableWidth, originalWidthLimit);
          const maxHeight = Math.min(availableHeight, originalHeightLimit);
          const minHeightClamp = Math.min(maxHeight, Math.max(minHeight, 0));
          const minWidthClamp = Math.min(maxWidth, Math.max(minWidth, 0));
          const applyWidthLimits = (widthValue) => clamp(widthValue, minWidthClamp || 0, maxWidth);
          const applyHeightLimits = (heightValue) => clamp(heightValue, minHeightClamp || 0, maxHeight);
          let width = maxWidth;
          let height = width / safeRatio;
          if (height > maxHeight) {
              height = maxHeight;
              width = height * safeRatio;
          }
          if (height < minHeightClamp) {
              height = minHeightClamp;
              width = height * safeRatio;
              if (width > maxWidth) {
                  width = maxWidth;
                  height = width / safeRatio;
              }
          }
          width = applyWidthLimits(width);
          height = applyHeightLimits(width / safeRatio);
          if (height > maxHeight) {
              height = maxHeight;
              width = height * safeRatio;
              width = applyWidthLimits(width);
          }
          return {
              width: Math.max(0, width),
              height: Math.max(0, height)
          };
      };
      exports.calculatePreviewSize = calculatePreviewSize;

        },
        './nodes/resize': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createResizeNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createResizeNodeRenderer = (context) => ({
          id: 'resize-info',
          typeIds: ['resize'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.resize.tip' })
          })
      });
      exports.createResizeNodeRenderer = createResizeNodeRenderer;

        },
        './nodes/shared': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.buildNodeInfoSection = void 0;
      const translateOrFallback = (key, fallback, t) => {
          const translated = t(key);
          return translated === key ? fallback : translated;
      };
      const escape = (value, context) => context.escapeHtml(value);
      const buildNodeInfoSection = (node, context, options = {}) => {
          const { state, t, getTemplateByType } = context;
          const template = getTemplateByType(node.typeId);
          const title = translateOrFallback(`nodeTemplate.${node.typeId}.title`, node.title, t);
          const description = translateOrFallback(`nodeTemplate.${node.typeId}.description`, template?.description ?? '', t);
          const ports = template?.inputs ?? node.inputs ?? [];
          const statuses = ports
              .map(port => {
              const portLabel = translateOrFallback(`nodeTemplate.${node.typeId}.port.${port.id}`, port.label, t);
              const connected = state.connections.some(connection => connection.toNodeId === node.id && connection.toPortId === port.id);
              const statusLabel = translateOrFallback(connected ? 'nodes.status.connected' : 'nodes.status.missing', connected ? 'Connected' : 'Missing', t);
              return `<div class="node-status"><span class="node-status-label">${escape(portLabel, context)}</span><span class="node-status-value">${escape(statusLabel, context)}</span></div>`;
          })
              .join('');
          const tip = options.tipKey && options.tipKey.length
              ? `<p class="node-info-tip">${escape(translateOrFallback(options.tipKey, options.tipKey, t), context)}</p>`
              : '';
          const extra = options.extraHtml ?? '';
          if (!statuses && !tip && !extra) {
              return '';
          }
          const descriptionHtml = description
              ? `<p class="node-info-desc">${escape(description, context)}</p>`
              : '';
          return `<section class="node-info">
          <div class="node-info-heading">${escape(title, context)}</div>
          ${descriptionHtml}
          ${statuses}
          ${tip}
          ${extra}
        </section>`;
      };
      exports.buildNodeInfoSection = buildNodeInfoSection;

        },
        './nodes/speed': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createSpeedNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createSpeedNodeRenderer = (context) => ({
          id: 'speed-info',
          typeIds: ['speed'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.speed.tip' })
          })
      });
      exports.createSpeedNodeRenderer = createSpeedNodeRenderer;

        },
        './nodes/text': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createTextNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const createTextNodeRenderer = (context) => ({
          id: 'text-info',
          typeIds: ['text'],
          render: node => ({
              afterPortsHtml: (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.text.tip' })
          })
      });
      exports.createTextNodeRenderer = createTextNodeRenderer;

        },
        './nodes/trim': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createTrimNodeRenderer = void 0;
      const shared_1 = require("./shared");
      const trim_shared_1 = require("./trim-shared");
      const buildStatusLabel = (node, context) => {
          const settings = (0, trim_shared_1.ensureTrimSettings)(node);
          const { t } = context;
          const region = settings.region ?? { x: 0, y: 0, width: 1, height: 1 };
          const hasImageEdit = region.x !== 0 || region.y !== 0 || region.width !== 1 || region.height !== 1;
          const hasVideoEdit = settings.startMs !== null || settings.endMs !== null || settings.strictCut;
          if (!hasImageEdit && !hasVideoEdit) {
              return t('nodes.trim.status.empty');
          }
          const parts = [];
          if (hasImageEdit) {
              const widthPct = Math.round(region.width * 100);
              const heightPct = Math.round(region.height * 100);
              parts.push(t('nodes.trim.status.imageSummary', { width: widthPct, height: heightPct }));
          }
          if (hasVideoEdit) {
              const startLabel = (0, trim_shared_1.formatTrimTimecode)(settings.startMs ?? 0);
              const endLabel = settings.endMs === null ? t('nodes.trim.status.videoEndLabel') : (0, trim_shared_1.formatTrimTimecode)(settings.endMs);
              const strictSuffix = settings.strictCut ? ` ${t('nodes.trim.status.videoStrictSuffix')}` : '';
              parts.push(t('nodes.trim.status.videoSummary', { start: startLabel, end: endLabel, strict: strictSuffix }));
          }
          return parts.join(' / ');
      };
      const buildLauncher = (node, context) => {
          const { escapeHtml, t } = context;
          return `
          <section class="trim-launcher" data-trim-node="${escapeHtml(node.id)}">
            <div class="trim-launcher-buttons">
              <button type="button" class="trim-launcher-btn" data-trim-launch="image" data-node-interactive="true">
                ${escapeHtml(t('nodes.trim.imageButton'))}
              </button>
              <button type="button" class="trim-launcher-btn" data-trim-launch="video" data-node-interactive="true">
                ${escapeHtml(t('nodes.trim.videoButton'))}
              </button>
            </div>
            <p class="trim-launcher-status">${escapeHtml(buildStatusLabel(node, context))}</p>
          </section>
        `;
      };
      const bindLauncher = (panel, node, context) => {
          panel.querySelectorAll('[data-trim-launch]').forEach(button => {
              button.addEventListener('click', () => {
                  const mode = button.getAttribute('data-trim-launch') ?? 'image';
                  context.openTrimModal(mode, node.id);
              });
          });
      };
      const createTrimNodeRenderer = (context) => ({
          id: 'trim-launcher',
          typeIds: ['trim'],
          render: node => ({
              afterPortsHtml: [
                  buildLauncher(node, context),
                  (0, shared_1.buildNodeInfoSection)(node, context, { tipKey: 'nodes.trim.tip' })
              ].join(''),
              afterRender: element => {
                  const panel = element.querySelector('.trim-launcher');
                  if (panel) {
                      bindLauncher(panel, node, context);
                  }
              }
          })
      });
      exports.createTrimNodeRenderer = createTrimNodeRenderer;

        },
        './nodes/trim-shared': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatTrimTimecode = exports.ensureTrimSettings = exports.DEFAULT_TRIM_SETTINGS = void 0;
      const cloneRegion = (region) => {
          if (!region) {
              return { x: 0, y: 0, width: 1, height: 1 };
          }
          return {
              x: region.x ?? 0,
              y: region.y ?? 0,
              width: region.width ?? 1,
              height: region.height ?? 1
          };
      };
      exports.DEFAULT_TRIM_SETTINGS = {
          kind: 'trim',
          startMs: null,
          endMs: null,
          strictCut: false,
          region: { x: 0, y: 0, width: 1, height: 1 },
          rotationDeg: 0,
          zoom: 1,
          flipHorizontal: false,
          flipVertical: false,
          aspectMode: 'free'
      };
      const cloneSettings = () => ({
          kind: 'trim',
          startMs: exports.DEFAULT_TRIM_SETTINGS.startMs,
          endMs: exports.DEFAULT_TRIM_SETTINGS.endMs,
          strictCut: exports.DEFAULT_TRIM_SETTINGS.strictCut,
          region: cloneRegion(exports.DEFAULT_TRIM_SETTINGS.region),
          rotationDeg: exports.DEFAULT_TRIM_SETTINGS.rotationDeg,
          zoom: exports.DEFAULT_TRIM_SETTINGS.zoom,
          flipHorizontal: exports.DEFAULT_TRIM_SETTINGS.flipHorizontal,
          flipVertical: exports.DEFAULT_TRIM_SETTINGS.flipVertical,
          aspectMode: exports.DEFAULT_TRIM_SETTINGS.aspectMode
      });
      const ensureTrimSettings = (node) => {
          const current = node.settings;
          if (current && current.kind === 'trim') {
              current.region = cloneRegion(current.region);
              if (typeof current.rotationDeg !== 'number') {
                  current.rotationDeg = exports.DEFAULT_TRIM_SETTINGS.rotationDeg;
              }
              if (typeof current.zoom !== 'number' || Number.isNaN(current.zoom) || current.zoom <= 0) {
                  current.zoom = exports.DEFAULT_TRIM_SETTINGS.zoom;
              }
              if (typeof current.flipHorizontal !== 'boolean') {
                  current.flipHorizontal = exports.DEFAULT_TRIM_SETTINGS.flipHorizontal;
              }
              if (typeof current.flipVertical !== 'boolean') {
                  current.flipVertical = exports.DEFAULT_TRIM_SETTINGS.flipVertical;
              }
              if (current.aspectMode !== 'free' &&
                  current.aspectMode !== 'original' &&
                  current.aspectMode !== 'square' &&
                  current.aspectMode !== '4:3' &&
                  current.aspectMode !== '16:9' &&
                  current.aspectMode !== '9:16') {
                  current.aspectMode = exports.DEFAULT_TRIM_SETTINGS.aspectMode;
              }
              return current;
          }
          const next = cloneSettings();
          node.settings = next;
          return next;
      };
      exports.ensureTrimSettings = ensureTrimSettings;
      const formatTrimTimecode = (value) => {
          if (typeof value !== 'number' || !Number.isFinite(value)) {
              return '00:00.000';
          }
          const positive = Math.max(0, Math.floor(value));
          const minutes = Math.floor(positive / 60000);
          const seconds = Math.floor((positive % 60000) / 1000);
          const millis = positive % 1000;
          return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${millis
              .toString()
              .padStart(3, '0')}`;
      };
      exports.formatTrimTimecode = formatTrimTimecode;

        },
        './nodes/types': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });

        },
        './ports': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.syncPendingPortHighlight = void 0;
      /**
       * UI
       * DOM  aria-pressed  .port-pending 
       */
      const syncPendingPortHighlight = (root, pending) => {
          if (!root)
              return;
          const buttons = root.querySelectorAll('.port[data-direction="output"]');
          buttons.forEach(button => {
              const nodeId = button.getAttribute('data-node-id');
              const portId = button.getAttribute('data-port-id');
              const isMatch = Boolean(pending && nodeId === pending.fromNodeId && portId === pending.fromPortId);
              button.classList.toggle('port-pending', isMatch);
              button.setAttribute('aria-pressed', isMatch ? 'true' : 'false');
          });
      };
      exports.syncPendingPortHighlight = syncPendingPortHighlight;

        },
        './state': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createInitialState = exports.cloneConnection = exports.cloneNode = exports.clonePorts = exports.deepClone = exports.DEFAULT_QUEUE_LIMITS = void 0;
      exports.DEFAULT_QUEUE_LIMITS = {
          maxParallelJobs: 1,
          maxQueueLength: 4,
          queueTimeoutMs: 180000
      };
      const deepClone = (value) => JSON.parse(JSON.stringify(value));
      exports.deepClone = deepClone;
      const clonePorts = (ports) => Array.isArray(ports) ? ports.map(port => ({ ...port })) : [];
      exports.clonePorts = clonePorts;
      const cloneNode = (node) => {
          const copy = (0, exports.deepClone)(node);
          copy.inputs = (0, exports.clonePorts)(copy.inputs);
          copy.outputs = (0, exports.clonePorts)(copy.outputs);
          return copy;
      };
      exports.cloneNode = cloneNode;
      const cloneConnection = (connection) => {
          const copy = (0, exports.deepClone)(connection);
          if (!copy.id) {
              copy.id = crypto?.randomUUID ? crypto.randomUUID() : `connection-${Date.now()}-${Math.floor(Math.random() * 9999)}`;
          }
          return copy;
      };
      exports.cloneConnection = cloneConnection;
      const buildQueueState = (bootstrap) => ({
          active: bootstrap.queue?.active ?? [],
          queued: bootstrap.queue?.queued ?? [],
          history: bootstrap.queue?.history ?? [],
          warnings: bootstrap.queue?.warnings ?? [],
          limits: bootstrap.queue?.limits ?? exports.DEFAULT_QUEUE_LIMITS
      });
      const buildDiagnostics = (bootstrap) => ({
          collectCrashDumps: bootstrap.diagnostics?.collectCrashDumps ?? false,
          lastTokenPreview: bootstrap.diagnostics?.lastTokenPreview ?? null,
          lastLogExportPath: bootstrap.diagnostics?.lastLogExportPath ?? null,
          lastExportSha: bootstrap.diagnostics?.lastExportSha ?? null,
          inspectHistory: bootstrap.diagnostics?.inspectHistory ?? []
      });
      const createInitialState = (bootstrap, locale) => {
          const nodes = (bootstrap.nodes ?? []).map(exports.cloneNode);
          const nodeSizes = new Map();
          nodes.forEach(node => nodeSizes.set(node.id, {
              width: Math.max(336, node.width ?? 336),
              height: Math.max(460, node.height ?? 460)
          }));
          return {
              locale,
              nodes,
              selection: new Set(),
              clipboard: [],
              zoom: 1,
              viewport: { x: 0, y: 0 },
              activeTool: 'select',
              canvasControlsPosition: null,
              history: [],
              historyIndex: -1,
              autosaveTimer: null,
              lastAutosave: null,
              isRunning: false,
              readonly: false,
              queue: buildQueueState(bootstrap),
              diagnostics: buildDiagnostics(bootstrap),
              connections: (bootstrap.connections ?? []).map(exports.cloneConnection),
              pendingConnection: null,
              draggingConnection: null,
              highlightedConnections: new Set(),
              pressedNodeId: null,
              mediaPreviews: new Map(),
              nodeSizes,
              nodeChrome: new Map(),
              resizing: null,
              workflows: [],
              activeWorkflowId: null,
              workflowName: 'Unsaved Workflow',
              workflowDirty: false,
              workflowSearch: '',
              workflowMenuOpen: false,
              workflowContextMenuOpen: false,
              workflowContextTargetId: null
          };
      };
      exports.createInitialState = createInitialState;

        },
        './types': function (exports, require, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });

        }
        };
        const cache = {};
        const splitPath = value => {
          let input = value;
          if (input.startsWith('./')) {
            input = input.slice(2);
          }
          return input.split('/').filter(Boolean);
        };
        const normalize = (from, request) => {
          const base = splitPath(from);
          if (base.length) {
            base.pop();
          }
          const segments = splitPath(request);
          for (const segment of segments) {
            if (!segment || segment === '.') continue;
            if (segment === '..') {
              base.pop();
            } else {
              base.push(segment);
            }
          }
          return './' + base.join('/');
        };
        const resolveId = id => {
          if (modules[id]) {
            return id;
          }
          const indexId = id.endsWith('/index') ? null : id + '/index';
          if (indexId && modules[indexId]) {
            return indexId;
          }
          return null;
        };
        const require = (request, from = './') => {
          const target = request.startsWith('.') ? normalize(from, request) : request;
          const id = resolveId(target);
          if (!id) {
            throw new Error('Renderer module not found: ' + target);
          }
          if (cache[id]) {
            return cache[id].exports;
          }
          const module = { exports: {} };
          cache[id] = module;
          const localRequire = child => require(child, id);
          modules[id](module.exports, localRequire, module);
          return module.exports;
        };
        require('./app', './app');
      })();
    </script>
  </body>
</html>