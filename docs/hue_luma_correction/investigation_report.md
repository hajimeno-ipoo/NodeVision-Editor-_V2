# Hue vs Luma 挙動改善に関する調査報告

## 1. 現状の課題と分析

### 観測された挙動の違い
- **DaVinci Resolve (目標)**:
  - Hue vs Luma カーブを下げると、色がグレーにならずに「深く濃い色」になる。
  - カーブを上げると、色が白っぽくならずに「鮮やかに発光」するような明るさになる。
  - これは、輝度変化に伴って彩度も連動して変化する「乗算（ゲイン）」的な挙動を示唆しています。

- **現在のアプリ実装**:
  - 色の変化が弱く、コントラストが低い。
  - 暗くしても真っ黒にならず、明るくしても突き抜けるような明るさが出ない。

### 原因の特定
`packages/color-grading/src/curves/hue-curves.ts` 内の以下の処理が、DaVinci Resolveのような挙動を阻害しています。

1.  **Reinhardトーンカーブによる抑制**
    ```typescript
    const shoulder = (gainClamped * currentY) / (1 + (gainClamped - 1) * currentY);
    ```
    この計算式は、ハイライトが1.0を超えないように強く抑え込むため、Resolveのような「輝き」が出ません。

2.  **シャドウリフトによる底上げ**
    ```typescript
    const lifted = Math.max(0.03, shoulder);
    ```
    輝度の下限を0.03（3%）に固定しているため、カーブを一番下まで下げても完全な黒（0.0）になりません。

3.  **ゲイン範囲の制限**
    ```typescript
    const gainClamped = Math.min(2.0, Math.max(0.4, gainRaw));
    ```
    変化率が0.4倍〜2.0倍に制限されており、ダイナミックな変化が得られません。

## 2. 推奨される修正方針

DaVinci Resolveの挙動に近づけるため、複雑な補正処理を削除し、シンプルな「Y'（輝度）ベースの乗算ゲイン」に変更することを推奨します。

### 修正後のコードイメージ

`packages/color-grading/src/curves/hue-curves.ts` の `applyHueCurves` 関数内、Hue vs Luma 適用部分（62行目付近〜）を以下のように書き換えます。

```typescript
    // 4. Apply Hue vs Luma
    // カーブの評価（0.0 〜 1.0）
    const lumaVal = evaluateCurve(curves.hueVsLuma, normalizedHue, true);

    // シンプルなゲイン計算
    // カーブ中央(0.5) = 1.0倍（変化なし）
    // カーブ下限(0.0) = 0.0倍（完全な黒）
    // カーブ上限(1.0) = 2.0倍（明るく鮮やか）※必要に応じて3.0倍などに調整可能
    const gain = lumaVal * 2.0;

    // 現在の輝度（Y'）を計算（Rec.709係数）
    const currentY = 0.2126 * newR + 0.7152 * newG + 0.0722 * newB;

    // 目標輝度を計算（Reinhardトーンカーブやシャドウリフトは廃止）
    // 単純にゲインを掛けることで、明るさと共に彩度感も維持される
    const targetY = currentY * gain;

    // RGBを輝度比率に基づいてスケーリング
    // これにより色相(Hue)と彩度(Saturation)のバランスを保ったまま輝度を変更できる
    const scale = currentY > 1e-6 ? targetY / currentY : gain;
    
    newR *= scale;
    newG *= scale;
    newB *= scale;
```

## 3. 期待される効果

この修正により、以下の改善が見込まれます：

1.  **深い黒の表現**: カーブを下げることで、色が濁らずに深く沈むようになります。
2.  **鮮やかなハイライト**: カーブを上げることで、色が白飛びせずに鮮やかに明るくなります。
3.  **直感的な操作感**: カーブの形状がそのまま輝度の倍率として反映されるため、DaVinci Resolveに近い操作感が得られます。

## 4. 技術的背景

### 4.1. なぜ「乗算（ゲイン）」が重要か

DaVinci Resolveの画像（画像1、2）を見ると：
- **画像1（青を暗く）**: 青が濃く深い色合いを保持
- **画像2（シアンを明るく）**: シアンが鮮やかに発光

これは**乗算（Gain）方式**の特徴です。RGB値を同じ倍率でスケーリングすることで：
- 暗くする時：色が濃く沈む（グレーにならない）
- 明るくする時：彩度が維持される（白っぽくならない）

もし**加算（Offset）方式**を使うと：
- 暗くする時：色がグレーっぽく濁る
- 明るくする時：色が白っぽく薄くなる

これがDaVinci Resolveの実装と異なる結果をもたらします。

### 4.2. Y'（ガンマ補正済み輝度）について

**Y'** とは、Rec.709などで定義される**ガンマ補正済みの輝度成分**です。
係数 `0.2126 * R + 0.7152 * G + 0.0722 * B` で計算されます。

現在のコードは線形RGB空間でY'を計算していますが、理論的にはガンマ補正済み（非線形）RGB空間で計算すべきです。ただし、この違いが実際の見た目に与える影響は限定的である可能性があります。

## 5. 実装時の注意点

### 5.1. 段階的なアプローチを推奨

1.  **第1段階**: Reinhardトーンカーブとシャドウリフトの削除、単純ゲイン化
2.  **第2段階**: ゲイン範囲の調整（2.0倍 → 3.0倍など）
3.  **第3段階**: Y'計算タイミングの最適化（必要に応じて）

### 5.2. ゲイン係数の調整

提案コードでは `const gain = lumaVal * 2.0;` としていますが、DaVinci Resolveとの比較テストにより、以下のように調整できます：

```typescript
// より強い効果が必要な場合
const gain = lumaVal * 3.0;  // 0.0倍 〜 3.0倍

// より繊細な調整が必要な場合
const gain = lumaVal * 1.5;  // 0.0倍 〜 1.5倍
```

### 5.3. クランプ処理

RGB値は最終的に0.0〜1.0にクランプされますが、それは `clampRGB` 関数（91行目）で行われます。
ゲイン計算では意図的にクランプせず、自然なハイライトクリッピングを許容することで、Resolveに近い挙動が得られます。

## 6. さらなる改善案（オプション）

### 6.1. Y'計算タイミングの最適化

現在のコードはRGB値を線形化 → HSL変換 → Y'計算という流れですが、
理論的には**ガンマ補正済みRGB**でY'を計算すべきです。

**修正案**:
```typescript
// Hue/Sat 反映後のRGB（線形空間）
let [newR, newG, newB] = hslToRGB(newH, newS, l);

// 先にガンマ戻し（非線形空間へ）
if (USE_REC709_GAMMA) {
    newR = fromRec709Linear(newR);
    newG = fromRec709Linear(newG);
    newB = fromRec709Linear(newB);
}

// 非線形RGB空間でY'を計算
const currentY = 0.2126 * newR + 0.7152 * newG + 0.0722 * newB;

// Hue vs Luma適用
const lumaVal = evaluateCurve(curves.hueVsLuma, normalizedHue, true);
const gain = lumaVal * 2.0;
const targetY = currentY * gain;

const scale = currentY > 1e-6 ? targetY / currentY : gain;
newR *= scale;
newG *= scale;
newB *= scale;

// この場合、最後のガンマ戻し（85-89行目）は不要になる
```

ただし、この変更は慎重に検証する必要があります。色相・彩度の一貫性が保たれるか確認してください。

## 7. 検証手順

### 7.1. テストケース

比較用の色を含む画像（DaVinci Resolveのスクリーンショットと同じもの）を使用：
- 青（Hue 240°付近）
- シアン（Hue 180°付近）
- 緑（Hue 120°付近）

### 7.2. 確認ポイント

1.  カーブを最下点（Y=0）に下げた時：
    - 色が完全に黒くなるか
    - グレーっぽくならないか

2.  カーブを最上点（Y=1）に上げた時：
    - 色が鮮やかに明るくなるか
    - 白飛びせずに彩度が保たれるか

3.  中間点（Y=0.5）：
    - 元の色と変わらないか

## 8. まとめ

現在のHue vs Luma実装は、Reinhardトーンカーブとシャドウリフトにより、DaVinci Resolveのようなダイナミックな色変化が抑制されています。

**推奨される修正**:
1.  複雑な補正処理（Reinhard、シャドウリフト）を削除
2.  シンプルなY'ベースの乗算ゲインに変更
3.  段階的にテストしながらゲイン係数を調整

この修正により、DaVinci Resolveに近い「深い黒」と「鮮やかなハイライト」が実現できるはずです。

## 9. その他の考慮事項（補足）

### 9.1. カーブ補間方式の違い

**DaVinci Resolve**:
- デフォルトはベジェ系の独自カーブ（ハンドル付き）
- オプションでベジェ補間を選択可能

**現在の実装**:
- Catmull-Rom スプライン補間を使用
- `curve-math.ts`の`evaluateCurve`関数で実装

**影響**:
補間方式の違いにより、カーブの中間調の「効き」が異なる可能性があります。特に、カーブポイント間の補間が滑らかになりすぎたり、逆に急峻になりすぎたりする場合があります。

これは今回のゲイン計算の修正とは別の差分要因として認識しておく必要があります。完全にDaVinci Resolveと一致させるには、補間アルゴリズムの見直しも検討課題となります。

### 9.2. Rec.709 ガンマフラグのデフォルト設定

`hue-curves.ts` の6行目に以下の設定があります：

```typescript
const USE_REC709_GAMMA = true;
```

**推奨設定**: `true`（デフォルトのまま）

**理由**:
- DaVinci Resolveは通常、Rec.709やタイムラインのガンマ設定に基づいて処理します
- `true`に設定することで、ガンマ補正を考慮した色空間で処理が行われ、DaVinci Resolveの挙動に近づきます
- `false`にすると、線形RGB空間での処理となり、見た目が大きく変わる可能性があります

**注意**: この設定を変更する場合は、必ず視覚的に比較テストを行ってください。

### 9.3. ゲイン上限の安全弁（オプション）

現在の実装では、ゲインに上限を設けていません：

```typescript
const gain = lumaVal * 2.0;
const scale = currentY > 1e-6 ? targetY / currentY : gain;
// scaleに制限なし
```

**潜在的な問題**:
- RGB値が大幅に増幅されると、最終的な`clampRGB`処理でクリッピングが発生
- チャンネル間で不均等にクリッピングされると、色相がずれる可能性がある

**安全弁の提案**:

より安全な実装として、スケールに軽いリミットを設けることを検討できます：

```typescript
const gain = lumaVal * 2.0;
const targetY = currentY * gain;

// スケールに上限を設定（例: 3.0倍まで）
let scale = currentY > 1e-6 ? targetY / currentY : gain;
scale = Math.min(scale, 3.0);

newR *= scale;
newG *= scale;
newB *= scale;
```

**トレードオフ**:
- **メリット**: 色相ズレのリスクを軽減
- **デメリット**: 極端に明るくする場合の「発光感」が若干抑えられる

実際の使用感に応じて、上限値（3.0など）を調整してください。上限なしでも問題ない場合は、現在の実装のままで構いません。

## 10. 検証結果

### 実装完了後の確認事項

✅ **カーブを最下点（Y=0）に下げた時**:
- 色が完全に黒になることを確認済み
- グレーっぽくならず、期待通りの動作

🔄 **カーブを最上点（Y=1）に上げた時**:
- DaVinci Resolveと比較して、鮮やかさを確認中

🔄 **中間調の確認**:
- 補間方式の違いによる効きのズレを検証中

